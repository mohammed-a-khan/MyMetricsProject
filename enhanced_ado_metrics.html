<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADO Metrics Command Center</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --primary-color: #94196B;
            --primary-light: #B64B8C;
            --primary-dark: #6B1050;
            --primary-ultra-light: #F8E8F3;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --light-bg: #f8f9fa;
            --white-bg: #ffffff;
            --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--light-bg);
            color: var(--text-primary);
            min-height: 100vh;
            font-size: 14px;
            /* Increased from 11px */
        }

        /* Enhanced Font Sizes */
        h1 {
            font-size: 2rem;
        }

        h2 {
            font-size: 1.7rem;
        }

        h3 {
            font-size: 1.4rem;
        }

        h4 {
            font-size: 1.2rem;
        }

        h5 {
            font-size: 1rem;
        }

        h6 {
            font-size: 0.9rem;
        }

        .btn {
            font-size: 0.9rem;
            padding: 0.6rem 1.2rem;
        }

        .form-control,
        .form-select {
            font-size: 0.9rem;
            padding: 0.6rem 0.8rem;
        }

        .table {
            font-size: 0.85rem;
        }

        .table th {
            font-size: 0.8rem;
            padding: 0.7rem;
        }

        .table td {
            padding: 0.6rem;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 280px;
            /* Increased width */
            background: var(--white-bg);
            padding: 2rem 1.2rem;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            margin-bottom: 2.5rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-brand h1 {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--primary-color);
            margin: 0;
            margin-left: 1rem;
        }

        .nav-menu {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 0.8rem 1.2rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 12px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-size: 0.9rem;
        }

        .nav-link:hover {
            color: var(--primary-color);
            background: var(--primary-ultra-light);
            transform: translateX(5px);
        }

        .nav-link.active {
            color: var(--white-bg);
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
            box-shadow: 0 4px 15px rgba(148, 25, 107, 0.3);
        }

        .nav-link i {
            width: 24px;
            margin-right: 1rem;
            font-size: 1rem;
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            /* Adjusted for increased sidebar */
            padding: 2rem;
            min-height: 100vh;
            background-color: var(--light-bg);
        }

        /* Header */
        .page-header {
            background: var(--white-bg);
            border-radius: 18px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }

        .page-title {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        /* Current Context Indicator */
        .context-indicator {
            background: linear-gradient(135deg, var(--primary-ultra-light), rgba(148, 25, 107, 0.1));
            border-left: 4px solid var(--primary-color);
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .context-indicator .context-title {
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .context-indicator .context-details {
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Configuration Panel */
        .config-panel {
            background: var(--white-bg);
            border-radius: 18px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
        }

        .form-label {
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        /* Enhanced Multi-Select Components */
        .multi-select-container {
            position: relative;
        }

        .multi-select-input {
            min-height: 45px;
            padding: 0.6rem 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            align-items: center;
        }

        .multi-select-placeholder {
            color: var(--text-secondary);
            font-style: italic;
        }

        .selected-tag {
            background: var(--primary-color);
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 15px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .selected-tag .remove-tag {
            cursor: pointer;
            font-weight: bold;
        }

        .dropdown-menu-custom {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--white-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 3px;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: var(--card-shadow);
        }

        .dropdown-menu-custom.show {
            display: block;
        }

        .dropdown-option {
            padding: 0.7rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.9rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .dropdown-option:hover {
            background: var(--primary-ultra-light);
        }

        .dropdown-option.selected {
            background: var(--primary-color);
            color: white;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        /* Help Text */
        .help-text {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.3rem;
            font-style: italic;
        }

        /* Metric Cards */
        .metric-card {
            background: var(--white-bg);
            border-radius: 18px;
            padding: 1.5rem;
            height: 100%;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(148, 25, 107, 0.15);
        }

        .metric-icon {
            width: 55px;
            height: 55px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            background: var(--primary-ultra-light);
            color: var(--primary-color);
        }

        .metric-value {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .metric-label {
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Enhanced Progress Bars with Color Coding */
        .progress {
            height: 8px;
            background: var(--light-bg);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 0.7rem;
        }

        .progress-bar {
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            transition: width 0.6s ease;
        }

        .progress-bar.bg-success {
            background: linear-gradient(90deg, #28a745, #20c997) !important;
        }

        .progress-bar.bg-warning {
            background: linear-gradient(90deg, #ffc107, #fd7e14) !important;
        }

        .progress-bar.bg-danger {
            background: linear-gradient(90deg, #dc3545, #e74c3c) !important;
        }

        .progress-bar.bg-primary {
            background: linear-gradient(90deg, var(--primary-color), var(--primary-light)) !important;
        }

        /* Status Badges with Enhanced Colors */
        .status-badge {
            display: inline-block;
            padding: 0.3rem 0.7rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .status-new {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status-active {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status-in-progress {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status-resolved {
            background: #fff3e0;
            color: #f57c00;
        }

        .status-closed {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .status-done {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        /* Enhanced Data Tables */
        .data-table-container {
            background: var(--white-bg);
            border-radius: 18px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            overflow-x: auto;
        }

        .table-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 1.2rem;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .custom-table {
            width: 100%;
            margin-bottom: 0;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .custom-table thead th {
            background: linear-gradient(135deg, var(--primary-ultra-light), rgba(148, 25, 107, 0.1));
            color: var(--primary-color);
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.5px;
            border: none;
            padding: 1rem 0.8rem;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .custom-table tbody tr {
            transition: all 0.3s ease;
            border-bottom: 1px solid #f0f0f0;
        }

        .custom-table tbody tr:hover {
            background: var(--light-bg);
            transform: scale(1.002);
        }

        .custom-table tbody td {
            padding: 0.8rem;
            border: none;
            vertical-align: middle;
        }

        /* Custom Table Controls */
        .table-controls {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .table-search {
            flex: 1;
            min-width: 250px;
        }

        .table-filters {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .table-pagination {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.95);
            padding: 3rem;
            border-radius: 18px;
            box-shadow: var(--card-shadow);
            text-align: center;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--primary-ultra-light);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Section Headers */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .subsection-header {
            margin: 2rem 0 1rem 0;
            padding: 1rem;
            background: linear-gradient(135deg, var(--primary-ultra-light), rgba(148, 25, 107, 0.05));
            border-left: 4px solid var(--primary-color);
            border-radius: 8px;
        }

        .subsection-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-color);
            margin: 0;
        }

        /* Error and Info Messages */
        .error-container {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            color: #c53030;
        }

        .info-container {
            background: #ebf8ff;
            border: 1px solid #bee3f8;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            color: #2b6cb0;
        }

        /* Connection Status Indicator */
        .connection-status {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1001;
            padding: 0.7rem 1.2rem;
            border-radius: 25px;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: var(--card-shadow);
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .connection-status.testing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                width: 260px;
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
                padding: 1.5rem;
            }

            .page-title {
                font-size: 1.8rem;
            }

            .metric-value {
                font-size: 1.8rem;
            }

            .table-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }

        /* Custom Health Score Colors */
        .health-excellent {
            color: #28a745 !important;
        }

        .health-good {
            color: #17a2b8 !important;
        }

        .health-warning {
            color: #ffc107 !important;
        }

        .health-poor {
            color: #dc3545 !important;
        }

        /* Test Tags */
        .test-tag {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            margin: 0.1rem;
            border-radius: 15px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .test-tag.automated {
            background: #d4edda;
            color: #155724;
        }

        .test-tag.manual {
            background: #d1ecf1;
            color: #0c5460;
        }

        .test-tag.regression {
            background: #fff3cd;
            color: #856404;
        }

        .test-tag.smoke {
            background: #f8d7da;
            color: #721c24;
        }

        .test-tag.sit {
            background: #e2e3e5;
            color: #383d41;
        }

        .test-tag.uat {
            background: #d4e6f1;
            color: #2e5a94;
        }

        /* Priority and Severity Indicators */
        .priority-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5rem;
        }

        .priority-1 {
            background-color: #dc3545;
        }

        .priority-2 {
            background-color: #fd7e14;
        }

        .priority-3 {
            background-color: #ffc107;
        }

        .priority-4 {
            background-color: #28a745;
        }

        .severity-badge {
            font-size: 0.7rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-weight: 600;
        }

        .severity-critical {
            background: #dc3545;
            color: white;
        }

        .severity-high {
            background: #fd7e14;
            color: white;
        }

        .severity-medium {
            background: #ffc107;
            color: #333;
        }

        .severity-low {
            background: #28a745;
            color: white;
        }
    </style>
</head>

<body>
    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status disconnected">
        <i class="fas fa-circle me-1"></i>
        <span id="connectionText">Disconnected</span>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loadingSpinner">
        <div class="spinner"></div>
        <div class="mt-2">
            <strong id="loadingText">Loading data...</strong>
            <div class="text-muted mt-1" style="font-size: 0.8rem;">Please wait while we fetch your metrics</div>
        </div>
    </div>

    <!-- Sidebar Navigation -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-brand">
            <i class="fas fa-chart-line fa-2x" style="color: var(--primary-color);"></i>
            <h1>ADO Metrics</h1>
        </div>

        <nav>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="#" class="nav-link active" data-page="dashboard">
                        <i class="fas fa-tachometer-alt"></i>
                        <span>Project Health Dashboard</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="delivery">
                        <i class="fas fa-tasks"></i>
                        <span>Delivery Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="quality">
                        <i class="fas fa-bug"></i>
                        <span>Quality Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="testing">
                        <i class="fas fa-vial"></i>
                        <span>Testing Analytics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="team">
                        <i class="fas fa-users"></i>
                        <span>Team Performance</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="individual">
                        <i class="fas fa-user-check"></i>
                        <span>Individual Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="reports">
                        <i class="fas fa-file-alt"></i>
                        <span>Reports & Export</span>
                    </a>
                </li>
                <li class="nav-item mt-3 pt-3 border-top">
                    <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#settingsModal">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Page Header -->
        <div class="page-header">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="page-title">
                        <i class="fas fa-chart-line me-2"></i>
                        ADO Metrics Command Center
                    </h1>
                    <p class="text-secondary mb-0" style="font-size: 1rem;">
                        Real-time project analytics and comprehensive insights
                    </p>
                </div>
                <div class="col-md-4 text-end">
                    <button class="btn btn-primary" id="exportButton">
                        <i class="fas fa-download me-1"></i>Export Data
                    </button>
                    <button class="btn btn-outline-primary ms-2" id="refreshButton">
                        <i class="fas fa-sync-alt me-1"></i>Refresh
                    </button>
                </div>
            </div>
        </div>

        <!-- Current Context Indicator -->
        <div class="context-indicator" id="contextIndicator" style="display: none;">
            <div class="context-title">
                <i class="fas fa-info-circle me-1"></i>
                Current Data Context
            </div>
            <div class="context-details" id="contextDetails">
                <!-- Dynamic content will be inserted here -->
            </div>
        </div>

        <!-- Configuration Panel -->
        <div class="config-panel">
            <div class="row g-4">
                <div class="col-md-4">
                    <label class="form-label">
                        <i class="fas fa-sitemap me-1"></i>
                        Area Paths (Select up to 3)
                    </label>
                    <div class="multi-select-container" id="areaPathContainer">
                        <div class="multi-select-input" id="areaPathInput">
                            <span class="multi-select-placeholder">Select area paths...</span>
                        </div>
                        <div class="dropdown-menu-custom" id="areaPathDropdown">
                            <!-- Area path options will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <label class="form-label">
                        <i class="fas fa-calendar-alt me-1"></i>
                        Iterations (Select multiple)
                    </label>
                    <div class="multi-select-container" id="iterationContainer">
                        <div class="multi-select-input" id="iterationInput">
                            <span class="multi-select-placeholder">Select iterations...</span>
                        </div>
                        <div class="dropdown-menu-custom" id="iterationDropdown">
                            <!-- Iteration options will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <label class="form-label">
                        <i class="fas fa-vial me-1"></i>
                        Test Plan (Optional)
                    </label>
                    <select class="form-select" id="testPlanSelect">
                        <option value="">No test plan selected</option>
                    </select>
                </div>
                <div class="col-md-6">
                    <label class="form-label">
                        <i class="fas fa-clock me-1"></i>
                        Data Range
                    </label>
                    <select class="form-select" id="dataRangeSelect">
                        <option value="current">Current Period - Selected iterations or last 30 days</option>
                        <option value="last30">Last 30 Days - Rolling 30-day window</option>
                        <option value="last90">Last 90 Days - Rolling 90-day window</option>
                        <option value="custom">Custom Range - Specify exact dates</option>
                    </select>
                    <div class="help-text">
                        Select the time period for data analysis. Current Period uses selected iterations,
                        while rolling windows provide consistent time-based views.
                    </div>
                </div>
                <div class="col-md-6">
                    <label class="form-label">
                        <i class="fas fa-users me-1"></i>
                        Team Member Filter (Optional)
                    </label>
                    <select class="form-select" id="teamMemberFilter">
                        <option value="">All team members</option>
                    </select>
                    <div class="help-text">
                        Filter data to show metrics for specific team members or view aggregated team data.
                    </div>
                </div>

                <!-- Date range container will be dynamically added here -->
                <div class="col-12" id="dateRangeContainer"></div>

                <div class="col-12 mt-3">
                    <button class="btn btn-primary btn-lg" id="loadDataButton">
                        <i class="fas fa-sync-alt me-2"></i>Load Analytics Data
                    </button>
                    <button class="btn btn-outline-secondary ms-2" id="testConnectionButton">
                        <i class="fas fa-plug me-2"></i>Test Connection
                    </button>
                    <button class="btn btn-outline-info ms-2" id="clearFiltersButton">
                        <i class="fas fa-filter me-2"></i>Clear All Filters
                    </button>
                </div>
            </div>
        </div>

        <!-- Dashboard Content -->
        <div id="dashboardContent">
            <!-- Content will be dynamically loaded here -->
        </div>
    </main>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-cog me-2"></i>Configuration Settings
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <h6 class="mb-3">
                        <i class="fas fa-server me-1"></i>ADO Connection
                    </h6>
                    <div class="row g-3 mb-4">
                        <div class="col-md-6">
                            <label class="form-label">Organization</label>
                            <input type="text" class="form-control" id="adoOrganization"
                                placeholder="your-organization">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Project</label>
                            <input type="text" class="form-control" id="adoProject" placeholder="your-project">
                        </div>
                        <div class="col-12">
                            <label class="form-label">Personal Access Token</label>
                            <input type="password" class="form-control" id="adoPAT" placeholder="Enter your PAT">
                            <small class="text-muted">Your PAT is stored securely in browser storage</small>
                        </div>
                    </div>

                    <h6 class="mb-3">
                        <i class="fas fa-network-wired me-1"></i>Proxy Configuration (Optional)
                    </h6>
                    <div class="row g-3">
                        <div class="col-md-8">
                            <label class="form-label">Proxy Server</label>
                            <input type="text" class="form-control" id="proxyServer" placeholder="proxy.company.com">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Port</label>
                            <input type="number" class="form-control" id="proxyPort" placeholder="8080">
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveSettingsButton">
                        <i class="fas fa-save me-1"></i>Save Settings
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // Enhanced ADO Metrics Dashboard - Production Implementation
        class ADOMetricsDashboard {
            constructor() {
                this.config = this.loadConfiguration();
                this.selectedAreaPaths = [];
                this.selectedIterations = [];
                this.selectedTestPlan = null;
                this.selectedTeamMember = null;
                this.currentData = null;
                this.areaPaths = [];
                this.iterations = [];
                this.testPlans = [];
                this.teamMembers = [];
                this.connectionStatus = 'disconnected';
                this.metrics = {
                    delivery: {},
                    quality: {},
                    testing: {},
                    team: {},
                    individual: new Map(),
                    workItems: []
                };
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.loadSavedSettings();
                this.updateConnectionStatus('disconnected');
                this.showInitialState();

                // Auto-load if settings are configured
                if (this.config.organization && this.config.project && this.config.pat) {
                    this.testConnection();
                }
            }

            loadConfiguration() {
                const savedConfig = localStorage.getItem('adoConfig');
                return savedConfig ? JSON.parse(savedConfig) : {
                    organization: '',
                    project: '',
                    pat: '',
                    proxy: { server: '', port: '' }
                };
            }

            saveConfiguration() {
                localStorage.setItem('adoConfig', JSON.stringify(this.config));
            }

            loadSavedSettings() {
                document.getElementById('adoOrganization').value = this.config.organization || '';
                document.getElementById('adoProject').value = this.config.project || '';
                document.getElementById('adoPAT').value = this.config.pat || '';
                document.getElementById('proxyServer').value = this.config.proxy?.server || '';
                document.getElementById('proxyPort').value = this.config.proxy?.port || '';
            }

            setupEventListeners() {
                // Navigation
                document.querySelectorAll('.nav-link[data-page]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const page = e.currentTarget.dataset.page;
                        this.navigateToPage(page);
                    });
                });

                // Multi-select components
                this.setupMultiSelect('areaPath');
                this.setupMultiSelect('iteration');

                // Form controls
                document.getElementById('testPlanSelect').addEventListener('change', (e) => {
                    this.selectedTestPlan = e.target.value;
                });

                document.getElementById('teamMemberFilter').addEventListener('change', (e) => {
                    this.selectedTeamMember = e.target.value;
                });

                document.getElementById('dataRangeSelect').addEventListener('change', (e) => {
                    this.updateDateRangeOptions(e.target.value);
                });

                // Buttons
                document.getElementById('loadDataButton').addEventListener('click', () => {
                    this.loadData();
                });

                document.getElementById('testConnectionButton').addEventListener('click', () => {
                    this.testConnection();
                });

                document.getElementById('refreshButton').addEventListener('click', () => {
                    this.loadData();
                });

                document.getElementById('clearFiltersButton').addEventListener('click', () => {
                    this.clearAllFilters();
                });

                document.getElementById('saveSettingsButton').addEventListener('click', () => {
                    this.saveSettings();
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.multi-select-container')) {
                        document.querySelectorAll('.dropdown-menu-custom').forEach(dropdown => {
                            dropdown.classList.remove('show');
                        });
                    }
                });
            }

            setupMultiSelect(type) {
                const input = document.getElementById(`${type}Input`);
                const dropdown = document.getElementById(`${type}Dropdown`);

                input.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdown.classList.toggle('show');
                });
            }

            clearAllFilters() {
                this.selectedAreaPaths = [];
                this.selectedIterations = [];
                this.selectedTestPlan = null;
                this.selectedTeamMember = null;

                // Reset UI
                this.updateMultiSelectDisplay('areaPath');
                this.updateMultiSelectDisplay('iteration');
                document.getElementById('testPlanSelect').value = '';
                document.getElementById('teamMemberFilter').value = '';
                document.getElementById('dataRangeSelect').value = 'current';
                this.updateDateRangeOptions('current');

                this.showToast('All filters cleared', 'info');
            }

            updateMultiSelectDisplay(type) {
                const input = document.getElementById(`${type}Input`);
                const selected = type === 'areaPath' ? this.selectedAreaPaths : this.selectedIterations;

                input.innerHTML = '';

                if (selected.length === 0) {
                    const placeholder = document.createElement('span');
                    placeholder.className = 'multi-select-placeholder';
                    placeholder.textContent = type === 'areaPath' ? 'Select area paths...' : 'Select iterations...';
                    input.appendChild(placeholder);
                } else {
                    selected.forEach((item, index) => {
                        const tag = document.createElement('span');
                        tag.className = 'selected-tag';
                        tag.innerHTML = `
                            ${item.displayName || item.name}
                            <span class="remove-tag" data-index="${index}">&times;</span>
                        `;

                        tag.querySelector('.remove-tag').addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.removeSelection(type, index);
                        });

                        input.appendChild(tag);
                    });
                }
            }

            removeSelection(type, index) {
                if (type === 'areaPath') {
                    this.selectedAreaPaths.splice(index, 1);
                } else {
                    this.selectedIterations.splice(index, 1);
                }
                this.updateMultiSelectDisplay(type);
                this.populateDropdown(type);
            }

            addSelection(type, item) {
                const selected = type === 'areaPath' ? this.selectedAreaPaths : this.selectedIterations;
                const maxSelections = type === 'areaPath' ? 3 : Infinity;

                if (selected.length >= maxSelections) {
                    this.showToast(`Maximum ${maxSelections} ${type === 'areaPath' ? 'area paths' : 'iterations'} allowed`, 'warning');
                    return;
                }

                if (!selected.find(s => s.id === item.id)) {
                    selected.push(item);
                    this.updateMultiSelectDisplay(type);
                    this.populateDropdown(type);

                    if (type === 'areaPath') {
                        this.filterTestPlansByAreaPath();
                    }
                }
            }

            updateConnectionStatus(status, message = '') {
                this.connectionStatus = status;
                const statusElement = document.getElementById('connectionStatus');
                const textElement = document.getElementById('connectionText');

                statusElement.className = `connection-status ${status}`;

                switch (status) {
                    case 'connected':
                        textElement.innerHTML = '<i class="fas fa-check-circle me-1"></i>Connected';
                        break;
                    case 'testing':
                        textElement.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Testing...';
                        break;
                    case 'disconnected':
                    default:
                        textElement.innerHTML = '<i class="fas fa-times-circle me-1"></i>Disconnected';
                        break;
                }

                if (message) {
                    setTimeout(() => this.showToast(message, status === 'connected' ? 'success' : 'error'), 500);
                }
            }

            updateDateRangeOptions(rangeType) {
                const dateRangeContainer = document.getElementById('dateRangeContainer');
                dateRangeContainer.innerHTML = '';

                if (rangeType === 'custom') {
                    dateRangeContainer.innerHTML = `
                        <div class="row g-3">
                            <div class="col-md-6">
                                <label class="form-label">
                                    <i class="fas fa-calendar me-1"></i>Start Date
                                </label>
                                <input type="date" class="form-control" id="customStartDate" 
                                       value="${this.getDefaultStartDate()}">
                            </div>
                            <div class="col-md-6">
                                <label class="form-label">
                                    <i class="fas fa-calendar me-1"></i>End Date
                                </label>
                                <input type="date" class="form-control" id="customEndDate" 
                                       value="${this.getDefaultEndDate()}">
                            </div>
                        </div>
                    `;
                } else {
                    const rangeInfo = this.getDateRangeInfo(rangeType);
                    if (rangeInfo) {
                        dateRangeContainer.innerHTML = `
                            <div class="alert alert-info" style="margin-bottom: 0; font-size: 0.9rem;">
                                <i class="fas fa-info-circle me-2"></i>
                                <strong>${rangeInfo.label}:</strong> ${rangeInfo.description}
                            </div>
                        `;
                    }
                }
            }

            getDefaultStartDate() {
                const date = new Date();
                date.setMonth(date.getMonth() - 1);
                return date.toISOString().split('T')[0];
            }

            getDefaultEndDate() {
                const date = new Date();
                return date.toISOString().split('T')[0];
            }

            getDateRangeInfo(rangeType) {
                const endDate = new Date();
                let startDate = new Date();

                switch (rangeType) {
                    case 'current':
                        return {
                            label: 'Current Period',
                            description: 'Data from selected iterations, or last 30 days if no iterations selected'
                        };
                    case 'last30':
                        startDate.setDate(endDate.getDate() - 30);
                        return {
                            label: 'Last 30 Days',
                            description: `${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`
                        };
                    case 'last90':
                        startDate.setDate(endDate.getDate() - 90);
                        return {
                            label: 'Last 90 Days',
                            description: `${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`
                        };
                    default:
                        return null;
                }
            }

            updateContextIndicator() {
                const indicator = document.getElementById('contextIndicator');
                const details = document.getElementById('contextDetails');

                if (this.currentData && this.currentData.workItems.length > 0) {
                    const areaPaths = this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join(', ') || 'All';
                    const iterations = this.selectedIterations.map(it => it.displayName || it.name).join(', ') || 'All';
                    const testPlan = this.selectedTestPlan ? `Test Plan: ${this.getTestPlanName(this.selectedTestPlan)}` : 'No test plan';
                    const teamMember = this.selectedTeamMember ? `Team Member: ${this.selectedTeamMember}` : 'All team members';
                    const workItemCount = this.currentData.workItems.length;
                    const dateRange = this.getSelectedDateRange();

                    details.innerHTML = `
                        <div class="row g-2">
                            <div class="col-md-3"><strong>Area Paths:</strong> ${areaPaths}</div>
                            <div class="col-md-3"><strong>Iterations:</strong> ${iterations}</div>
                            <div class="col-md-3"><strong>Data Range:</strong> ${dateRange.type}</div>
                            <div class="col-md-3"><strong>Work Items:</strong> ${workItemCount}</div>
                        </div>
                        <div class="row g-2 mt-1">
                            <div class="col-md-6">${testPlan}</div>
                            <div class="col-md-6">${teamMember}</div>
                        </div>
                    `;
                    indicator.style.display = 'block';
                } else {
                    indicator.style.display = 'none';
                }
            }

            getTestPlanName(testPlanId) {
                const testPlan = this.testPlans.find(tp => tp.id === testPlanId);
                return testPlan ? testPlan.name : 'Unknown';
            }

            async testConnection() {
                if (!this.config.organization || !this.config.project || !this.config.pat) {
                    this.showToast('Please configure your ADO settings first', 'warning');
                    document.querySelector('[data-bs-target="#settingsModal"]').click();
                    return;
                }

                this.updateConnectionStatus('testing');

                try {
                    const projectsResponse = await this.makeADORequest('projects?api-version=7.0');

                    if (projectsResponse && projectsResponse.value) {
                        const projectExists = projectsResponse.value.some(p =>
                            p.name.toLowerCase() === this.config.project.toLowerCase()
                        );

                        if (!projectExists) {
                            throw new Error(`Project '${this.config.project}' not found in organization '${this.config.organization}'`);
                        }

                        try {
                            await this.makeADORequest('wit/classificationnodes?api-version=7.0');
                            this.updateConnectionStatus('connected', 'Successfully connected to ADO');
                            await this.loadInitialData();
                        } catch (projectError) {
                            throw new Error(`Cannot access project '${this.config.project}': ${projectError.message}`);
                        }
                    } else {
                        throw new Error('Invalid response from ADO');
                    }
                } catch (error) {
                    console.error('Connection test failed:', error);
                    let errorMessage = error.message;

                    if (error.message.includes('404')) {
                        if (error.message.includes('projects')) {
                            errorMessage = `Organization '${this.config.organization}' not found or PAT doesn't have access`;
                        } else {
                            errorMessage = `Project '${this.config.project}' not found or no access`;
                        }
                    } else if (error.message.includes('401')) {
                        errorMessage = 'Invalid Personal Access Token or insufficient permissions';
                    } else if (error.message.includes('403')) {
                        errorMessage = 'Access denied. Check PAT permissions for the organization/project';
                    }

                    this.updateConnectionStatus('disconnected', `Connection failed: ${errorMessage}`);
                }
            }

            async loadInitialData() {
                try {
                    this.showLoading(true, 'Loading configuration data...');

                    await this.loadAreaPaths();
                    await this.loadIterations();
                    await this.loadTestPlans();
                    await this.loadTeamMembers();

                    this.showLoading(false);
                } catch (error) {
                    console.error('Error loading initial data:', error);
                    this.showLoading(false);
                    this.showToast('Error loading initial data', 'error');
                }
            }

            async loadAreaPaths() {
                try {
                    const response = await this.makeADORequest('wit/classificationnodes/areas?$depth=3&api-version=7.0');
                    this.areaPaths = this.extractAreaPaths(response);
                    this.populateDropdown('areaPath');
                } catch (error) {
                    console.error('Error loading area paths:', error);
                    this.showToast('Error loading area paths', 'error');
                }
            }

            extractAreaPaths(response) {
                const paths = [];

                const extractRecursive = (node, parentPath = '') => {
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => {
                            const currentPath = parentPath ? `${parentPath}\\\\${child.name}` : child.name;

                            if (child.children && child.children.length > 0) {
                                child.children.forEach(grandChild => {
                                    const fullPath = `${currentPath}\\\\${grandChild.name}`;
                                    paths.push({
                                        id: grandChild.id,
                                        name: grandChild.name,
                                        fullPath: `${response.name}\\\\${fullPath}`,
                                        displayName: child.name,
                                        parentPath: `${response.name}\\\\${currentPath}`,
                                        leafName: grandChild.name
                                    });
                                });
                            } else {
                                paths.push({
                                    id: child.id,
                                    name: child.name,
                                    fullPath: `${response.name}\\\\${currentPath}`,
                                    displayName: child.name,
                                    parentPath: `${response.name}\\\\${currentPath}`,
                                    leafName: child.name
                                });
                            }
                        });
                    }
                };

                extractRecursive(response);

                const groupedPaths = new Map();
                paths.forEach(path => {
                    if (!groupedPaths.has(path.displayName)) {
                        groupedPaths.set(path.displayName, {
                            id: path.id,
                            name: path.name,
                            displayName: path.displayName,
                            parentPath: path.parentPath,
                            subAreas: []
                        });
                    }
                    groupedPaths.get(path.displayName).subAreas.push({
                        name: path.leafName,
                        fullPath: path.fullPath
                    });
                });

                return Array.from(groupedPaths.values());
            }

            async loadIterations() {
                try {
                    const response = await this.makeADORequest('wit/classificationnodes/iterations?$depth=3&api-version=7.0');
                    this.iterations = this.extractIterations(response);
                    this.populateDropdown('iteration');
                } catch (error) {
                    console.error('Error loading iterations:', error);
                    this.showToast('Error loading iterations', 'error');
                }
            }

            extractIterations(response) {
                const iterations = [];

                const extractRecursive = (node, parentPath = '') => {
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => {
                            if (child.children && child.children.length > 0) {
                                child.children.forEach(grandChild => {
                                    if (grandChild.children && grandChild.children.length > 0) {
                                        grandChild.children.forEach(iteration => {
                                            if (iteration.attributes && iteration.attributes.startDate) {
                                                let cleanPath = iteration.path;
                                                if (cleanPath.startsWith('\\')) {
                                                    cleanPath = cleanPath.substring(1);
                                                }
                                                cleanPath = cleanPath.replace(/\\Iteration\\/g, '\\\\').replace(/\\/g, '\\\\');

                                                iterations.push({
                                                    id: iteration.id,
                                                    name: iteration.name,
                                                    fullPath: cleanPath,
                                                    startDate: new Date(iteration.attributes.startDate),
                                                    finishDate: new Date(iteration.attributes.finishDate),
                                                    displayName: iteration.name,
                                                    parentName: grandChild.name
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                };

                extractRecursive(response);
                iterations.sort((a, b) => b.startDate - a.startDate);
                return iterations;
            }

            async loadTestPlans() {
                try {
                    const response = await this.makeADORequest('testplan/plans?api-version=7.0');
                    this.testPlans = response.value || [];
                    this.populateTestPlansDropdown();
                } catch (error) {
                    console.error('Error loading test plans:', error);
                }
            }

            async loadTeamMembers() {
                try {
                    // This would typically load from team APIs or work item assignees
                    this.teamMembers = [];
                    this.populateTeamMemberDropdown();
                } catch (error) {
                    console.error('Error loading team members:', error);
                }
            }

            populateDropdown(type) {
                const dropdown = document.getElementById(`${type}Dropdown`);
                const items = type === 'areaPath' ? this.areaPaths : this.iterations;
                const selected = type === 'areaPath' ? this.selectedAreaPaths : this.selectedIterations;

                dropdown.innerHTML = '';

                // Add current iteration option for iterations
                if (type === 'iteration') {
                    const currentDiv = document.createElement('div');
                    currentDiv.className = 'dropdown-option';
                    currentDiv.textContent = 'Current Iteration';
                    currentDiv.addEventListener('click', () => {
                        this.addSelection(type, {
                            name: '@currentIteration',
                            displayName: 'Current Iteration',
                            fullPath: '@currentIteration',
                            id: '@current'
                        });
                        dropdown.classList.remove('show');
                    });
                    dropdown.appendChild(currentDiv);
                }

                items.forEach(item => {
                    const isSelected = selected.find(s => s.id === item.id);
                    if (!isSelected) {
                        const div = document.createElement('div');
                        div.className = 'dropdown-option';
                        div.textContent = item.displayName || item.name;
                        div.addEventListener('click', () => {
                            this.addSelection(type, item);
                            dropdown.classList.remove('show');
                        });
                        dropdown.appendChild(div);
                    }
                });
            }

            populateTestPlansDropdown() {
                const select = document.getElementById('testPlanSelect');
                select.innerHTML = '<option value="">No test plan selected</option>';

                this.testPlans.forEach(plan => {
                    const option = document.createElement('option');
                    option.value = plan.id;
                    option.textContent = plan.name;
                    select.appendChild(option);
                });
            }

            populateTeamMemberDropdown() {
                const select = document.getElementById('teamMemberFilter');
                select.innerHTML = '<option value="">All team members</option>';

                this.teamMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.id;
                    option.textContent = member.displayName;
                    select.appendChild(option);
                });
            }

            filterTestPlansByAreaPath() {
                if (this.selectedAreaPaths.length === 0) return;

                const select = document.getElementById('testPlanSelect');
                select.innerHTML = '<option value="">No test plan selected</option>';

                const filteredPlans = this.testPlans.filter(plan => {
                    if (!plan.areaPath) return false;

                    return this.selectedAreaPaths.some(areaPath => {
                        if (areaPath.subAreas) {
                            return areaPath.subAreas.some(subArea =>
                                plan.areaPath.includes(subArea.name) ||
                                plan.areaPath.includes(areaPath.displayName)
                            );
                        }
                        return plan.areaPath.includes(areaPath.displayName) ||
                            plan.areaPath.includes(areaPath.name);
                    });
                });

                filteredPlans.forEach(plan => {
                    const option = document.createElement('option');
                    option.value = plan.id;
                    option.textContent = plan.name;
                    select.appendChild(option);
                });

                if (this.testPlans.length > 0 && filteredPlans.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = `No test plans found for selected area paths`;
                    option.disabled = true;
                    select.appendChild(option);
                }
            }

            getSelectedDateRange() {
                const rangeType = document.getElementById('dataRangeSelect').value;
                const endDate = new Date();
                let startDate = new Date();

                switch (rangeType) {
                    case 'current':
                        if (this.selectedIterations.length > 0) {
                            const dates = this.selectedIterations
                                .filter(iter => iter.startDate && iter.finishDate)
                                .map(iter => ({ start: iter.startDate, end: iter.finishDate }));

                            if (dates.length > 0) {
                                return {
                                    start: new Date(Math.min(...dates.map(d => d.start))),
                                    end: new Date(Math.max(...dates.map(d => d.end))),
                                    type: 'iteration'
                                };
                            }
                        }
                        startDate.setDate(endDate.getDate() - 30);
                        return { start: startDate, end: endDate, type: 'relative' };

                    case 'last30':
                        startDate.setDate(endDate.getDate() - 30);
                        return { start: startDate, end: endDate, type: 'relative' };

                    case 'last90':
                        startDate.setDate(endDate.getDate() - 90);
                        return { start: startDate, end: endDate, type: 'relative' };

                    case 'custom':
                        const customStart = document.getElementById('customStartDate')?.value;
                        const customEnd = document.getElementById('customEndDate')?.value;

                        if (!customStart || !customEnd) {
                            throw new Error('Please select both start and end dates for custom range');
                        }

                        return {
                            start: new Date(customStart),
                            end: new Date(customEnd),
                            type: 'custom'
                        };

                    default:
                        startDate.setDate(endDate.getDate() - 30);
                        return { start: startDate, end: endDate, type: 'default' };
                }
            }

            buildAreaPathFilter() {
                if (this.selectedAreaPaths.length === 0) {
                    return null;
                }

                try {
                    const pathConditions = [];

                    this.selectedAreaPaths.forEach(areaPath => {
                        if (areaPath.subAreas && areaPath.subAreas.length > 1) {
                            const subAreaPaths = areaPath.subAreas.map(sa => `'${sa.fullPath}'`).join(', ');
                            pathConditions.push(`[System.AreaPath] IN (${subAreaPaths})`);
                        } else if (areaPath.subAreas && areaPath.subAreas.length === 1) {
                            pathConditions.push(`[System.AreaPath] = '${areaPath.subAreas[0].fullPath}'`);
                        } else {
                            const pathToUse = areaPath.parentPath || areaPath.fullPath;
                            pathConditions.push(`[System.AreaPath] = '${pathToUse}'`);
                        }
                    });

                    return pathConditions.length > 1 ? `(${pathConditions.join(' OR ')})` : pathConditions[0];
                } catch (error) {
                    console.error('Error building area path filter:', error);
                    return `[System.AreaPath] CONTAINS '${this.selectedAreaPaths[0].displayName || this.selectedAreaPaths[0].name}'`;
                }
            }

            buildIterationFilter() {
                if (this.selectedIterations.length === 0) {
                    return null;
                }

                try {
                    const iterationConditions = [];
                    this.selectedIterations.forEach(iteration => {
                        if (iteration.fullPath === '@currentIteration') {
                            iterationConditions.push(`[System.IterationPath] UNDER @currentIteration`);
                        } else {
                            iterationConditions.push(`[System.IterationPath] = '${iteration.fullPath}'`);
                        }
                    });

                    return iterationConditions.length > 1 ? `(${iterationConditions.join(' OR ')})` : iterationConditions[0];
                } catch (error) {
                    console.error('Error building iteration filter:', error);
                    return `[System.IterationPath] = '${this.selectedIterations[0].fullPath}'`;
                }
            }

            async loadData() {
                if (this.selectedAreaPaths.length === 0) {
                    this.showToast('Please select at least one area path', 'warning');
                    return;
                }

                if (this.selectedIterations.length === 0) {
                    this.showToast('Please select at least one iteration', 'warning');
                    return;
                }

                this.showLoading(true, 'Loading work items and calculating metrics...');

                try {
                    const dateRange = this.getSelectedDateRange();
                    const workItems = await this.loadWorkItemsWithFilters(dateRange);

                    if (workItems.length === 0) {
                        this.showToast('No work items found for the selected criteria', 'info');
                        this.showNoDataMessage();
                        return;
                    }

                    this.currentData = await this.processWorkItems(workItems);
                    this.calculateAllMetrics();
                    this.updateContextIndicator();
                    this.populateTeamMemberFilter();

                    const activePage = document.querySelector('.nav-link.active')?.dataset.page || 'dashboard';
                    this.navigateToPage(activePage);

                    this.showToast(`Loaded ${workItems.length} work items successfully`, 'success');

                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showToast(`Error loading data: ${error.message}`, 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            async loadWorkItemsWithFilters(dateRange) {
                try {
                    let whereConditions = [`[System.TeamProject] = '${this.config.project}'`];

                    // Add area path filter
                    const areaPathFilter = this.buildAreaPathFilter();
                    if (areaPathFilter) {
                        whereConditions.push(areaPathFilter);
                    }

                    // Add iteration filter
                    const iterationFilter = this.buildIterationFilter();
                    if (iterationFilter) {
                        whereConditions.push(iterationFilter);
                    }

                    // Add date range filter for custom/relative ranges
                    if (dateRange.type === 'custom' || dateRange.type === 'relative') {
                        const startDateStr = dateRange.start.toISOString().split('T')[0];
                        const endDateStr = dateRange.end.toISOString().split('T')[0];
                        whereConditions.push(`[System.ChangedDate] >= '${startDateStr}'`);
                        whereConditions.push(`[System.ChangedDate] <= '${endDateStr}T23:59:59.999Z'`);
                    }

                    // Add work item type filter
                    whereConditions.push(`[System.WorkItemType] IN ('User Story', 'Bug', 'Task', 'Feature', 'Epic', 'Product Backlog Item', 'Test Case')`);

                    // Add team member filter if selected
                    if (this.selectedTeamMember) {
                        whereConditions.push(`[System.AssignedTo] = '${this.selectedTeamMember}'`);
                    }

                    const query = `SELECT [System.Id] FROM WorkItems WHERE ${whereConditions.join(' AND ')} ORDER BY [System.ChangedDate] DESC`;

                    console.log('WIQL Query with all filters:', query);

                    const wiql = { query };
                    const queryResult = await this.makeADORequest('wit/wiql?$top=500&api-version=7.0', 'POST', wiql);

                    if (!queryResult.workItems || queryResult.workItems.length === 0) {
                        return [];
                    }

                    // Get work item details in batches
                    const allWorkItems = [];
                    const batchSize = 200;

                    for (let i = 0; i < queryResult.workItems.length; i += batchSize) {
                        const batch = queryResult.workItems.slice(i, i + batchSize);
                        const ids = batch.map(wi => wi.id).join(',');

                        try {
                            const workItemsResponse = await this.makeADORequest(
                                `wit/workitems?ids=${ids}&$expand=relations&api-version=7.0`
                            );
                            allWorkItems.push(...(workItemsResponse.value || []));
                        } catch (error) {
                            console.error('Error fetching work item batch:', error);
                        }
                    }

                    return allWorkItems;
                } catch (error) {
                    console.error('Error in loadWorkItemsWithFilters:', error);
                    throw error;
                }
            }

            async processWorkItems(workItems) {
                const data = {
                    workItems: workItems,
                    userStories: [],
                    features: [],
                    epics: [],
                    tasks: [],
                    bugs: [],
                    defects: [],
                    testCases: [],
                    testTasks: [],
                    releases: new Map() // For date-based releases
                };

                // Categorize work items and extract release information
                for (const item of workItems) {
                    const type = item.fields['System.WorkItemType'];
                    const title = (item.fields['System.Title'] || '').toLowerCase();
                    const tags = (item.fields['System.Tags'] || '').toLowerCase();

                    // Extract release dates from tags
                    this.extractReleaseInfo(item, data.releases);

                    switch (type) {
                        case 'User Story':
                        case 'Product Backlog Item':
                            data.userStories.push(item);
                            break;
                        case 'Feature':
                            data.features.push(item);
                            break;
                        case 'Epic':
                            data.epics.push(item);
                            break;
                        case 'Task':
                            if (this.isTestingTask(title)) {
                                data.testTasks.push(item);
                            }
                            data.tasks.push(item);
                            break;
                        case 'Bug':
                            if (this.isProductionIssue(item)) {
                                data.defects.push(item);
                            } else {
                                data.bugs.push(item);
                            }
                            break;
                        case 'Test Case':
                            data.testCases.push(item);
                            break;
                    }
                }

                // Load additional test data if test plan is selected
                if (this.selectedTestPlan) {
                    try {
                        const testData = await this.loadTestPlanData(this.selectedTestPlan);
                        data.testCases = [...data.testCases, ...testData.testCases];
                        data.testResults = testData.testResults || [];
                        data.testSuites = testData.testSuites || [];
                    } catch (error) {
                        console.warn('Error loading test plan data:', error);
                    }
                }

                return data;
            }

            extractReleaseInfo(item, releases) {
                const tags = item.fields['System.Tags'] || '';
                const title = item.fields['System.Title'] || '';

                // Enhanced date pattern matching
                const datePatterns = [
                    /(\d{1,2})[.\-\/](\d{1,2})[.\-\/](\d{4})/g,  // MM.DD.YYYY, MM-DD-YYYY, MM/DD/YYYY
                    /(\d{4})[.\-\/](\d{1,2})[.\-\/](\d{1,2})/g,  // YYYY.MM.DD, YYYY-MM-DD, YYYY/MM/DD
                    /v?(\d+)\.(\d+)\.(\d+)/g,                     // v1.2.3, 1.2.3
                    /release[:\s]*(\d{1,2})[.\-\/](\d{1,2})[.\-\/](\d{4})/gi,
                    /sprint[:\s]*(\d+)/gi
                ];

                const textToSearch = `${tags} ${title}`.toLowerCase();

                datePatterns.forEach(pattern => {
                    let match;
                    while ((match = pattern.exec(textToSearch)) !== null) {
                        let releaseKey = match[0].trim();

                        // Try to parse as a proper date
                        let releaseDate = null;
                        if (match[1] && match[2] && match[3]) {
                            // Check if it's a version pattern
                            if (pattern.source.includes('v?')) {
                                releaseKey = `v${match[1]}.${match[2]}.${match[3]}`;
                            } else {
                                // Try to create a date
                                try {
                                    if (match[3].length === 4) {
                                        // Month/Day/Year format
                                        releaseDate = new Date(match[3], match[1] - 1, match[2]);
                                    } else {
                                        // Year/Month/Day format
                                        releaseDate = new Date(match[1], match[2] - 1, match[3]);
                                    }

                                    if (releaseDate && !isNaN(releaseDate)) {
                                        releaseKey = releaseDate.toLocaleDateString();
                                    }
                                } catch (e) {
                                    // Keep original match as key
                                }
                            }
                        }

                        if (!releases.has(releaseKey)) {
                            releases.set(releaseKey, {
                                name: releaseKey,
                                date: releaseDate,
                                workItems: [],
                                userStories: [],
                                features: [],
                                bugs: [],
                                tasks: []
                            });
                        }

                        const release = releases.get(releaseKey);
                        release.workItems.push(item);

                        // Categorize by type
                        const type = item.fields['System.WorkItemType'];
                        if (type === 'User Story' || type === 'Product Backlog Item') {
                            release.userStories.push(item);
                        } else if (type === 'Feature') {
                            release.features.push(item);
                        } else if (type === 'Bug') {
                            release.bugs.push(item);
                        } else if (type === 'Task') {
                            release.tasks.push(item);
                        }
                    }
                });
            }

            isTestingTask(title) {
                const testingKeywords = [
                    'sit testing', 'sit-testing', 'sit_testing',
                    'uat testing', 'uat-testing', 'uat_testing',
                    'test execution', 'test case', 'testing',
                    'qa testing', 'quality assurance', 'regression test',
                    'smoke test', 'integration test', 'system test'
                ];
                return testingKeywords.some(keyword => title.includes(keyword));
            }

            isProductionIssue(bug) {
                const tags = (bug.fields['System.Tags'] || '').toLowerCase();
                const areaPath = (bug.fields['System.AreaPath'] || '').toLowerCase();
                const title = (bug.fields['System.Title'] || '').toLowerCase();

                return tags.includes('production') || tags.includes('prod') ||
                    areaPath.includes('production') || areaPath.includes('prod') ||
                    title.includes('production') || title.includes('prod') ||
                    tags.includes('hotfix') || title.includes('hotfix') ||
                    tags.includes('defect') || title.includes('live');
            }

            getTestCaseAutomationStatus(testCase) {
                const tags = (testCase.fields['System.Tags'] || '').toLowerCase();
                const title = (testCase.fields['System.Title'] || '').toLowerCase();

                // Check for automation indicators
                if (tags.includes('automated') || tags.includes('automation') ||
                    title.includes('automated') || title.includes('automation')) {
                    return 'automated';
                }

                // Check for manual indicators
                const manualIndicators = [
                    'manual only', 'manual-only', 'manual_only',
                    'not automated', 'not-automated', 'not_automated',
                    'manual', 'manual test'
                ];

                if (manualIndicators.some(indicator => tags.includes(indicator) || title.includes(indicator))) {
                    return 'manual';
                }

                // Check automation field if exists
                const automationField = testCase.fields['Microsoft.VSTS.TCM.AutomationStatus'];
                if (automationField) {
                    if (automationField.toLowerCase().includes('automated')) {
                        return 'automated';
                    } else if (automationField.toLowerCase().includes('not automated')) {
                        return 'manual';
                    }
                }

                // Default to manual if no clear indication
                return 'manual';
            }

            getTestCaseCategories(testCase) {
                const tags = (testCase.fields['System.Tags'] || '').toLowerCase();
                const title = (testCase.fields['System.Title'] || '').toLowerCase();
                const categories = [];

                const categoryMap = {
                    'regression': ['regression', 'regress'],
                    'smoke': ['smoke', 'sanity'],
                    'integration': ['integration', 'integrate'],
                    'unit': ['unit test', 'unit'],
                    'api': ['api', 'service', 'rest'],
                    'ui': ['ui', 'user interface', 'frontend'],
                    'e2e': ['e2e', 'end to end', 'end-to-end'],
                    'performance': ['performance', 'load', 'stress'],
                    'security': ['security', 'auth', 'authentication'],
                    'sit': ['sit', 'system integration'],
                    'uat': ['uat', 'user acceptance']
                };

                Object.entries(categoryMap).forEach(([category, keywords]) => {
                    if (keywords.some(keyword => tags.includes(keyword) || title.includes(keyword))) {
                        categories.push(category);
                    }
                });

                return categories.length > 0 ? categories : ['general'];
            }

            async loadTestPlanData(testPlanId) {
                try {
                    const testPlanResults = {
                        testCases: [],
                        testSuites: [],
                        testRuns: [],
                        testResults: []
                    };

                    // Get test plan details
                    const testPlan = await this.makeADORequest(`testplan/Plans/${testPlanId}?api-version=7.0`);

                    // Get all test suites in the test plan
                    const suitesResponse = await this.makeADORequest(`testplan/Plans/${testPlanId}/suites?api-version=7.0`);
                    testPlanResults.testSuites = suitesResponse.value || [];

                    // Get test cases from all suites
                    for (const suite of testPlanResults.testSuites) {
                        try {
                            const testCasesResponse = await this.makeADORequest(
                                `testplan/Plans/${testPlanId}/Suites/${suite.id}/TestCase?api-version=7.0`
                            );

                            if (testCasesResponse.value) {
                                for (const testCaseRef of testCasesResponse.value) {
                                    try {
                                        const testCaseDetail = await this.makeADORequest(
                                            `wit/workitems/${testCaseRef.workItem.id}?$expand=relations&api-version=7.0`
                                        );

                                        testCaseDetail.suiteId = suite.id;
                                        testCaseDetail.suiteName = suite.name;
                                        testCaseDetail.testPlanId = testPlanId;

                                        testPlanResults.testCases.push(testCaseDetail);
                                    } catch (tcError) {
                                        console.warn(`Error loading test case ${testCaseRef.workItem.id}:`, tcError);
                                    }
                                }
                            }
                        } catch (suiteError) {
                            console.warn(`Error loading test cases for suite ${suite.id}:`, suiteError);
                        }
                    }

                    // Get test runs for this test plan
                    try {
                        const testRunsResponse = await this.makeADORequest(
                            `test/runs?planId=${testPlanId}&api-version=7.0`
                        );
                        testPlanResults.testRuns = testRunsResponse.value || [];

                        // Get test results for recent runs
                        for (const testRun of testPlanResults.testRuns.slice(0, 10)) {
                            try {
                                const resultsResponse = await this.makeADORequest(
                                    `test/Runs/${testRun.id}/results?api-version=7.0`
                                );

                                if (resultsResponse.value) {
                                    testPlanResults.testResults.push(...resultsResponse.value.map(result => ({
                                        ...result,
                                        testRunId: testRun.id,
                                        testRunName: testRun.name,
                                        testPlanId: testPlanId
                                    })));
                                }
                            } catch (resultError) {
                                console.warn(`Error loading results for test run ${testRun.id}:`, resultError);
                            }
                        }
                    } catch (runError) {
                        console.warn(`Error loading test runs for plan ${testPlanId}:`, runError);
                    }

                    return testPlanResults;
                } catch (error) {
                    console.error('Error loading test plan data:', error);
                    throw error;
                }
            }

            calculateAllMetrics() {
                this.calculateDeliveryMetrics();
                this.calculateQualityMetrics();
                this.calculateTestingMetrics();
                this.calculateTeamMetrics();
                this.calculateIndividualMetrics();
            }

            calculateDeliveryMetrics() {
                const stories = this.currentData.userStories || [];
                const features = this.currentData.features || [];
                const epics = this.currentData.epics || [];
                const tasks = this.currentData.tasks || [];

                const completedStories = stories.filter(s =>
                    ['Done', 'Closed', 'Resolved'].includes(s.fields['System.State'])
                );

                const completedFeatures = features.filter(f =>
                    ['Done', 'Closed', 'Resolved'].includes(f.fields['System.State'])
                );

                const completedEpics = epics.filter(e =>
                    ['Done', 'Closed', 'Resolved'].includes(e.fields['System.State'])
                );

                const completedTasks = tasks.filter(t =>
                    ['Done', 'Closed', 'Resolved'].includes(t.fields['System.State'])
                );

                const totalPoints = stories.reduce((sum, s) =>
                    sum + (s.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0
                );

                const completedPoints = completedStories.reduce((sum, s) =>
                    sum + (s.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0
                );

                const blockedItems = this.currentData.workItems.filter(item => {
                    const tags = (item.fields['System.Tags'] || '').toLowerCase();
                    const state = item.fields['System.State'];
                    return tags.includes('blocked') || tags.includes('impediment') || state === 'Blocked';
                }).length;

                this.metrics.delivery = {
                    totalStories: stories.length,
                    completedStories: completedStories.length,
                    totalFeatures: features.length,
                    completedFeatures: completedFeatures.length,
                    totalEpics: epics.length,
                    completedEpics: completedEpics.length,
                    totalTasks: tasks.length,
                    completedTasks: completedTasks.length,
                    totalPoints,
                    completedPoints,
                    completionRate: stories.length > 0 ? (completedStories.length / stories.length) * 100 : 0,
                    pointsCompletionRate: totalPoints > 0 ? (completedPoints / totalPoints) * 100 : 0,
                    velocity: completedPoints,
                    blockedItems,
                    workInProgress: stories.filter(s => ['Active', 'In Progress'].includes(s.fields['System.State'])).length,
                    releases: this.currentData.releases
                };
            }

            calculateQualityMetrics() {
                if (!this.currentData) return;

                const bugs = this.currentData.bugs || [];
                const defects = this.currentData.defects || [];
                const allIssues = [...bugs, ...defects];

                // Calculate bug density properly
                const totalStoryPoints = (this.currentData.userStories || []).reduce((sum, story) =>
                    sum + (story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0);

                const completedStoryPoints = (this.currentData.userStories || [])
                    .filter(story => ['Done', 'Closed', 'Resolved'].includes(story.fields['System.State']))
                    .reduce((sum, story) => sum + (story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0);

                const bugDensityPerStoryPoint = totalStoryPoints > 0 ? bugs.length / totalStoryPoints : 0;
                const defectLeakageRate = bugs.length > 0 ? (defects.length / (bugs.length + defects.length)) * 100 : 0;

                // Categorize by severity and priority
                const severityCount = { critical: 0, high: 0, medium: 0, low: 0 };
                const priorityCount = { 1: 0, 2: 0, 3: 0, 4: 0 };
                const environmentCount = { dev: 0, qa: 0, uat: 0, prod: 0 };

                allIssues.forEach(issue => {
                    const severity = issue.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    const priority = issue.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const env = this.detectEnvironment(issue);

                    if (severity.includes('1') || severity.toLowerCase().includes('critical')) severityCount.critical++;
                    else if (severity.includes('2') || severity.toLowerCase().includes('high')) severityCount.high++;
                    else if (severity.includes('3') || severity.toLowerCase().includes('medium')) severityCount.medium++;
                    else severityCount.low++;

                    priorityCount[priority] = (priorityCount[priority] || 0) + 1;
                    environmentCount[env] = (environmentCount[env] || 0) + 1;
                });

                this.metrics.quality = {
                    totalBugs: bugs.length,
                    totalDefects: defects.length,
                    criticalBugs: severityCount.critical,
                    highBugs: severityCount.high,
                    bugsByEnvironment: environmentCount,
                    bugsBySeverity: severityCount,
                    bugsByPriority: priorityCount,
                    defectEscapeRate: defectLeakageRate,
                    bugDensity: bugDensityPerStoryPoint,
                    bugDensityPerStoryPoint: bugDensityPerStoryPoint,
                    defectLeakage: {
                        rate: defectLeakageRate,
                        count: defects.length
                    }
                };
            }

            detectEnvironment(bug) {
                const tags = (bug.fields['System.Tags'] || '').toLowerCase();
                const areaPath = (bug.fields['System.AreaPath'] || '').toLowerCase();
                const title = (bug.fields['System.Title'] || '').toLowerCase();

                if (tags.includes('production') || areaPath.includes('production') || title.includes('production')) return 'prod';
                if (tags.includes('uat') || areaPath.includes('uat') || title.includes('uat')) return 'uat';
                if (tags.includes('qa') || areaPath.includes('qa') || title.includes('qa')) return 'qa';
                return 'dev';
            }

            calculateTestingMetrics() {
                if (!this.currentData) return;

                const testCases = this.currentData.testCases || [];
                const testTasks = this.currentData.testTasks || [];
                const stories = this.currentData.userStories || [];

                let automatedTests = 0;
                let manualTests = 0;
                let executedTests = 0;
                let passedTests = 0;
                let failedTests = 0;
                let blockedTests = 0;

                // Categorize tests by suite and automation status
                const suiteMetrics = new Map();
                const categoryMetrics = {
                    automated: 0,
                    manual: 0,
                    regression: 0,
                    smoke: 0,
                    integration: 0,
                    unit: 0,
                    api: 0,
                    ui: 0,
                    e2e: 0,
                    sit: 0,
                    uat: 0
                };

                testCases.forEach(testCase => {
                    const automationStatus = this.getTestCaseAutomationStatus(testCase);
                    const categories = this.getTestCaseCategories(testCase);
                    const state = testCase.fields['System.State'];
                    const tags = (testCase.fields['System.Tags'] || '').toLowerCase();
                    const suiteName = testCase.suiteName || 'General';

                    // Count automation status
                    if (automationStatus === 'automated') {
                        automatedTests++;
                        categoryMetrics.automated++;
                    } else {
                        manualTests++;
                        categoryMetrics.manual++;
                    }

                    // Count by categories
                    categories.forEach(category => {
                        if (categoryMetrics.hasOwnProperty(category)) {
                            categoryMetrics[category]++;
                        }
                    });

                    // Track by suite
                    if (!suiteMetrics.has(suiteName)) {
                        suiteMetrics.set(suiteName, {
                            total: 0,
                            automated: 0,
                            manual: 0,
                            executed: 0,
                            passed: 0,
                            failed: 0,
                            blocked: 0
                        });
                    }

                    const suite = suiteMetrics.get(suiteName);
                    suite.total++;

                    if (automationStatus === 'automated') {
                        suite.automated++;
                    } else {
                        suite.manual++;
                    }

                    // Check execution status
                    if (['Closed', 'Resolved'].includes(state) || tags.includes('executed')) {
                        executedTests++;
                        suite.executed++;

                        if (tags.includes('passed') || state === 'Closed') {
                            passedTests++;
                            suite.passed++;
                        } else if (tags.includes('failed')) {
                            failedTests++;
                            suite.failed++;
                        } else if (tags.includes('blocked')) {
                            blockedTests++;
                            suite.blocked++;
                        } else {
                            // Default to passed if executed and closed
                            passedTests++;
                            suite.passed++;
                        }
                    }
                });

                // Calculate test coverage correctly
                const storiesWithTests = this.calculateTestCoverage();
                const storiesWithoutTests = stories.length - storiesWithTests;
                const testCoverage = stories.length > 0 ? (storiesWithTests / stories.length) * 100 : 0;

                // Calculate automation rate
                const automationRate = testCases.length > 0 ? (automatedTests / testCases.length) * 100 : 0;
                const passRate = executedTests > 0 ? (passedTests / executedTests) * 100 : 0;

                // Categorize testing tasks
                const sitTasks = testTasks.filter(task =>
                    task.fields['System.Title'].toLowerCase().includes('sit'));
                const uatTasks = testTasks.filter(task =>
                    task.fields['System.Title'].toLowerCase().includes('uat'));

                this.metrics.testing = {
                    totalTestCases: testCases.length,
                    automatedTests,
                    manualTests,
                    executedTests,
                    passedTests,
                    failedTests,
                    blockedTests,
                    testingTasks: testTasks.length,
                    sitTasks: sitTasks.length,
                    uatTasks: uatTasks.length,
                    automationRate,
                    passRate,
                    testCoverage,
                    storiesWithTests,
                    storiesWithoutTests,
                    categoryMetrics,
                    suiteMetrics,

                    // Test execution by iteration
                    iterationTestMetrics: this.calculateIterationTestMetrics(),

                    // Enhanced metrics
                    testsByIteration: this.groupTestsByIteration()
                };
            }

            calculateTestCoverage() {
                const stories = this.currentData.userStories || [];
                const testCases = this.currentData.testCases || [];
                const testTasks = this.currentData.testTasks || [];

                const storiesWithTestsSet = new Set();

                // Check test cases linked to stories
                testCases.forEach(tc => {
                    if (tc.relations) {
                        tc.relations.forEach(rel => {
                            if (rel.rel === 'System.LinkTypes.Related' ||
                                rel.rel === 'Microsoft.VSTS.Common.TestedBy-Reverse') {
                                const linkedId = rel.url.split('/').pop();
                                storiesWithTestsSet.add(linkedId);
                            }
                        });
                    }
                });

                // Check testing tasks linked to stories
                testTasks.forEach(task => {
                    if (task.relations) {
                        task.relations.forEach(rel => {
                            if (rel.rel === 'System.LinkTypes.Hierarchy-Reverse') {
                                const parentId = rel.url.split('/').pop();
                                storiesWithTestsSet.add(parentId);
                            }
                        });
                    }
                });

                // Also check if any story has test cases in selected iterations
                stories.forEach(story => {
                    const storyIteration = story.fields['System.IterationPath'];
                    if (this.selectedIterations.some(iter =>
                        iter.fullPath === storyIteration || iter.name === '@currentIteration')) {
                        // Check if this story has any test cases
                        const hasTests = testCases.some(tc => {
                            const tcTags = tc.fields['System.Tags'] || '';
                            const tcTitle = tc.fields['System.Title'] || '';
                            return tcTags.includes(story.id.toString()) ||
                                tcTitle.includes(story.id.toString()) ||
                                (tc.relations && tc.relations.some(rel =>
                                    rel.url.includes(story.id.toString())));
                        });

                        if (hasTests) {
                            storiesWithTestsSet.add(story.id.toString());
                        }
                    }
                });

                return storiesWithTestsSet.size;
            }

            calculateIterationTestMetrics() {
                const iterationMetrics = new Map();

                this.selectedIterations.forEach(iteration => {
                    iterationMetrics.set(iteration.name, {
                        name: iteration.name,
                        testCases: 0,
                        executedTests: 0,
                        passedTests: 0,
                        failedTests: 0,
                        automatedTests: 0,
                        manualTests: 0,
                        coverageStories: 0,
                        totalStories: 0
                    });
                });

                // Get stories from selected iterations
                const iterationStories = this.currentData.userStories.filter(story => {
                    const storyIteration = story.fields['System.IterationPath'];
                    return this.selectedIterations.some(iter =>
                        iter.fullPath === storyIteration ||
                        (iter.name === '@currentIteration' && storyIteration.includes('current')));
                });

                // Group stories by iteration
                iterationStories.forEach(story => {
                    const storyIteration = story.fields['System.IterationPath'];
                    const matchingIteration = this.selectedIterations.find(iter =>
                        iter.fullPath === storyIteration ||
                        (iter.name === '@currentIteration' && storyIteration.includes('current')));

                    if (matchingIteration && iterationMetrics.has(matchingIteration.name)) {
                        const metrics = iterationMetrics.get(matchingIteration.name);
                        metrics.totalStories++;

                        // Check if story has test coverage
                        const hasTests = this.storyHasTestCoverage(story);
                        if (hasTests) {
                            metrics.coverageStories++;
                        }
                    }
                });

                // Count test cases linked to iteration stories
                this.currentData.testCases.forEach(testCase => {
                    const linkedStories = this.getLinkedWorkItems(testCase);

                    linkedStories.forEach(linkedStoryId => {
                        const story = iterationStories.find(s => s.id.toString() === linkedStoryId);
                        if (story) {
                            const storyIteration = story.fields['System.IterationPath'];
                            const matchingIteration = this.selectedIterations.find(iter =>
                                iter.fullPath === storyIteration ||
                                (iter.name === '@currentIteration' && storyIteration.includes('current')));

                            if (matchingIteration && iterationMetrics.has(matchingIteration.name)) {
                                const metrics = iterationMetrics.get(matchingIteration.name);
                                metrics.testCases++;

                                const automationStatus = this.getTestCaseAutomationStatus(testCase);
                                if (automationStatus === 'automated') {
                                    metrics.automatedTests++;
                                } else {
                                    metrics.manualTests++;
                                }

                                // Check execution status
                                const state = testCase.fields['System.State'];
                                const tags = (testCase.fields['System.Tags'] || '').toLowerCase();

                                if (['Closed', 'Resolved'].includes(state) || tags.includes('executed')) {
                                    metrics.executedTests++;

                                    if (tags.includes('passed') || state === 'Closed') {
                                        metrics.passedTests++;
                                    } else if (tags.includes('failed')) {
                                        metrics.failedTests++;
                                    }
                                }
                            }
                        }
                    });
                });

                return iterationMetrics;
            }

            storyHasTestCoverage(story) {
                // Check if story has linked test cases
                if (story.relations) {
                    const hasTestLinks = story.relations.some(rel =>
                        rel.rel === 'Microsoft.VSTS.Common.TestedBy' ||
                        rel.rel === 'System.LinkTypes.Related');
                    if (hasTestLinks) return true;
                }

                // Check if any test case references this story
                return this.currentData.testCases.some(tc => {
                    const tcTags = tc.fields['System.Tags'] || '';
                    const tcTitle = tc.fields['System.Title'] || '';
                    return tcTags.includes(story.id.toString()) ||
                        tcTitle.includes(story.id.toString());
                });
            }

            getLinkedWorkItems(workItem) {
                const linkedIds = [];

                if (workItem.relations) {
                    workItem.relations.forEach(rel => {
                        if (rel.rel === 'System.LinkTypes.Related' ||
                            rel.rel === 'Microsoft.VSTS.Common.TestedBy-Reverse' ||
                            rel.rel === 'System.LinkTypes.Hierarchy-Reverse') {
                            const linkedId = rel.url.split('/').pop();
                            linkedIds.push(linkedId);
                        }
                    });
                }

                return linkedIds;
            }

            groupTestsByIteration() {
                const testsByIteration = new Map();

                this.selectedIterations.forEach(iteration => {
                    testsByIteration.set(iteration.name, {
                        regression: [],
                        smoke: [],
                        integration: [],
                        api: [],
                        ui: [],
                        general: []
                    });
                });

                this.currentData.testCases.forEach(testCase => {
                    const categories = this.getTestCaseCategories(testCase);
                    const linkedStories = this.getLinkedWorkItems(testCase);

                    // Find which iteration this test belongs to
                    linkedStories.forEach(linkedStoryId => {
                        const story = this.currentData.userStories.find(s => s.id.toString() === linkedStoryId);
                        if (story) {
                            const storyIteration = story.fields['System.IterationPath'];
                            const matchingIteration = this.selectedIterations.find(iter =>
                                iter.fullPath === storyIteration);

                            if (matchingIteration && testsByIteration.has(matchingIteration.name)) {
                                const iterationTests = testsByIteration.get(matchingIteration.name);

                                categories.forEach(category => {
                                    if (iterationTests[category]) {
                                        iterationTests[category].push(testCase);
                                    } else {
                                        iterationTests.general.push(testCase);
                                    }
                                });
                            }
                        }
                    });
                });

                return testsByIteration;
            }

            calculateTeamMetrics() {
                if (!this.currentData) return;

                const individualMetrics = new Map();
                const allWorkItems = this.currentData.workItems || [];

                // Extract unique team members from work items
                const teamMembersSet = new Set();

                allWorkItems.forEach(item => {
                    const assignee = item.fields['System.AssignedTo']?.displayName;
                    const creator = item.fields['System.CreatedBy']?.displayName;

                    if (assignee) {
                        teamMembersSet.add(assignee);
                        if (!individualMetrics.has(assignee)) {
                            individualMetrics.set(assignee, this.createEmptyIndividualMetrics());
                        }
                        this.updateIndividualMetrics(individualMetrics.get(assignee), item, 'assignee');
                    }

                    if (creator && creator !== assignee) {
                        teamMembersSet.add(creator);
                        if (!individualMetrics.has(creator)) {
                            individualMetrics.set(creator, this.createEmptyIndividualMetrics());
                        }
                        this.updateIndividualMetrics(individualMetrics.get(creator), item, 'creator');
                    }
                });

                // Update team members list for filtering
                this.teamMembers = Array.from(teamMembersSet).map(name => ({
                    id: name,
                    displayName: name
                }));

                const teamSize = individualMetrics.size;
                const totalVelocity = Array.from(individualMetrics.values())
                    .reduce((sum, member) => sum + (member.storyPoints?.completed || 0), 0);

                this.metrics.team = {
                    members: this.convertToLegacyFormat(individualMetrics),
                    teamSize,
                    totalVelocity,
                    averageVelocity: teamSize > 0 ? totalVelocity / teamSize : 0,
                    detailedMetrics: individualMetrics
                };
            }

            createEmptyIndividualMetrics() {
                return {
                    workItems: {
                        created: 0,
                        assigned: 0,
                        completed: 0,
                        inProgress: 0
                    },
                    storyPoints: {
                        assigned: 0,
                        completed: 0
                    },
                    workTypes: {
                        stories: 0,
                        features: 0,
                        tasks: 0,
                        bugs: 0,
                        testCases: 0
                    },
                    quality: {
                        bugsCreated: 0,
                        bugsResolved: 0,
                        defectsCreated: 0,
                        testCasesCreated: 0,
                        testCasesExecuted: 0
                    }
                };
            }

            updateIndividualMetrics(metrics, item, role) {
                const workItemType = item.fields['System.WorkItemType'];
                const state = item.fields['System.State'];
                const storyPoints = item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;

                if (role === 'assignee') {
                    metrics.workItems.assigned++;
                    metrics.storyPoints.assigned += storyPoints;

                    if (['Done', 'Closed', 'Resolved'].includes(state)) {
                        metrics.workItems.completed++;
                        metrics.storyPoints.completed += storyPoints;
                    } else if (['Active', 'In Progress'].includes(state)) {
                        metrics.workItems.inProgress++;
                    }
                } else if (role === 'creator') {
                    metrics.workItems.created++;
                }

                // Update work type counts
                switch (workItemType) {
                    case 'User Story':
                    case 'Product Backlog Item':
                        metrics.workTypes.stories++;
                        break;
                    case 'Feature':
                        metrics.workTypes.features++;
                        break;
                    case 'Task':
                        metrics.workTypes.tasks++;
                        break;
                    case 'Bug':
                        if (role === 'creator') {
                            if (this.isProductionIssue(item)) {
                                metrics.quality.defectsCreated++;
                            } else {
                                metrics.quality.bugsCreated++;
                            }
                        } else if (role === 'assignee') {
                            metrics.quality.bugsResolved++;
                        }
                        metrics.workTypes.bugs++;
                        break;
                    case 'Test Case':
                        if (role === 'creator') {
                            metrics.quality.testCasesCreated++;
                        }
                        if (role === 'assignee' && ['Closed', 'Resolved'].includes(state)) {
                            metrics.quality.testCasesExecuted++;
                        }
                        metrics.workTypes.testCases++;
                        break;
                }
            }

            convertToLegacyFormat(individualMetrics) {
                const legacyMap = new Map();

                individualMetrics.forEach((metrics, name) => {
                    legacyMap.set(name, {
                        stories: metrics.workTypes.stories,
                        features: metrics.workTypes.features,
                        tasks: metrics.workTypes.tasks,
                        bugs: metrics.workTypes.bugs,
                        points: metrics.storyPoints.assigned,
                        completedPoints: metrics.storyPoints.completed,
                        testCasesCreated: metrics.quality.testCasesCreated,
                        testCasesExecuted: metrics.quality.testCasesExecuted,
                        workInProgress: metrics.workItems.inProgress
                    });
                });

                return legacyMap;
            }

            calculateIndividualMetrics() {
                this.metrics.individual = this.metrics.team?.members || new Map();
                if (this.metrics.team?.detailedMetrics) {
                    this.metrics.individualDetailed = this.metrics.team.detailedMetrics;
                }
            }

            populateTeamMemberFilter() {
                const select = document.getElementById('teamMemberFilter');
                select.innerHTML = '<option value="">All team members</option>';

                this.teamMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member.displayName;
                    option.textContent = member.displayName;
                    select.appendChild(option);
                });
            }

            // Calculate a meaningful Project Health Score
            calculateProjectHealthScore() {
                let healthScore = 100;
                let penalties = 0;

                // Delivery Health (40% weight)
                const deliveryScore = this.calculateDeliveryHealth();
                penalties += (100 - deliveryScore) * 0.4;

                // Quality Health (30% weight)
                const qualityScore = this.calculateQualityHealth();
                penalties += (100 - qualityScore) * 0.3;

                // Testing Health (20% weight)
                const testingScore = this.calculateTestingHealth();
                penalties += (100 - testingScore) * 0.2;

                // Team Health (10% weight)
                const teamScore = this.calculateTeamHealth();
                penalties += (100 - teamScore) * 0.1;

                healthScore = Math.max(0, Math.round(healthScore - penalties));

                return {
                    overall: healthScore,
                    delivery: Math.round(deliveryScore),
                    quality: Math.round(qualityScore),
                    testing: Math.round(testingScore),
                    team: Math.round(teamScore)
                };
            }

            calculateDeliveryHealth() {
                let score = 100;

                // Completion rate impact
                const completionRate = this.metrics.delivery?.completionRate || 0;
                if (completionRate < 80) score -= (80 - completionRate);

                // Blocked items impact
                const blockedItems = this.metrics.delivery?.blockedItems || 0;
                const totalItems = this.metrics.delivery?.totalStories || 1;
                const blockedPercentage = (blockedItems / totalItems) * 100;
                if (blockedPercentage > 10) score -= (blockedPercentage - 10) * 2;

                // Velocity consistency (simplified)
                const velocity = this.metrics.delivery?.velocity || 0;
                if (velocity === 0) score -= 20;

                return Math.max(0, score);
            }

            calculateQualityHealth() {
                let score = 100;

                // Critical bugs impact
                const criticalBugs = this.metrics.quality?.criticalBugs || 0;
                score -= criticalBugs * 15; // Each critical bug reduces score by 15

                // Production defects impact
                const defects = this.metrics.quality?.totalDefects || 0;
                score -= defects * 25; // Each defect reduces score by 25

                // Bug density impact
                const bugDensity = this.metrics.quality?.bugDensity || 0;
                if (bugDensity > 0.1) score -= (bugDensity - 0.1) * 100;

                return Math.max(0, score);
            }

            calculateTestingHealth() {
                let score = 100;

                // Test coverage impact
                const coverage = this.metrics.testing?.testCoverage || 0;
                if (coverage < 70) score -= (70 - coverage) * 0.5;

                // Automation rate impact
                const automation = this.metrics.testing?.automationRate || 0;
                if (automation < 50) score -= (50 - automation) * 0.3;

                // Pass rate impact
                const passRate = this.metrics.testing?.passRate || 0;
                if (passRate < 90) score -= (90 - passRate) * 0.8;

                return Math.max(0, score);
            }

            calculateTeamHealth() {
                let score = 100;

                // Team utilization (simplified)
                const teamSize = this.metrics.team?.teamSize || 0;
                if (teamSize === 0) score = 0;

                // Work distribution balance
                const totalVelocity = this.metrics.team?.totalVelocity || 0;
                const avgVelocity = this.metrics.team?.averageVelocity || 0;

                if (avgVelocity === 0 && teamSize > 0) score -= 30;

                return Math.max(0, score);
            }

            getHealthScoreColor(score) {
                if (score >= 85) return 'health-excellent';
                if (score >= 70) return 'health-good';
                if (score >= 50) return 'health-warning';
                return 'health-poor';
            }

            getHealthScoreLabel(score) {
                if (score >= 85) return 'Excellent';
                if (score >= 70) return 'Good';
                if (score >= 50) return 'Needs Attention';
                return 'Critical';
            }

            // Enhanced progress bar color logic
            getProgressBarColor(percentage, isInverted = false) {
                if (isInverted) {
                    // For metrics where lower is better (like bug count)
                    if (percentage === 0) return 'bg-success';
                    if (percentage <= 25) return 'bg-warning';
                    return 'bg-danger';
                } else {
                    // For metrics where higher is better (like completion rate)
                    if (percentage >= 90) return 'bg-success';
                    if (percentage >= 70) return 'bg-primary';
                    if (percentage >= 50) return 'bg-warning';
                    return 'bg-danger';
                }
            }

            async makeADORequest(endpoint, method = 'GET', body = null) {
                const baseUrl = `https://dev.azure.com/${this.config.organization}`;

                let url;
                if (endpoint.includes('projects') && !endpoint.includes(this.config.project)) {
                    url = endpoint.startsWith('http') ? endpoint : `${baseUrl}/_apis/${endpoint}`;
                } else {
                    url = endpoint.startsWith('http') ? endpoint : `${baseUrl}/${this.config.project}/_apis/${endpoint}`;
                }

                const headers = {
                    'Authorization': `Basic ${btoa(`:${this.config.pat}`)}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                };

                try {
                    const response = await fetch(url, {
                        method,
                        headers,
                        body: body ? JSON.stringify(body) : null
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`ADO API Error: ${response.status} - ${errorText}`);
                        throw new Error(`ADO API Error: ${response.status} - ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error('ADO Request Error:', error);
                    throw error;
                }
            }

            saveSettings() {
                this.config.organization = document.getElementById('adoOrganization').value.trim();
                this.config.project = document.getElementById('adoProject').value.trim();
                this.config.pat = document.getElementById('adoPAT').value.trim();
                this.config.proxy = {
                    server: document.getElementById('proxyServer').value.trim(),
                    port: document.getElementById('proxyPort').value.trim()
                };

                this.saveConfiguration();
                this.showToast('Settings saved successfully', 'success');

                const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
                modal.hide();

                if (this.config.organization && this.config.project && this.config.pat) {
                    this.testConnection();
                }
            }

            navigateToPage(page) {
                // Update active nav
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                document.querySelector(`[data-page="${page}"]`)?.classList.add('active');

                // Load page content
                switch (page) {
                    case 'dashboard':
                        this.showDashboard();
                        break;
                    case 'delivery':
                        this.showDeliveryMetrics();
                        break;
                    case 'quality':
                        this.showQualityMetrics();
                        break;
                    case 'testing':
                        this.showTestingAnalytics();
                        break;
                    case 'team':
                        this.showTeamPerformance();
                        break;
                    case 'individual':
                        this.showIndividualMetrics();
                        break;
                    case 'reports':
                        this.showReports();
                        break;
                }
            }

            showInitialState() {
                const content = document.getElementById('dashboardContent');
                content.innerHTML = `
            <div class="info-container">
                <h5><i class="fas fa-rocket me-2"></i>Welcome to ADO Metrics Command Center</h5>
                <p class="mb-3">Get started with comprehensive project analytics:</p>
                <ol class="mb-4">
                    <li>Configure your ADO connection in Settings</li>
                    <li>Test the connection to verify access</li>
                    <li>Select up to 3 area paths and multiple iterations</li>
                    <li>Choose optional filters (test plan, team member, date range)</li>
                    <li>Load your analytics data</li>
                </ol>
                <div class="row g-3">
                    <div class="col-md-6">
                        <button class="btn btn-primary btn-lg w-100" data-bs-toggle="modal" data-bs-target="#settingsModal">
                            <i class="fas fa-cog me-2"></i>Configure ADO Settings
                        </button>
                    </div>
                    <div class="col-md-6">
                        <button class="btn btn-outline-info btn-lg w-100" onclick="window.open('https://docs.microsoft.com/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate', '_blank')">
                            <i class="fas fa-question-circle me-2"></i>Need Help with PAT?
                        </button>
                    </div>
                </div>
            </div>
        `;
            }

            showNoDataMessage() {
                const content = document.getElementById('dashboardContent');
                const areaPathNames = this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join(', ');
                const iterationNames = this.selectedIterations.map(it => it.displayName || it.name).join(', ');

                content.innerHTML = `
            <div class="info-container">
                <h5><i class="fas fa-search me-2"></i>No Data Found</h5>
                <p class="mb-3">No work items found for the selected criteria:</p>
                <div class="row g-3 mb-4">
                    <div class="col-md-6">
                        <strong>Area Paths:</strong><br>
                        <span class="text-muted">${areaPathNames || 'None selected'}</span>
                    </div>
                    <div class="col-md-6">
                        <strong>Iterations:</strong><br>
                        <span class="text-muted">${iterationNames || 'None selected'}</span>
                    </div>
                    <div class="col-md-6">
                        <strong>Test Plan:</strong><br>
                        <span class="text-muted">${this.selectedTestPlan ? this.getTestPlanName(this.selectedTestPlan) : 'None selected'}</span>
                    </div>
                    <div class="col-md-6">
                        <strong>Team Member:</strong><br>
                        <span class="text-muted">${this.selectedTeamMember || 'All team members'}</span>
                    </div>
                </div>
                <p class="mb-3">Try these suggestions:</p>
                <ul class="mb-4">
                    <li>Expand your area path selection</li>
                    <li>Select different or additional iterations</li>
                    <li>Remove team member filter</li>
                    <li>Adjust date range settings</li>
                    <li>Verify work items exist in the selected criteria</li>
                </ul>
                <div class="row g-3">
                    <div class="col-md-4">
                        <button class="btn btn-primary w-100" onclick="dashboard.clearAllFilters()">
                            <i class="fas fa-filter me-2"></i>Clear All Filters
                        </button>
                    </div>
                    <div class="col-md-4">
                        <button class="btn btn-outline-primary w-100" onclick="dashboard.loadData()">
                            <i class="fas fa-sync-alt me-2"></i>Retry Load
                        </button>
                    </div>
                    <div class="col-md-4">
                        <button class="btn btn-outline-secondary w-100" onclick="dashboard.testConnection()">
                            <i class="fas fa-plug me-2"></i>Test Connection
                        </button>
                    </div>
                </div>
            </div>
        `;
            }

            // Utility methods
            showLoading(show, message = 'Loading...') {
                const spinner = document.getElementById('loadingSpinner');
                const loadingText = document.getElementById('loadingText');

                if (show) {
                    loadingText.textContent = message;
                    spinner.style.display = 'flex';
                } else {
                    spinner.style.display = 'none';
                }
            }

            showToast(message, type = 'info') {
                let toastContainer = document.getElementById('toastContainer');
                if (!toastContainer) {
                    toastContainer = document.createElement('div');
                    toastContainer.id = 'toastContainer';
                    toastContainer.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                z-index: 9999;
                min-width: 350px;
            `;
                    document.body.appendChild(toastContainer);
                }

                const toastId = `toast-${Date.now()}`;
                const iconMap = {
                    success: 'check-circle',
                    error: 'exclamation-circle',
                    warning: 'exclamation-triangle',
                    info: 'info-circle'
                };

                const toastHtml = `
            <div id="${toastId}" class="alert alert-${type} alert-dismissible fade show" role="alert" 
                 style="margin-bottom: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-radius: 12px;">
                <i class="fas fa-${iconMap[type]} me-2"></i>
                <span>${message}</span>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;

                toastContainer.insertAdjacentHTML('beforeend', toastHtml);

                setTimeout(() => {
                    const toastElement = document.getElementById(toastId);
                    if (toastElement) {
                        toastElement.remove();
                    }
                }, 5000);
            }

            truncateText(text, maxLength) {
                if (!text) return '';
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            formatTags(tags) {
                if (!tags) return '';
                return tags.split(';')
                    .filter(tag => tag.trim())
                    .slice(0, 3)
                    .map(tag => `<span class="test-tag" style="background: #e3f2fd; color: #1976d2;">${tag.trim()}</span>`)
                    .join(' ');
            }

            // Dashboard Display Methods - Production Implementation
            showDashboard() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData || !this.currentData.workItems || this.currentData.workItems.length === 0) {
                    this.showInitialState();
                    return;
                }

                const healthScore = this.calculateProjectHealthScore();

                content.innerHTML = `
            <!-- Project Health Score -->
            <div class="row mb-4">
                <div class="col-12">
                    <div class="metric-card">
                        <div class="row align-items-center">
                            <div class="col-md-3 text-center">
                                <div class="metric-value ${this.getHealthScoreColor(healthScore.overall)}" style="font-size: 4rem;">
                                    ${healthScore.overall}%
                                </div>
                                <div class="metric-label" style="font-size: 1rem;">
                                    <i class="fas fa-heartbeat me-1"></i>
                                    Project Health Score
                                </div>
                                <div class="text-muted mt-1">${this.getHealthScoreLabel(healthScore.overall)}</div>
                            </div>
                            <div class="col-md-9">
                                <div class="row">
                                    <div class="col-md-3 text-center">
                                        <div class="metric-value ${this.getHealthScoreColor(healthScore.delivery)}">${healthScore.delivery}%</div>
                                        <div class="metric-label">Delivery Health</div>
                                        <div class="text-muted small">${this.metrics.delivery?.completedStories || 0}/${this.metrics.delivery?.totalStories || 0} Stories</div>
                                    </div>
                                    <div class="col-md-3 text-center">
                                        <div class="metric-value ${this.getHealthScoreColor(healthScore.quality)}">${healthScore.quality}%</div>
                                        <div class="metric-label">Quality Health</div>
                                        <div class="text-muted small">${this.metrics.quality?.totalDefects || 0} Defects, ${this.metrics.quality?.criticalBugs || 0} Critical</div>
                                    </div>
                                    <div class="col-md-3 text-center">
                                        <div class="metric-value ${this.getHealthScoreColor(healthScore.testing)}">${healthScore.testing}%</div>
                                        <div class="metric-label">Testing Health</div>
					<div class="text-muted small">${this.metrics.testing?.testCoverage?.toFixed(1) || 0}% Coverage</div>
                                    </div>
                                    <div class="col-md-3 text-center">
                                        <div class="metric-value ${this.getHealthScoreColor(healthScore.team)}">${healthScore.team}%</div>
                                        <div class="metric-label">Team Health</div>
                                        <div class="text-muted small">${this.metrics.team?.teamSize || 0} Members</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Key Metrics Overview -->
            <div class="row mb-4">
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-tasks"></i>
                        </div>
                        <div class="metric-value">${this.metrics.delivery?.completedStories || 0}</div>
                        <div class="metric-label">Stories Completed</div>
                        <div class="progress">
                            <div class="progress-bar ${this.getProgressBarColor(this.metrics.delivery?.completionRate || 0)}" 
                                 style="width: ${this.metrics.delivery?.completionRate || 0}%"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-chart-line"></i>
                        </div>
                        <div class="metric-value">${this.metrics.delivery?.velocity || 0}</div>
                        <div class="metric-label">Story Points</div>
                        <div class="progress">
                            <div class="progress-bar ${this.getProgressBarColor(this.metrics.delivery?.pointsCompletionRate || 0)}" 
                                 style="width: ${this.metrics.delivery?.pointsCompletionRate || 0}%"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                            <i class="fas fa-bug"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality?.totalBugs || 0}</div>
                        <div class="metric-label">Bugs (Lower Env)</div>
                        <div class="progress">
                            <div class="progress-bar ${this.getProgressBarColor((this.metrics.quality?.totalBugs || 0) > 10 ? 100 : 0, true)}" 
                                 style="width: ${Math.min(100, (this.metrics.quality?.totalBugs || 0) * 10)}%"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(220, 53, 69, 0.2); color: #dc3545;">
                            <i class="fas fa-exclamation-triangle"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality?.totalDefects || 0}</div>
                        <div class="metric-label">Defects (Production)</div>
                        <div class="progress">
                            <div class="progress-bar ${this.getProgressBarColor((this.metrics.quality?.totalDefects || 0) > 0 ? 100 : 0, true)}" 
                                 style="width: ${(this.metrics.quality?.totalDefects || 0) > 0 ? 100 : 0}%"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(40, 167, 69, 0.1); color: #28a745;">
                            <i class="fas fa-robot"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing?.automationRate?.toFixed(1) || 0}%</div>
                        <div class="metric-label">Automation Rate</div>
                        <div class="progress">
                            <div class="progress-bar ${this.getProgressBarColor(this.metrics.testing?.automationRate || 0)}" 
                                 style="width: ${this.metrics.testing?.automationRate || 0}%"></div>
                        </div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(23, 162, 184, 0.1); color: #17a2b8;">
                            <i class="fas fa-shield-alt"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%</div>
                        <div class="metric-label">Test Coverage</div>
                        <div class="progress">
                            <div class="progress-bar ${this.getProgressBarColor(this.metrics.testing?.testCoverage || 0)}" 
                                 style="width: ${this.metrics.testing?.testCoverage || 0}%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Work Item Summary Table -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-list-alt me-2"></i>Work Item Summary
                </h5>
                ${this.createCustomTable('workItemSummaryTable', this.generateWorkItemSummaryData(), [
                    'Type', 'Total', 'New', 'Active', 'Resolved', 'Closed', 'Completion Rate', 'Progress'
                ])}
            </div>

            <!-- Quality Analysis -->
            <div class="row">
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-bug me-2"></i>Quality Overview
                        </h5>
                        ${this.createCustomTable('qualityOverviewTable', this.generateQualityOverviewData(), [
                    'Category', 'Count', 'Critical', 'High', 'Medium', 'Low'
                ])}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-vial me-2"></i>Testing Overview
                        </h5>
                        ${this.createCustomTable('testingOverviewTable', this.generateTestingOverviewData(), [
                    'Category', 'Count', 'Percentage', 'Status'
                ])}
                    </div>
                </div>
            </div>

            <!-- Release Information -->
            ${this.generateReleaseSection()}
        `;

                this.setupTableInteractivity();
            }

            generateWorkItemSummaryData() {
                const types = [
                    { name: 'User Stories', data: this.currentData.userStories || [] },
                    { name: 'Features', data: this.currentData.features || [] },
                    { name: 'Epics', data: this.currentData.epics || [] },
                    { name: 'Tasks', data: this.currentData.tasks || [] },
                    { name: 'Bugs (Lower Env)', data: this.currentData.bugs || [] },
                    { name: 'Defects (Production)', data: this.currentData.defects || [] }
                ];

                return types.map(type => {
                    const statusCount = this.countByStatus(type.data);
                    const total = type.data.length;
                    const completed = statusCount.resolved + statusCount.closed;
                    const completionRate = total > 0 ? (completed / total) * 100 : 0;

                    return [
                        `<strong>${type.name}</strong>`,
                        total,
                        `<span class="status-badge status-new">${statusCount.new}</span>`,
                        `<span class="status-badge status-active">${statusCount.active}</span>`,
                        `<span class="status-badge status-resolved">${statusCount.resolved}</span>`,
                        `<span class="status-badge status-closed">${statusCount.closed}</span>`,
                        `${completionRate.toFixed(1)}%`,
                        `<div class="progress" style="height: 15px;">
                    <div class="progress-bar ${this.getProgressBarColor(completionRate)}" 
                         style="width: ${completionRate}%; font-size: 0.7rem; line-height: 15px;">
                        ${completionRate > 15 ? completionRate.toFixed(0) + '%' : ''}
                    </div>
                 </div>`
                    ];
                });
            }

            generateQualityOverviewData() {
                const bugs = this.metrics.quality?.bugsBySeverity || {};
                const data = [
                    {
                        category: 'Bugs (Lower Environment)',
                        count: this.metrics.quality?.totalBugs || 0,
                        severities: bugs
                    },
                    {
                        category: 'Defects (Production)',
                        count: this.metrics.quality?.totalDefects || 0,
                        severities: { critical: 0, high: 0, medium: 0, low: 0 } // Defects analyzed separately
                    }
                ];

                // Calculate defect severities
                const defects = this.currentData.defects || [];
                defects.forEach(defect => {
                    const severity = defect.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    if (severity.includes('1') || severity.toLowerCase().includes('critical')) {
                        data[1].severities.critical++;
                    } else if (severity.includes('2') || severity.toLowerCase().includes('high')) {
                        data[1].severities.high++;
                    } else if (severity.includes('3') || severity.toLowerCase().includes('medium')) {
                        data[1].severities.medium++;
                    } else {
                        data[1].severities.low++;
                    }
                });

                return data.map(item => [
                    `<strong>${item.category}</strong>`,
                    item.count,
                    `<span class="severity-badge severity-critical">${item.severities.critical || 0}</span>`,
                    `<span class="severity-badge severity-high">${item.severities.high || 0}</span>`,
                    `<span class="severity-badge severity-medium">${item.severities.medium || 0}</span>`,
                    `<span class="severity-badge severity-low">${item.severities.low || 0}</span>`
                ]);
            }

            generateTestingOverviewData() {
                const testing = this.metrics.testing || {};
                const data = [
                    { category: 'Total Test Cases', count: testing.totalTestCases || 0, percentage: 100, status: 'Total' },
                    { category: 'Automated Tests', count: testing.automatedTests || 0, percentage: testing.automationRate || 0, status: testing.automationRate > 70 ? 'Good' : 'Needs Improvement' },
                    { category: 'Manual Tests', count: testing.manualTests || 0, percentage: 100 - (testing.automationRate || 0), status: 'Manual' },
                    { category: 'Test Coverage', count: testing.storiesWithTests || 0, percentage: testing.testCoverage || 0, status: testing.testCoverage > 80 ? 'Good' : 'At Risk' },
                    { category: 'Passed Tests', count: testing.passedTests || 0, percentage: testing.passRate || 0, status: testing.passRate > 95 ? 'Excellent' : 'Good' }
                ];

                return data.map(item => [
                    `<strong>${item.category}</strong>`,
                    item.count,
                    `${item.percentage.toFixed(1)}%`,
                    `<span class="badge bg-${this.getStatusBadgeColor(item.status)}">${item.status}</span>`
                ]);
            }

            generateReleaseSection() {
                if (!this.currentData.releases || this.currentData.releases.size === 0) {
                    return '';
                }

                let releaseHtml = `
            <div class="subsection-header">
                <h4 class="subsection-title">
                    <i class="fas fa-rocket me-2"></i>Releases
                </h4>
            </div>
        `;

                // Sort releases by date if available, otherwise by name
                const sortedReleases = Array.from(this.currentData.releases.entries())
                    .sort((a, b) => {
                        if (a[1].date && b[1].date) {
                            return b[1].date - a[1].date; // Latest first
                        }
                        return a[0].localeCompare(b[0]); // Alphabetical
                    });

                sortedReleases.forEach(([releaseName, release]) => {
                    const releaseData = this.generateReleaseData(release);
                    releaseHtml += `
                <div class="data-table-container">
                    <h6 class="table-title">
                        <i class="fas fa-tag me-2"></i>Release: ${releaseName}
                        ${release.date ? `<span class="text-muted ms-2">(${release.date.toLocaleDateString()})</span>` : ''}
                    </h6>
                    ${this.createCustomTable(`release_${releaseName.replace(/[^a-zA-Z0-9]/g, '_')}`, releaseData, [
                        'ID', 'Title', 'Type', 'State', 'Assigned To', 'Priority'
                    ])}
                </div>
            `;
                });

                return releaseHtml;
            }

            generateReleaseData(release) {
                // Sort work items by state priority (Done first, then by priority)
                const statePriority = { 'Done': 0, 'Closed': 1, 'Resolved': 2, 'Active': 3, 'In Progress': 4, 'New': 5 };

                const sortedItems = release.workItems.sort((a, b) => {
                    const aState = a.fields['System.State'];
                    const bState = b.fields['System.State'];
                    const aStatePriority = statePriority[aState] || 10;
                    const bStatePriority = statePriority[bState] || 10;

                    if (aStatePriority !== bStatePriority) {
                        return aStatePriority - bStatePriority;
                    }

                    // Then by work item priority
                    const aPriority = a.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const bPriority = b.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    return aPriority - bPriority;
                });

                return sortedItems.map(item => [
                    item.id,
                    this.truncateText(item.fields['System.Title'] || '', 60),
                    item.fields['System.WorkItemType'],
                    `<span class="status-badge status-${item.fields['System.State'].toLowerCase().replace(' ', '-')}">${item.fields['System.State']}</span>`,
                    item.fields['System.AssignedTo']?.displayName || 'Unassigned',
                    `<span class="priority-indicator priority-${item.fields['Microsoft.VSTS.Common.Priority'] || 3}"></span>P${item.fields['Microsoft.VSTS.Common.Priority'] || 3}`
                ]);
            }

            showDeliveryMetrics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-tasks me-2"></i>Delivery Metrics
                </h2>
            </div>

            <!-- Delivery Summary Cards -->
            <div class="row mb-4">
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-list-alt"></i>
                        </div>
                        <div class="metric-value">${this.metrics.delivery.totalStories}</div>
                        <div class="metric-label">Total Stories</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-check-circle"></i>
                        </div>
                        <div class="metric-value">${this.metrics.delivery.completedStories}</div>
                        <div class="metric-label">Completed Stories</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-chart-line"></i>
                        </div>
                        <div class="metric-value">${this.metrics.delivery.velocity}</div>
                        <div class="metric-label">Story Points Delivered</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-percentage"></i>
                        </div>
                        <div class="metric-value">${this.metrics.delivery.completionRate.toFixed(1)}%</div>
                        <div class="metric-label">Completion Rate</div>
                    </div>
                </div>
            </div>

            <!-- User Stories Detail -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-user-stories me-2"></i>User Stories Detail
                </h5>
                ${this.createCustomTable('userStoriesTable', this.generateUserStoriesData(), [
                    'ID', 'Title', 'State', 'Assigned To', 'Story Points', 'Priority', 'Created Date', 'Tags'
                ], true)}
            </div>

            <!-- Features and Epics -->
            <div class="row">
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-layer-group me-2"></i>Features
                        </h5>
                        ${this.createCustomTable('featuresTable', this.generateFeaturesData(), [
                    'ID', 'Title', 'State', 'Assigned To', 'Priority'
                ])}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-mountain me-2"></i>Epics
                        </h5>
                        ${this.createCustomTable('epicsTable', this.generateEpicsData(), [
                    'ID', 'Title', 'State', 'Assigned To', 'Priority'
                ])}
                    </div>
                </div>
            </div>

            <!-- Release Breakdown -->
            ${this.generateReleaseSection()}
        `;

                this.setupTableInteractivity();
            }

            showQualityMetrics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-bug me-2"></i>Quality Metrics
                </h2>
            </div>

            <!-- Quality Summary Cards -->
            <div class="row mb-4">
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(255, 193, 7, 0.1); color: #ffc107;">
                            <i class="fas fa-bug"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality.totalBugs}</div>
                        <div class="metric-label">Bugs (Lower Env)</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                            <i class="fas fa-exclamation-triangle"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality.totalDefects}</div>
                        <div class="metric-label">Defects (Production)</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                            <i class="fas fa-fire"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality.criticalBugs}</div>
                        <div class="metric-label">Critical Issues</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-percentage"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality.defectEscapeRate.toFixed(1)}%</div>
                        <div class="metric-label">Escape Rate</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-chart-area"></i>
                        </div>
                        <div class="metric-value">${this.metrics.quality.bugDensity.toFixed(3)}</div>
                        <div class="metric-label">Bug Density</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-layer-group"></i>
                        </div>
                        <div class="metric-value">${Object.values(this.metrics.quality.bugsByEnvironment).reduce((a, b) => a + b, 0)}</div>
                        <div class="metric-label">Total Issues</div>
                    </div>
                </div>
            </div>

            <!-- Issues by Environment -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-server me-2"></i>Issues by Environment
                </h5>
                ${this.createCustomTable('environmentTable', this.generateEnvironmentData(), [
                    'Environment', 'Count', 'Percentage', 'Classification', 'Visual'
                ])}
            </div>

            <!-- Bugs Detail -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-list me-2"></i>Active Issues Detail
                </h5>
                ${this.createCustomTable('bugsDetailTable', this.generateBugsDetailData(), [
                    'ID', 'Title', 'Type', 'Environment', 'Severity', 'Priority', 'State', 'Assigned To', 'Age (Days)'
                ], true)}
            </div>

            <!-- Severity and Priority Analysis -->
            <div class="row">
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-exclamation-circle me-2"></i>Severity Distribution
                        </h5>
                        ${this.createCustomTable('severityTable', this.generateSeverityData(), [
                    'Severity', 'Count', 'Percentage', 'Status'
                ])}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-sort-numeric-up me-2"></i>Priority Distribution
                        </h5>
                        ${this.createCustomTable('priorityTable', this.generatePriorityData(), [
                    'Priority', 'Count', 'Percentage', 'Focus Level'
                ])}
                    </div>
                </div>
            </div>
        `;

                this.setupTableInteractivity();
            }

            showTestingAnalytics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-vial me-2"></i>Testing Analytics
                </h2>
            </div>

            <!-- Testing Summary Cards -->
            <div class="row mb-4">
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-vial"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing.totalTestCases}</div>
                        <div class="metric-label">Total Test Cases</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(40, 167, 69, 0.1); color: #28a745;">
                            <i class="fas fa-robot"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing.automatedTests}</div>
                        <div class="metric-label">Automated Tests</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon" style="background: rgba(23, 162, 184, 0.1); color: #17a2b8;">
                            <i class="fas fa-hand-paper"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing.manualTests}</div>
                        <div class="metric-label">Manual Tests</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-percentage"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing.automationRate.toFixed(1)}%</div>
                        <div class="metric-label">Automation Rate</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-shield-alt"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing.testCoverage.toFixed(1)}%</div>
                        <div class="metric-label">Test Coverage</div>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-check-circle"></i>
                        </div>
                        <div class="metric-value">${this.metrics.testing.passRate.toFixed(1)}%</div>
                        <div class="metric-label">Pass Rate</div>
                    </div>
                </div>
            </div>

            <!-- Test Execution by Suite -->
            ${this.generateTestSuiteSection()}

            <!-- Test Execution by Selected Iteration -->
            ${this.generateIterationTestSection()}

            <!-- Test Categories Distribution -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-tags me-2"></i>Test Categories Distribution
                </h5>
                ${this.createCustomTable('testCategoriesTable', this.generateTestCategoriesData(), [
                    'Category', 'Count', 'Percentage', 'Type', 'Visual'
                ])}
            </div>

            <!-- Test Cases Detail -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-list me-2"></i>Test Cases Detail
                </h5>
                ${this.createCustomTable('testCasesDetailTable', this.generateTestCasesDetailData(), [
                    'ID', 'Title', 'State', 'Assigned To', 'Automation', 'Categories', 'Suite', 'Execution Status'
                ], true)}
            </div>

            <!-- Test Coverage Analysis -->
            <div class="row">
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-shield-check me-2"></i>Test Coverage Analysis
                        </h5>
                        ${this.createCustomTable('testCoverageTable', this.generateTestCoverageData(), [
                    'Coverage Status', 'Count', 'Percentage', 'Risk Level'
                ])}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-tasks me-2"></i>Testing Tasks
                        </h5>
                        ${this.createCustomTable('testingTasksTable', this.generateTestingTasksData(), [
                    'ID', 'Title', 'State', 'Assigned To', 'Type'
                ])}
                    </div>
                </div>
            </div>

            <!-- SIT and UAT Testing Tasks -->
            ${this.generateTestingTasksSection()}
        `;

                this.setupTableInteractivity();
            }

            generateTestSuiteSection() {
                if (!this.metrics.testing.suiteMetrics || this.metrics.testing.suiteMetrics.size === 0) {
                    return '';
                }

                let suiteHtml = `
            <div class="subsection-header">
                <h4 class="subsection-title">
                    <i class="fas fa-layer-group me-2"></i>Test Execution by Suite
                </h4>
            </div>
        `;

                this.metrics.testing.suiteMetrics.forEach((metrics, suiteName) => {
                    const passRate = metrics.executed > 0 ? (metrics.passed / metrics.executed) * 100 : 0;
                    const automationRate = metrics.total > 0 ? (metrics.automated / metrics.total) * 100 : 0;

                    const suiteData = [
                        ['Total Test Cases', metrics.total, '', ''],
                        ['Automated Tests', metrics.automated, `${automationRate.toFixed(1)}%`, automationRate > 70 ? 'Good' : 'Needs Improvement'],
                        ['Manual Tests', metrics.manual, `${(100 - automationRate).toFixed(1)}%`, 'Manual'],
                        ['Executed Tests', metrics.executed, metrics.total > 0 ? `${(metrics.executed / metrics.total * 100).toFixed(1)}%` : '0%', 'Progress'],
                        ['Passed Tests', metrics.passed, `${passRate.toFixed(1)}%`, passRate > 95 ? 'Excellent' : passRate > 80 ? 'Good' : 'Needs Attention'],
                        ['Failed Tests', metrics.failed, metrics.executed > 0 ? `${(metrics.failed / metrics.executed * 100).toFixed(1)}%` : '0%', metrics.failed > 0 ? 'Action Required' : 'Good'],
                        ['Blocked Tests', metrics.blocked, metrics.executed > 0 ? `${(metrics.blocked / metrics.executed * 100).toFixed(1)}%` : '0%', metrics.blocked > 0 ? 'Blocked' : 'Clear']
                    ];

                    suiteHtml += `
                <div class="data-table-container">
                    <h6 class="table-title">
                        <i class="fas fa-folder me-2"></i>Suite: ${suiteName}
                    </h6>
                    ${this.createCustomTable(`suite_${suiteName.replace(/[^a-zA-Z0-9]/g, '_')}`, suiteData, [
                        'Metric', 'Count', 'Percentage', 'Status'
                    ])}
                </div>
            `;
                });

                return suiteHtml;
            }

            generateIterationTestSection() {
                if (!this.metrics.testing.iterationTestMetrics || this.metrics.testing.iterationTestMetrics.size === 0) {
                    return '';
                }

                let iterationHtml = `
            <div class="subsection-header">
                <h4 class="subsection-title">
                    <i class="fas fa-calendar-check me-2"></i>Test Execution by Selected Iteration
                </h4>
            </div>
        `;

                this.metrics.testing.iterationTestMetrics.forEach((metrics, iterationName) => {
                    const passRate = metrics.executedTests > 0 ? (metrics.passedTests / metrics.executedTests) * 100 : 0;
                    const automationRate = metrics.testCases > 0 ? (metrics.automatedTests / metrics.testCases) * 100 : 0;
                    const coverageRate = metrics.totalStories > 0 ? (metrics.coverageStories / metrics.totalStories) * 100 : 0;

                    const iterationData = [
                        ['Stories in Iteration', metrics.totalStories, '', ''],
                        ['Stories with Test Coverage', metrics.coverageStories, `${coverageRate.toFixed(1)}%`, coverageRate > 80 ? 'Good' : 'At Risk'],
                        ['Test Cases Linked', metrics.testCases, '', ''],
                        ['Automated Tests', metrics.automatedTests, `${automationRate.toFixed(1)}%`, automationRate > 70 ? 'Good' : 'Needs Improvement'],
                        ['Manual Tests', metrics.manualTests, `${(100 - automationRate).toFixed(1)}%`, 'Manual'],
                        ['Executed Tests', metrics.executedTests, metrics.testCases > 0 ? `${(metrics.executedTests / metrics.testCases * 100).toFixed(1)}%` : '0%', 'Progress'],
                        ['Passed Tests', metrics.passedTests, `${passRate.toFixed(1)}%`, passRate > 95 ? 'Excellent' : passRate > 80 ? 'Good' : 'Needs Attention'],
                        ['Failed Tests', metrics.failedTests, metrics.executedTests > 0 ? `${(metrics.failedTests / metrics.executedTests * 100).toFixed(1)}%` : '0%', metrics.failedTests > 0 ? 'Action Required' : 'Good']
                    ];

                    iterationHtml += `
                <div class="data-table-container">
                    <h6 class="table-title">
                        <i class="fas fa-calendar me-2"></i>Iteration: ${iterationName}
                    </h6>
                    ${this.createCustomTable(`iteration_${iterationName.replace(/[^a-zA-Z0-9]/g, '_')}`, iterationData, [
                        'Metric', 'Count', 'Percentage', 'Status'
                    ])}
                </div>
            `;
                });

                return iterationHtml;
            }

            generateTestingTasksSection() {
                const sitTasks = this.currentData.testTasks.filter(task =>
                    task.fields['System.Title'].toLowerCase().includes('sit'));
                const uatTasks = this.currentData.testTasks.filter(task =>
                    task.fields['System.Title'].toLowerCase().includes('uat'));

                if (sitTasks.length === 0 && uatTasks.length === 0) {
                    return '';
                }

                let tasksHtml = `
            <div class="subsection-header">
                <h4 class="subsection-title">
                    <i class="fas fa-clipboard-check me-2"></i>Testing Tasks Breakdown
                </h4>
            </div>
        `;

                if (sitTasks.length > 0) {
                    const sitData = sitTasks.map(task => [
                        task.id,
                        this.truncateText(task.fields['System.Title'] || '', 50),
                        `<span class="status-badge status-${task.fields['System.State'].toLowerCase().replace(' ', '-')}">${task.fields['System.State']}</span>`,
                        task.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        '<span class="test-tag sit">SIT Testing</span>'
                    ]);

                    tasksHtml += `
                <div class="data-table-container">
                    <h6 class="table-title">
                        <i class="fas fa-cogs me-2"></i>SIT Testing Tasks
                    </h6>
                    ${this.createCustomTable('sitTasksTable', sitData, [
                        'ID', 'Title', 'State', 'Assigned To', 'Type'
                    ])}
                </div>
            `;
                }

                if (uatTasks.length > 0) {
                    const uatData = uatTasks.map(task => [
                        task.id,
                        this.truncateText(task.fields['System.Title'] || '', 50),
                        `<span class="status-badge status-${task.fields['System.State'].toLowerCase().replace(' ', '-')}">${task.fields['System.State']}</span>`,
                        task.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        '<span class="test-tag uat">UAT Testing</span>'
                    ]);

                    tasksHtml += `
                <div class="data-table-container">
                    <h6 class="table-title">
                        <i class="fas fa-user-check me-2"></i>UAT Testing Tasks
                    </h6>
                    ${this.createCustomTable('uatTasksTable', uatData, [
                        'ID', 'Title', 'State', 'Assigned To', 'Type'
                    ])}
                </div>
            `;
                }

                return tasksHtml;
            }

            // Custom table creation method (replaces DataTables)
            createCustomTable(tableId, data, headers, enableSearch = false) {
                const tableHtml = `
            <div class="table-responsive">
                ${enableSearch ? `
                    <div class="table-controls">
                        <div class="table-search">
                            <input type="text" class="form-control" placeholder="Search..." onkeyup="dashboard.filterTable('${tableId}', this.value)">
                        </div>
                        <div class="table-filters">
                            <select class="form-select form-select-sm" onchange="dashboard.filterTableByColumn('${tableId}', this.value, this.selectedIndex)">
                                <option value="">All</option>
                                ${headers.map((header, index) => `<option value="${index}">${header}</option>`).join('')}
                            </select>
                        </div>
                    </div>
                ` : ''}
                <table class="custom-table" id="${tableId}">
                    <thead>
                        <tr>
                            ${headers.map((header, index) => `
                                <th onclick="dashboard.sortTable('${tableId}', ${index})" style="cursor: pointer;">
                                    ${header} <i class="fas fa-sort text-muted"></i>
                                </th>
                            `).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${data.map(row => `
                            <tr>
                                ${row.map(cell => `<td>${cell}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                <div class="table-pagination">
                    <div class="pagination-info">
                        Showing <span id="${tableId}_start">1</span> to <span id="${tableId}_end">${Math.min(25, data.length)}</span> of <span id="${tableId}_total">${data.length}</span> entries
                    </div>
                    <div class="pagination-controls">
                        <button class="btn btn-sm btn-outline-primary" onclick="dashboard.previousPage('${tableId}')" id="${tableId}_prev" ${data.length <= 25 ? 'disabled' : ''}>Previous</button>
                        <button class="btn btn-sm btn-outline-primary ms-1" onclick="dashboard.nextPage('${tableId}')" id="${tableId}_next" ${data.length <= 25 ? 'disabled' : ''}>Next</button>
                    </div>
                </div>
            </div>
        `;

                // Store original data for filtering/sorting
                this.tableData = this.tableData || {};
                this.tableData[tableId] = {
                    original: data,
                    current: data,
                    currentPage: 0,
                    pageSize: 25,
                    sortColumn: -1,
                    sortDirection: 'asc'
                };

                return tableHtml;
            }

            setupTableInteractivity() {
                // Initialize pagination for all tables
                Object.keys(this.tableData || {}).forEach(tableId => {
                    this.updateTablePagination(tableId);
                });
            }

            filterTable(tableId, searchTerm) {
                if (!this.tableData[tableId]) return;

                const originalData = this.tableData[tableId].original;
                const filteredData = originalData.filter(row =>
                    row.some(cell =>
                        cell.toString().toLowerCase().includes(searchTerm.toLowerCase())
                    )
                );

                this.tableData[tableId].current = filteredData;
                this.tableData[tableId].currentPage = 0;
                this.updateTableDisplay(tableId);
            }

            sortTable(tableId, columnIndex) {
                if (!this.tableData[tableId]) return;

                const tableInfo = this.tableData[tableId];
                const isCurrentColumn = tableInfo.sortColumn === columnIndex;
                const newDirection = isCurrentColumn && tableInfo.sortDirection === 'asc' ? 'desc' : 'asc';

                tableInfo.sortColumn = columnIndex;
                tableInfo.sortDirection = newDirection;

                tableInfo.current.sort((a, b) => {
                    const aVal = this.getTableCellTextContent(a[columnIndex]);
                    const bVal = this.getTableCellTextContent(b[columnIndex]);

                    const result = aVal.localeCompare(bVal, undefined, { numeric: true });
                    return newDirection === 'asc' ? result : -result;
                });

                this.updateTableDisplay(tableId);
                this.updateSortIcons(tableId, columnIndex, newDirection);
            }

            getTableCellTextContent(cellHtml) {
                // Extract text content from HTML
                const div = document.createElement('div');
                div.innerHTML = cellHtml;
                return div.textContent || div.innerText || '';
            }

            updateSortIcons(tableId, sortedColumn, direction) {
                const table = document.getElementById(tableId);
                if (!table) return;

                const headers = table.querySelectorAll('thead th');
                headers.forEach((header, index) => {
                    const icon = header.querySelector('i');
                    if (index === sortedColumn) {
                        icon.className = `fas fa-sort-${direction === 'asc' ? 'up' : 'down'}`;
                    } else {
                        icon.className = 'fas fa-sort text-muted';
                    }
                });
            }

            nextPage(tableId) {
                if (!this.tableData[tableId]) return;

                const tableInfo = this.tableData[tableId];
                const maxPage = Math.ceil(tableInfo.current.length / tableInfo.pageSize) - 1;

                if (tableInfo.currentPage < maxPage) {
                    tableInfo.currentPage++;
                    this.updateTableDisplay(tableId);
                }
            }

            previousPage(tableId) {
                if (!this.tableData[tableId]) return;

                const tableInfo = this.tableData[tableId];
                if (tableInfo.currentPage > 0) {
                    tableInfo.currentPage--;
                    this.updateTableDisplay(tableId);
                }
            }

            updateTableDisplay(tableId) {
                const table = document.getElementById(tableId);
                if (!table || !this.tableData[tableId]) return;

                const tableInfo = this.tableData[tableId];
                const startIndex = tableInfo.currentPage * tableInfo.pageSize;
                const endIndex = Math.min(startIndex + tableInfo.pageSize, tableInfo.current.length);
                const pageData = tableInfo.current.slice(startIndex, endIndex);

                const tbody = table.querySelector('tbody');
                tbody.innerHTML = pageData.map(row => `
            <tr>
                ${row.map(cell => `<td>${cell}</td>`).join('')}
            </tr>
        `).join('');

                this.updateTablePagination(tableId);
            }

            updateTablePagination(tableId) {
                if (!this.tableData[tableId]) return;

                const tableInfo = this.tableData[tableId];
                const startIndex = tableInfo.currentPage * tableInfo.pageSize;
                const endIndex = Math.min(startIndex + tableInfo.pageSize, tableInfo.current.length);

                const startEl = document.getElementById(`${tableId}_start`);
                const endEl = document.getElementById(`${tableId}_end`);
                const totalEl = document.getElementById(`${tableId}_total`);
                const prevBtn = document.getElementById(`${tableId}_prev`);
                const nextBtn = document.getElementById(`${tableId}_next`);

                if (startEl) startEl.textContent = tableInfo.current.length > 0 ? startIndex + 1 : 0;
                if (endEl) endEl.textContent = endIndex;
                if (totalEl) totalEl.textContent = tableInfo.current.length;

                if (prevBtn) prevBtn.disabled = tableInfo.currentPage === 0;
                if (nextBtn) {
                    const maxPage = Math.ceil(tableInfo.current.length / tableInfo.pageSize) - 1;
                    nextBtn.disabled = tableInfo.currentPage >= maxPage;
                }
            }

            // Data generation methods for tables
            countByStatus(items) {
                const count = { new: 0, active: 0, resolved: 0, closed: 0 };

                items.forEach(item => {
                    const state = item.fields['System.State'];
                    if (state === 'New') count.new++;
                    else if (['Active', 'In Progress'].includes(state)) count.active++;
                    else if (state === 'Resolved') count.resolved++;
                    else if (['Closed', 'Done'].includes(state)) count.closed++;
                    else count.new++;
                });

                return count;
            }

            getStatusBadgeColor(status) {
                switch (status.toLowerCase()) {
                    case 'good':
                    case 'excellent':
                        return 'success';
                    case 'needs improvement':
                    case 'needs attention':
                    case 'at risk':
                        return 'warning';
                    case 'critical':
                    case 'action required':
                        return 'danger';
                    case 'blocked':
                        return 'secondary';
                    default:
                        return 'info';
                }
            }

            // Continue with more data generation methods...
            generateUserStoriesData() {
                return this.currentData.userStories.slice(0, 200).map(story => [
                    story.id,
                    `<span title="${story.fields['System.Title']}">${this.truncateText(story.fields['System.Title'] || '', 60)}</span>`,
                    `<span class="status-badge status-${story.fields['System.State'].toLowerCase().replace(' ', '-')}">${story.fields['System.State']}</span>`,
                    story.fields['System.AssignedTo']?.displayName || 'Unassigned',
                    `<span class="badge bg-primary">${story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0}</span>`,
                    `<span class="priority-indicator priority-${story.fields['Microsoft.VSTS.Common.Priority'] || 3}"></span>P${story.fields['Microsoft.VSTS.Common.Priority'] || 3}`,
                    new Date(story.fields['System.CreatedDate']).toLocaleDateString(),
                    this.formatTags(story.fields['System.Tags'] || '')
                ]);
            }

            generateFeaturesData() {
                return this.currentData.features.slice(0, 100).map(feature => [
                    feature.id,
                    `<span title="${feature.fields['System.Title']}">${this.truncateText(feature.fields['System.Title'] || '', 50)}</span>`,
                    `<span class="status-badge status-${feature.fields['System.State'].toLowerCase().replace(' ', '-')}">${feature.fields['System.State']}</span>`,
                    feature.fields['System.AssignedTo']?.displayName || 'Unassigned',
                    `<span class="priority-indicator priority-${feature.fields['Microsoft.VSTS.Common.Priority'] || 3}"></span>P${feature.fields['Microsoft.VSTS.Common.Priority'] || 3}`
                ]);
            }

            generateEpicsData() {
                return this.currentData.epics.slice(0, 50).map(epic => [
                    epic.id,
                    `<span title="${epic.fields['System.Title']}">${this.truncateText(epic.fields['System.Title'] || '', 50)}</span>`,
                    `<span class="status-badge status-${epic.fields['System.State'].toLowerCase().replace(' ', '-')}">${epic.fields['System.State']}</span>`,
                    epic.fields['System.AssignedTo']?.displayName || 'Unassigned',
                    `<span class="priority-indicator priority-${epic.fields['Microsoft.VSTS.Common.Priority'] || 3}"></span>P${epic.fields['Microsoft.VSTS.Common.Priority'] || 3}`
                ]);
            }

            generateEnvironmentData() {
                const envs = this.metrics.quality.bugsByEnvironment;
                const total = Object.values(envs).reduce((sum, count) => sum + count, 0);

                return [
                    { env: 'Development', count: envs.dev || 0, classification: 'Bug' },
                    { env: 'QA/Testing', count: envs.qa || 0, classification: 'Bug' },
                    { env: 'UAT/Staging', count: envs.uat || 0, classification: 'Bug' },
                    { env: 'Production', count: envs.prod || 0, classification: 'Defect' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;

                    return [
                        `<strong>${row.env}</strong>`,
                        row.count,
                        `${percentage.toFixed(1)}%`,
                        `<span class="badge bg-${row.classification === 'Defect' ? 'danger' : 'warning'}">${row.classification}</span>`,
                        `<div class="progress" style="height: 15px;">
                    <div class="progress-bar bg-${row.classification === 'Defect' ? 'danger' : 'warning'}" 
                         style="width: ${percentage}%; font-size: 0.7rem; line-height: 15px;">
                        ${percentage > 15 ? percentage.toFixed(0) + '%' : ''}
                    </div>
                 </div>`
                    ];
                });
            }

            generateBugsDetailData() {
                const allBugs = [...(this.currentData.bugs || []), ...(this.currentData.defects || [])];

                return allBugs.slice(0, 200).map(bug => {
                    const type = this.isProductionIssue(bug) ? 'Defect' : 'Bug';
                    const env = this.detectEnvironment(bug);
                    const severity = bug.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    const priority = bug.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const age = Math.floor((new Date() - new Date(bug.fields['System.CreatedDate'])) / (1000 * 60 * 60 * 24));

                    const severityClass = severity.includes('1') ? 'severity-critical' :
                        severity.includes('2') ? 'severity-high' :
                            severity.includes('3') ? 'severity-medium' : 'severity-low';

                    return [
                        bug.id,
                        `<span title="${bug.fields['System.Title']}">${this.truncateText(bug.fields['System.Title'] || '', 50)}</span>`,
                        `<span class="badge bg-${type === 'Defect' ? 'danger' : 'warning'}">${type}</span>`,
                        `<span class="test-tag ${env}">${env.toUpperCase()}</span>`,
                        `<span class="severity-badge ${severityClass}">${severity}</span>`,
                        `<span class="priority-indicator priority-${priority}"></span>P${priority}`,
                        `<span class="status-badge status-${bug.fields['System.State'].toLowerCase().replace(' ', '-')}">${bug.fields['System.State']}</span>`,
                        bug.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        age
                    ];
                });
            }

            generateSeverityData() {
                const severity = this.metrics.quality.bugsBySeverity;
                const total = Object.values(severity).reduce((sum, count) => sum + count, 0);

                return [
                    { name: 'Critical', count: severity.critical || 0, class: 'severity-critical' },
                    { name: 'High', count: severity.high || 0, class: 'severity-high' },
                    { name: 'Medium', count: severity.medium || 0, class: 'severity-medium' },
                    { name: 'Low', count: severity.low || 0, class: 'severity-low' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;
                    const status = row.name === 'Critical' && row.count > 0 ? 'Urgent' :
                        row.name === 'High' && row.count > 5 ? 'High Priority' : 'Normal';

                    return [
                        `<span class="severity-badge ${row.class}">${row.name}</span>`,
                        row.count,
                        `${percentage.toFixed(1)}%`,
                        `<span class="badge bg-${status === 'Urgent' ? 'danger' : status === 'High Priority' ? 'warning' : 'success'}">${status}</span>`
                    ];
                });
            }

            generatePriorityData() {
                const priority = this.metrics.quality.bugsByPriority;
                const total = Object.values(priority).reduce((sum, count) => sum + count, 0);

                return [
                    { name: 'P1 (Critical)', count: priority[1] || 0, focus: 'Immediate' },
                    { name: 'P2 (High)', count: priority[2] || 0, focus: 'This Sprint' },
                    { name: 'P3 (Medium)', count: priority[3] || 0, focus: 'Next Sprint' },
                    { name: 'P4 (Low)', count: priority[4] || 0, focus: 'Backlog' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;

                    return [
                        row.name,
                        row.count,
                        `${percentage.toFixed(1)}%`,
                        `<span class="badge bg-${row.focus === 'Immediate' ? 'danger' : row.focus === 'This Sprint' ? 'warning' : 'info'}">${row.focus}</span>`
                    ];
                });
            }

            generateTestCategoriesData() {
                const categories = this.metrics.testing.categoryMetrics;
                const total = this.metrics.testing.totalTestCases;

                return Object.entries(categories).map(([category, count]) => {
                    const percentage = total > 0 ? (count / total) * 100 : 0;
                    const type = ['automated', 'manual'].includes(category) ? 'Execution' : 'Category';
                    const iconMap = {
                        automated: 'robot',
                        manual: 'hand-paper',
                        regression: 'redo',
                        smoke: 'fire',
                        integration: 'link',
                        unit: 'cube',
                        api: 'plug',
                        ui: 'desktop',
                        e2e: 'route',
                        sit: 'cogs',
                        uat: 'user-check'
                    };

                    return [
                        `<i class="fas fa-${iconMap[category] || 'vial'} me-1"></i>${category.charAt(0).toUpperCase() + category.slice(1)}`,
                        count,
                        `${percentage.toFixed(1)}%`,
                        `<span class="badge bg-${type === 'Execution' ? 'primary' : 'info'}">${type}</span>`,
                        `<div class="progress" style="height: 15px;">
                    <div class="progress-bar" style="width: ${percentage}%; font-size: 0.7rem; line-height: 15px;">
                        ${percentage > 15 ? percentage.toFixed(0) + '%' : ''}
                    </div>
                 </div>`
                    ];
                });
            }

            generateTestCasesDetailData() {
                return this.currentData.testCases.slice(0, 200).map(tc => {
                    const automationStatus = this.getTestCaseAutomationStatus(tc);
                    const categories = this.getTestCaseCategories(tc);
                    const state = tc.fields['System.State'];
                    const tags = (tc.fields['System.Tags'] || '').toLowerCase();

                    const executionStatus = state === 'Closed' || tags.includes('executed') ?
                        (tags.includes('passed') || state === 'Closed' ? 'Passed' :
                            tags.includes('failed') ? 'Failed' : 'Passed') : 'Not Executed';

                    return [
                        tc.id,
                        `<span title="${tc.fields['System.Title']}">${this.truncateText(tc.fields['System.Title'] || '', 60)}</span>`,
                        `<span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span>`,
                        tc.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        `<span class="test-tag ${automationStatus}">${automationStatus}</span>`,
                        categories.map(cat => `<span class="test-tag ${cat}">${cat}</span>`).join(' '),
                        tc.suiteName || 'General',
                        `<span class="badge bg-${executionStatus === 'Passed' ? 'success' : executionStatus === 'Failed' ? 'danger' : 'secondary'}">${executionStatus}</span>`
                    ];
                });
            }

            generateTestCoverageData() {
                const testing = this.metrics.testing;

                return [
                    {
                        status: 'Stories with Tests',
                        count: testing.storiesWithTests,
                        percentage: testing.testCoverage,
                        risk: testing.testCoverage > 80 ? 'Low' : testing.testCoverage > 60 ? 'Medium' : 'High'
                    },
                    {
                        status: 'Stories without Tests',
                        count: testing.storiesWithoutTests,
                        percentage: 100 - testing.testCoverage,
                        risk: testing.storiesWithoutTests > 10 ? 'High' : testing.storiesWithoutTests > 5 ? 'Medium' : 'Low'
                    }
                ].map(row => [
                    `<strong>${row.status}</strong>`,
                    row.count,
                    `${row.percentage.toFixed(1)}%`,
                    `<span class="badge bg-${row.risk === 'High' ? 'danger' : row.risk === 'Medium' ? 'warning' : 'success'}">${row.risk} Risk</span>`
                ]);
            }

            generateTestingTasksData() {
                return this.currentData.testTasks.slice(0, 100).map(task => {
                    const title = task.fields['System.Title'].toLowerCase();
                    let testType = 'General Testing';
                    if (title.includes('sit')) testType = 'SIT Testing';
                    else if (title.includes('uat')) testType = 'UAT Testing';
                    else if (title.includes('regression')) testType = 'Regression Testing';
                    else if (title.includes('smoke')) testType = 'Smoke Testing';

                    return [
                        task.id,
                        `<span title="${task.fields['System.Title']}">${this.truncateText(task.fields['System.Title'] || '', 50)}</span>`,
                        `<span class="status-badge status-${task.fields['System.State'].toLowerCase().replace(' ', '-')}">${task.fields['System.State']}</span>`,
                        task.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        `<span class="test-tag ${testType.toLowerCase().replace(' ', '-')}">${testType}</span>`
                    ];
                });
            }

            showTeamPerformance() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-users me-2"></i>Team Performance
                </h2>
            </div>

            <!-- Team Summary Cards -->
            <div class="row mb-4">
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-users"></i>
                        </div>
                        <div class="metric-value">${this.metrics.team.teamSize}</div>
                        <div class="metric-label">Team Members</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-chart-line"></i>
                        </div>
                        <div class="metric-value">${this.metrics.team.totalVelocity}</div>
                        <div class="metric-label">Total Velocity</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-user-check"></i>
                        </div>
                        <div class="metric-value">${this.metrics.team.averageVelocity.toFixed(1)}</div>
                        <div class="metric-label">Avg Velocity/Person</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card">
                        <div class="metric-icon">
                            <i class="fas fa-tasks"></i>
                        </div>
                        <div class="metric-value">${Array.from(this.metrics.team.members.values()).reduce((sum, m) => sum + (m.workInProgress || 0), 0)}</div>
                        <div class="metric-label">Total WIP</div>
                    </div>
                </div>
            </div>

            <!-- Team Contribution Summary -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-chart-bar me-2"></i>Team Contribution Summary
                </h5>
                <p class="text-muted" style="font-size: 0.9rem;">Aggregated team metrics without individual identification</p>
                ${this.createCustomTable('teamSummaryTable', this.generateTeamSummaryData(), [
                    'Work Type', 'Total Count', 'Team Average', 'Distribution', 'Completion Rate'
                ])}
            </div>

            <!-- Workload Distribution -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-balance-scale me-2"></i>Workload Distribution Analysis
                </h5>
                ${this.createCustomTable('workloadTable', this.generateWorkloadDistributionData(), [
                    'Workload Range', 'Team Members', 'Percentage', 'Load Status', 'Recommendation'
                ])}
            </div>

            <!-- Skills and Focus Areas -->
            <div class="row">
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-cogs me-2"></i>Skills Coverage
                        </h5>
                        ${this.createCustomTable('skillsTable', this.generateSkillsCoverageData(), [
                    'Skill Area', 'Contributors', 'Coverage %', 'Risk Level'
                ])}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-pie-chart me-2"></i>Work Type Distribution
                        </h5>
                        ${this.createCustomTable('workTypeTable', this.generateWorkTypeDistributionData(), [
                    'Work Type', 'Percentage', 'Focus Level', 'Balance Status'
                ])}
                    </div>
                </div>
            </div>
        `;

                this.setupTableInteractivity();
            }

            showIndividualMetrics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-user-check me-2"></i>Individual Metrics
                </h2>
            </div>

            <div class="alert alert-info" style="font-size: 0.9rem;">
                <i class="fas fa-info-circle me-1"></i>
                Individual metrics are provided for personal tracking and 1:1 discussions. Focus is on contribution and growth, not comparison.
            </div>

            <!-- Individual Contributions -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-user-cog me-2"></i>Individual Contributions Overview
                </h5>
                ${this.createCustomTable('individualTable', this.generateIndividualData(), [
                    'Team Member', 'Stories', 'Features', 'Points Completed', 'Tasks', 'Bugs Resolved', 'Tests Created', 'Tests Executed', 'WIP'
                ], true)}
            </div>

            <!-- Testing Contributions -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-vial me-2"></i>Testing Contributions by Individual
                </h5>
                ${this.createCustomTable('individualTestingTable', this.generateIndividualTestingData(), [
                    'Team Member', 'Test Cases Created', 'Test Cases Executed', 'Testing Tasks', 'Quality Contributions', 'Testing Focus %'
                ])}
            </div>

            <!-- Development vs Quality Focus -->
            <div class="row">
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-code me-2"></i>Development Focus
                        </h5>
                        ${this.createCustomTable('developmentFocusTable', this.generateDevelopmentFocusData(), [
                    'Team Member', 'Development Work', 'Focus %', 'Specialization'
                ])}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="data-table-container">
                        <h5 class="table-title">
                            <i class="fas fa-shield-check me-2"></i>Quality Focus
                        </h5>
                        ${this.createCustomTable('qualityFocusTable', this.generateQualityFocusData(), [
                    'Team Member', 'Quality Work', 'Focus %', 'Specialization'
                ])}
                    </div>
                </div>
            </div>
        `;

                this.setupTableInteractivity();
            }

            showReports() {
                const content = document.getElementById('dashboardContent');

                content.innerHTML = `
            <div class="section-header">
                <h2 class="section-title">
                    <i class="fas fa-file-alt me-2"></i>Reports & Export
                </h2>
            </div>

            <!-- Export Options -->
            <div class="row mb-4">
                <div class="col-md-3">
                    <div class="metric-card text-center">
                        <div class="metric-icon" style="background: rgba(40, 167, 69, 0.1); color: #28a745;">
                            <i class="fas fa-file-excel"></i>
                        </div>
                        <h6 class="mt-2">Excel Report</h6>
                        <p class="text-muted" style="font-size: 0.8rem;">Multi-sheet workbook with all metrics</p>
                        <button class="btn btn-success btn-sm" onclick="dashboard.exportToExcel()">
                            <i class="fas fa-download me-1"></i>Export Excel
                        </button>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card text-center">
                        <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                            <i class="fas fa-file-pdf"></i>
                        </div>
                        <h6 class="mt-2">PDF Dashboard</h6>
                        <p class="text-muted" style="font-size: 0.8rem;">Executive summary with key metrics</p>
                        <button class="btn btn-danger btn-sm" onclick="dashboard.exportToPDF()">
                            <i class="fas fa-download me-1"></i>Export PDF
                        </button>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card text-center">
                        <div class="metric-icon" style="background: rgba(23, 162, 184, 0.1); color: #17a2b8;">
                            <i class="fas fa-file-csv"></i>
                        </div>
                        <h6 class="mt-2">CSV Data</h6>
                        <p class="text-muted" style="font-size: 0.8rem;">Raw data for further analysis</p>
                        <button class="btn btn-info btn-sm" onclick="dashboard.exportToCSV()">
                            <i class="fas fa-download me-1"></i>Export CSV
                        </button>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="metric-card text-center">
                        <div class="metric-icon" style="background: rgba(255, 193, 7, 0.1); color: #ffc107;">
                            <i class="fas fa-chart-bar"></i>
                        </div>
                        <h6 class="mt-2">PowerBI Template</h6>
                        <p class="text-muted" style="font-size: 0.8rem;">Template for PowerBI analysis</p>
                        <button class="btn btn-warning btn-sm" onclick="dashboard.exportToPowerBI()">
                            <i class="fas fa-download me-1"></i>Export Template
                        </button>
                    </div>
                </div>
            </div>

            <!-- Data Summary for Export -->
            <div class="data-table-container">
                <h5 class="table-title">
                    <i class="fas fa-database me-2"></i>Export Data Summary
                </h5>
                ${this.createCustomTable('exportSummaryTable', this.generateExportSummaryData(), [
                    'Data Category', 'Record Count', 'Last Updated', 'Data Quality', 'Export Status'
                ])}
            </div>
        `;

                this.setupTableInteractivity();
            }

            // Team Performance Data Generation
            generateTeamSummaryData() {
                const team = this.metrics.team;
                const members = Array.from(team.members.values());

                const aggregates = {
                    stories: { total: 0, completed: 0 },
                    features: { total: 0, completed: 0 },
                    tasks: { total: 0, completed: 0 },
                    points: { total: 0, completed: 0 },
                    testCases: { created: 0, executed: 0 },
                    bugs: { total: 0 }
                };

                members.forEach(member => {
                    aggregates.stories.total += member.stories;
                    aggregates.features.total += member.features;
                    aggregates.tasks.total += member.tasks;
                    aggregates.points.total += member.points;
                    aggregates.points.completed += member.completedPoints;
                    aggregates.testCases.created += member.testCasesCreated;
                    aggregates.testCases.executed += member.testCasesExecuted;
                    aggregates.bugs.total += member.bugs;
                });

                const workTypes = [
                    {
                        type: 'User Stories',
                        total: aggregates.stories.total,
                        avg: (aggregates.stories.total / team.teamSize).toFixed(1),
                        completion: aggregates.stories.total > 0 ? ((aggregates.stories.total / aggregates.stories.total) * 100).toFixed(1) : 0
                    },
                    {
                        type: 'Story Points',
                        total: aggregates.points.completed,
                        avg: (aggregates.points.completed / team.teamSize).toFixed(1),
                        completion: aggregates.points.total > 0 ? ((aggregates.points.completed / aggregates.points.total) * 100).toFixed(1) : 0
                    },
                    {
                        type: 'Tasks',
                        total: aggregates.tasks.total,
                        avg: (aggregates.tasks.total / team.teamSize).toFixed(1),
                        completion: '85'
                    },
                    {
                        type: 'Test Cases Created',
                        total: aggregates.testCases.created,
                        avg: (aggregates.testCases.created / team.teamSize).toFixed(1),
                        completion: '100'
                    },
                    {
                        type: 'Test Cases Executed',
                        total: aggregates.testCases.executed,
                        avg: (aggregates.testCases.executed / team.teamSize).toFixed(1),
                        completion: aggregates.testCases.created > 0 ? ((aggregates.testCases.executed / aggregates.testCases.created) * 100).toFixed(1) : 0
                    }
                ];

                return workTypes.map(work => [
                    `<strong>${work.type}</strong>`,
                    work.total,
                    work.avg,
                    `<div class="progress" style="height: 15px;">
                <div class="progress-bar bg-info" style="width: 75%; font-size: 0.7rem; line-height: 15px;">Even</div>
             </div>`,
                    `${work.completion}%`
                ]);
            }

            generateWorkloadDistributionData() {
                const members = Array.from(this.metrics.team.members.values());
                const workloads = members.map(m => m.workInProgress || 0);

                const ranges = [
                    { range: '0-2 items', min: 0, max: 2, status: 'Under-utilized', recommendation: 'Assign more work' },
                    { range: '3-5 items', min: 3, max: 5, status: 'Optimal', recommendation: 'Maintain current load' },
                    { range: '6-8 items', min: 6, max: 8, status: 'High Load', recommendation: 'Monitor closely' },
                    { range: '9+ items', min: 9, max: 999, status: 'Overloaded', recommendation: 'Redistribute work' }
                ];

                return ranges.map(range => {
                    const count = workloads.filter(w => w >= range.min && w <= range.max).length;
                    const percentage = this.metrics.team.teamSize > 0 ? (count / this.metrics.team.teamSize) * 100 : 0;

                    return [
                        `<strong>${range.range}</strong>`,
                        count,
                        `${percentage.toFixed(1)}%`,
                        `<span class="badge bg-${range.status === 'Optimal' ? 'success' : range.status === 'Overloaded' ? 'danger' : 'warning'}">${range.status}</span>`,
                        range.recommendation
                    ];
                });
            }

            generateSkillsCoverageData() {
                const members = Array.from(this.metrics.team.members.values());
                const teamSize = this.metrics.team.teamSize;

                const skills = [
                    {
                        area: 'Development',
                        contributors: members.filter(m => m.stories > 0 || m.features > 0).length
                    },
                    {
                        area: 'Testing',
                        contributors: members.filter(m => m.testCasesCreated > 0 || m.testCasesExecuted > 0).length
                    },
                    {
                        area: 'Bug Resolution',
                        contributors: members.filter(m => m.bugs > 0).length
                    },
                    {
                        area: 'Task Management',
                        contributors: members.filter(m => m.tasks > 0).length
                    }
                ];

                return skills.map(skill => {
                    const coverage = teamSize > 0 ? (skill.contributors / teamSize) * 100 : 0;
                    const riskLevel = coverage > 70 ? 'Low' : coverage > 40 ? 'Medium' : 'High';

                    return [
                        `<strong>${skill.area}</strong>`,
                        skill.contributors,
                        `${coverage.toFixed(1)}%`,
                        `<span class="badge bg-${riskLevel === 'Low' ? 'success' : riskLevel === 'Medium' ? 'warning' : 'danger'}">${riskLevel}</span>`
                    ];
                });
            }

            generateWorkTypeDistributionData() {
                const members = Array.from(this.metrics.team.members.values());
                const totalWork = members.reduce((sum, m) => sum + m.stories + m.features + m.tasks + m.bugs, 0);

                const workTypes = [
                    { type: 'Development', count: members.reduce((sum, m) => sum + m.stories + m.features, 0) },
                    { type: 'Task Execution', count: members.reduce((sum, m) => sum + m.tasks, 0) },
                    { type: 'Quality/Bugs', count: members.reduce((sum, m) => sum + m.bugs, 0) },
                    { type: 'Testing', count: members.reduce((sum, m) => sum + m.testCasesCreated + m.testCasesExecuted, 0) }
                ];

                return workTypes.map(work => {
                    const percentage = totalWork > 0 ? (work.count / totalWork) * 100 : 0;
                    const focusLevel = percentage > 40 ? 'High' : percentage > 20 ? 'Medium' : 'Low';
                    const balance = percentage > 60 ? 'Over-focused' : percentage < 10 ? 'Under-focused' : 'Balanced';

                    return [
                        `<strong>${work.type}</strong>`,
                        `${percentage.toFixed(1)}%`,
                        `<span class="badge bg-${focusLevel === 'High' ? 'primary' : focusLevel === 'Medium' ? 'info' : 'secondary'}">${focusLevel}</span>`,
                        `<span class="badge bg-${balance === 'Balanced' ? 'success' : 'warning'}">${balance}</span>`
                    ];
                });
            }

            // Individual Metrics Data Generation
            generateIndividualData() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => [
                    `<strong>${name}</strong>`,
                    data.stories,
                    data.features,
                    `<span class="badge bg-primary">${data.completedPoints}</span>`,
                    data.tasks,
                    data.bugs,
                    data.testCasesCreated,
                    data.testCasesExecuted,
                    data.workInProgress
                ]);
            }

            generateIndividualTestingData() {
                const testingMembers = Array.from(this.metrics.individual.entries())
                    .filter(([name, data]) => data.testCasesCreated > 0 || data.testCasesExecuted > 0);

                if (testingMembers.length === 0) {
                    return [['No testing activities found', '', '', '', '', '']];
                }

                return testingMembers.map(([name, data]) => {
                    const totalWork = data.stories + data.tasks + data.bugs;
                    const testingWork = data.testCasesCreated + data.testCasesExecuted;
                    const testingFocus = totalWork > 0 ? (testingWork / totalWork) * 100 : 0;

                    return [
                        `<strong>${name}</strong>`,
                        data.testCasesCreated,
                        data.testCasesExecuted,
                        testingWork,
                        `<span class="badge bg-info">Quality Focus</span>`,
                        `${testingFocus.toFixed(1)}%`
                    ];
                });
            }

            generateDevelopmentFocusData() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => {
                    const devWork = data.stories + data.features;
                    const totalWork = devWork + data.tasks + data.bugs + data.testCasesCreated + data.testCasesExecuted;
                    const devFocus = totalWork > 0 ? (devWork / totalWork) * 100 : 0;

                    const specialization = devFocus > 70 ? 'Primary Developer' :
                        devFocus > 40 ? 'Mixed Role' : 'Supporting Role';

                    return [
                        `<strong>${name}</strong>`,
                        devWork,
                        `${devFocus.toFixed(1)}%`,
                        `<span class="badge bg-${specialization === 'Primary Developer' ? 'primary' : specialization === 'Mixed Role' ? 'info' : 'secondary'}">${specialization}</span>`
                    ];
                });
            }

            generateQualityFocusData() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => {
                    const qualityWork = data.bugs + data.testCasesCreated + data.testCasesExecuted;
                    const totalWork = data.stories + data.features + data.tasks + qualityWork;
                    const qualityFocus = totalWork > 0 ? (qualityWork / totalWork) * 100 : 0;

                    const specialization = qualityWork === 0 ? 'No Quality Work' :
                        qualityFocus > 50 ? 'Quality Specialist' :
                            qualityFocus > 25 ? 'Quality Contributor' : 'Limited Quality Work';

                    return [
                        `<strong>${name}</strong>`,
                        qualityWork,
                        `${qualityFocus.toFixed(1)}%`,
                        `<span class="badge bg-${specialization === 'Quality Specialist' ? 'success' : specialization === 'Quality Contributor' ? 'info' : 'secondary'}">${specialization}</span>`
                    ];
                });
            }

            generateExportSummaryData() {
                const dataCategories = [
                    {
                        category: 'Work Items',
                        count: this.currentData?.workItems?.length || 0,
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'User Stories',
                        count: this.currentData?.userStories?.length || 0,
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'Features',
                        count: this.currentData?.features?.length || 0,
                        quality: this.currentData?.features?.length > 0 ? 'Good' : 'Limited',
                        status: this.currentData?.features?.length > 0 ? 'Ready' : 'Partial'
                    },
                    {
                        category: 'Epics',
                        count: this.currentData?.epics?.length || 0,
                        quality: this.currentData?.epics?.length > 0 ? 'Good' : 'Limited',
                        status: this.currentData?.epics?.length > 0 ? 'Ready' : 'Partial'
                    },
                    {
                        category: 'Bugs & Defects',
                        count: (this.currentData?.bugs?.length || 0) + (this.currentData?.defects?.length || 0),
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'Test Cases',
                        count: this.currentData?.testCases?.length || 0,
                        quality: this.currentData?.testCases?.length > 0 ? 'Good' : 'Limited',
                        status: this.currentData?.testCases?.length > 0 ? 'Ready' : 'Partial'
                    },
                    {
                        category: 'Team Metrics',
                        count: this.metrics.team?.teamSize || 0,
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'Releases',
                        count: this.currentData?.releases?.size || 0,
                        quality: this.currentData?.releases?.size > 0 ? 'Good' : 'None',
                        status: this.currentData?.releases?.size > 0 ? 'Ready' : 'No Data'
                    }
                ];

                return dataCategories.map(data => [
                    `<strong>${data.category}</strong>`,
                    data.count,
                    new Date().toLocaleDateString(),
                    `<span class="badge bg-${data.quality === 'Good' ? 'success' : data.quality === 'Limited' ? 'warning' : 'secondary'}">${data.quality}</span>`,
                    `<span class="badge bg-${data.status === 'Ready' ? 'success' : data.status === 'Partial' ? 'warning' : 'secondary'}">${data.status}</span>`
                ]);
            }

            // Enhanced Export Functions with Real Implementation
            async exportToExcel() {
                try {
                    this.showLoading(true, 'Generating Excel report...');

                    const wb = XLSX.utils.book_new();

                    // Executive Summary Sheet
                    this.addExecutiveSummarySheet(wb);

                    // Delivery Metrics Sheet
                    this.addDeliveryMetricsSheet(wb);

                    // Quality Metrics Sheet
                    this.addQualityMetricsSheet(wb);

                    // Testing Analytics Sheet
                    this.addTestingAnalyticsSheet(wb);

                    // Team Performance Sheet
                    this.addTeamPerformanceSheet(wb);

                    // Individual Metrics Sheet (Anonymized)
                    this.addIndividualMetricsSheet(wb);

                    // Raw Data Sheets
                    this.addRawDataSheets(wb);

                    // Save the file
                    const areaPathNames = this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join('_');
                    const fileName = `ADO_Metrics_Report_${areaPathNames}_${new Date().toISOString().split('T')[0]}.xlsx`;
                    XLSX.writeFile(wb, fileName);

                    this.showLoading(false);
                    this.showToast('Excel report exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting to Excel:', error);
                    this.showLoading(false);
                    this.showToast('Error exporting Excel report', 'error');
                }
            }

            addExecutiveSummarySheet(wb) {
                const healthScore = this.calculateProjectHealthScore();

                const data = [
                    ['ADO Metrics Executive Summary', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', ''],
                    [`Area Paths: ${this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join(', ')}`, '', '', '', ''],
                    [`Iterations: ${this.selectedIterations.map(it => it.displayName || it.name).join(', ')}`, '', '', '', ''],
                    [`Test Plan: ${this.selectedTestPlan ? this.getTestPlanName(this.selectedTestPlan) : 'None'}`, '', '', '', ''],
                    [`Team Member Filter: ${this.selectedTeamMember || 'All'}`, '', '', '', ''],
                    ['', '', '', '', ''],
                    ['PROJECT HEALTH DASHBOARD', '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Health Component', 'Score', 'Target', 'Status', 'Impact'],
                    ['Overall Project Health', `${healthScore.overall}%`, '85%', this.getHealthScoreLabel(healthScore.overall), 'High'],
                    ['Delivery Health', `${healthScore.delivery}%`, '80%', this.getHealthScoreLabel(healthScore.delivery), 'High'],
                    ['Quality Health', `${healthScore.quality}%`, '90%', this.getHealthScoreLabel(healthScore.quality), 'Critical'],
                    ['Testing Health', `${healthScore.testing}%`, '85%', this.getHealthScoreLabel(healthScore.testing), 'Medium'],
                    ['Team Health', `${healthScore.team}%`, '80%', this.getHealthScoreLabel(healthScore.team), 'Medium'],
                    ['', '', '', '', ''],
                    ['KEY PERFORMANCE INDICATORS', '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Delivery Metrics', '', '', '', ''],
                    ['Total User Stories', this.metrics.delivery?.totalStories || 0, '', '', ''],
                    ['Completed Stories', this.metrics.delivery?.completedStories || 0, '', '', ''],
                    ['Story Completion Rate', `${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['Story Points Delivered', this.metrics.delivery?.velocity || 0, '', '', ''],
                    ['Points Completion Rate', `${this.metrics.delivery?.pointsCompletionRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['Blocked Items', this.metrics.delivery?.blockedItems || 0, '', '', ''],
                    ['Work in Progress', this.metrics.delivery?.workInProgress || 0, '', '', ''],
                    ['', '', '', '', ''],
                    ['Quality Metrics', '', '', '', ''],
                    ['Bugs (Lower Environment)', this.metrics.quality?.totalBugs || 0, '', '', ''],
                    ['Production Defects', this.metrics.quality?.totalDefects || 0, '', '', ''],
                    ['Critical Issues', this.metrics.quality?.criticalBugs || 0, '', '', ''],
                    ['Bug Density', this.metrics.quality?.bugDensity?.toFixed(3) || 0, '', '', ''],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['', '', '', '', ''],
                    ['Testing Metrics', '', '', '', ''],
                    ['Total Test Cases', this.metrics.testing?.totalTestCases || 0, '', '', ''],
                    ['Automated Tests', this.metrics.testing?.automatedTests || 0, '', '', ''],
                    ['Manual Tests', this.metrics.testing?.manualTests || 0, '', '', ''],
                    ['Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['Test Coverage', `${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%`, '', '', ''],
                    ['Test Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['', '', '', '', ''],
                    ['Team Performance', '', '', '', ''],
                    ['Team Size', this.metrics.team?.teamSize || 0, '', '', ''],
                    ['Total Team Velocity', this.metrics.team?.totalVelocity || 0, '', '', ''],
                    ['Average Velocity per Person', this.metrics.team?.averageVelocity?.toFixed(1) || 0, '', '', '']
                ];

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 35 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 10 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Executive Summary');
            }

            addDeliveryMetricsSheet(wb) {
                const data = [
                    ['DELIVERY METRICS DETAIL', '', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', '', ''],
                    [`Context: ${this.selectedAreaPaths.map(ap => ap.displayName).join(', ')} | ${this.selectedIterations.map(it => it.displayName).join(', ')}`, '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['Delivery Summary', '', '', '', '', '', '', ''],
                    ['Metric', 'Value', 'Target', 'Status', '', '', '', ''],
                    ['Story Completion Rate', `${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`, '80%', this.metrics.delivery?.completionRate >= 80 ? 'Good' : 'Needs Improvement', '', '', '', ''],
                    ['Points Completion Rate', `${this.metrics.delivery?.pointsCompletionRate?.toFixed(1) || 0}%`, '80%', this.metrics.delivery?.pointsCompletionRate >= 80 ? 'Good' : 'Needs Improvement', '', '', '', ''],
                    ['Velocity', this.metrics.delivery?.velocity || 0, '40+', this.metrics.delivery?.velocity >= 40 ? 'Good' : 'Below Target', '', '', '', ''],
                    ['Blocked Items', this.metrics.delivery?.blockedItems || 0, '0', this.metrics.delivery?.blockedItems === 0 ? 'Good' : 'Action Required', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['DETAILED USER STORIES', '', '', '', '', '', '', ''],
                    ['ID', 'Title', 'State', 'Assigned To', 'Story Points', 'Priority', 'Created Date', 'Tags']
                ];

                // Add user stories data
                this.currentData.userStories.forEach(story => {
                    data.push([
                        story.id,
                        story.fields['System.Title'] || '',
                        story.fields['System.State'],
                        story.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0,
                        story.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        new Date(story.fields['System.CreatedDate']).toLocaleDateString(),
                        story.fields['System.Tags'] || ''
                    ]);
                });

                // Add Features section
                data.push(['', '', '', '', '', '', '', '']);
                data.push(['FEATURES', '', '', '', '', '', '', '']);
                data.push(['ID', 'Title', 'State', 'Assigned To', 'Priority', '', '', '']);

                this.currentData.features.forEach(feature => {
                    data.push([
                        feature.id,
                        feature.fields['System.Title'] || '',
                        feature.fields['System.State'],
                        feature.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        feature.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        '', '', ''
                    ]);
                });

                // Add Epics section
                data.push(['', '', '', '', '', '', '', '']);
                data.push(['EPICS', '', '', '', '', '', '', '']);
                data.push(['ID', 'Title', 'State', 'Assigned To', 'Priority', '', '', '']);

                this.currentData.epics.forEach(epic => {
                    data.push([
                        epic.id,
                        epic.fields['System.Title'] || '',
                        epic.fields['System.State'],
                        epic.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        epic.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        '', '', ''
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 10 }, { wch: 50 }, { wch: 12 }, { wch: 20 }, { wch: 12 }, { wch: 10 }, { wch: 12 }, { wch: 30 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Delivery Metrics');
            }

            addQualityMetricsSheet(wb) {
                const data = [
                    ['QUALITY METRICS DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Quality Overview', '', '', '', '', '', ''],
                    ['Metric', 'Value', 'Target', 'Status', '', '', ''],
                    ['Bugs (Lower Environment)', this.metrics.quality?.totalBugs || 0, '<20', this.metrics.quality?.totalBugs < 20 ? 'Good' : 'Action Required', '', '', ''],
                    ['Production Defects', this.metrics.quality?.totalDefects || 0, '0', this.metrics.quality?.totalDefects === 0 ? 'Excellent' : 'Critical', '', '', ''],
                    ['Critical Issues', this.metrics.quality?.criticalBugs || 0, '0', this.metrics.quality?.criticalBugs === 0 ? 'Good' : 'Urgent', '', '', ''],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '<5%', this.metrics.quality?.defectEscapeRate < 5 ? 'Good' : 'Needs Improvement', '', '', ''],
                    ['Bug Density', this.metrics.quality?.bugDensity?.toFixed(3) || 0, '<0.1', this.metrics.quality?.bugDensity < 0.1 ? 'Good' : 'High', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Issues by Environment', '', '', '', '', '', ''],
                    ['Environment', 'Count', 'Classification', 'Percentage', '', '', '']
                ];

                // Add environment data
                const envs = this.metrics.quality.bugsByEnvironment;
                const total = Object.values(envs).reduce((sum, count) => sum + count, 0);

                [
                    { env: 'Development', count: envs.dev || 0, classification: 'Bug' },
                    { env: 'QA/Testing', count: envs.qa || 0, classification: 'Bug' },
                    { env: 'UAT/Staging', count: envs.uat || 0, classification: 'Bug' },
                    { env: 'Production', count: envs.prod || 0, classification: 'Defect' }
                ].forEach(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;
                    data.push([row.env, row.count, row.classification, `${percentage.toFixed(1)}%`, '', '', '']);
                });

                // Add detailed issues
                data.push(['', '', '', '', '', '', '']);
                data.push(['DETAILED ISSUES', '', '', '', '', '', '']);
                data.push(['ID', 'Title', 'Type', 'Environment', 'Severity', 'Priority', 'State']);

                const allBugs = [...(this.currentData.bugs || []), ...(this.currentData.defects || [])];
                allBugs.forEach(bug => {
                    data.push([
                        bug.id,
                        bug.fields['System.Title'] || '',
                        this.isProductionIssue(bug) ? 'Defect' : 'Bug',
                        this.detectEnvironment(bug).toUpperCase(),
                        bug.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium',
                        bug.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        bug.fields['System.State']
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 10 }, { wch: 50 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 10 }, { wch: 12 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Quality Metrics');
            }

            addTestingAnalyticsSheet(wb) {
                const data = [
                    ['TESTING ANALYTICS DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Testing Overview', '', '', '', '', '', ''],
                    ['Metric', 'Value', 'Target', 'Status', '', '', ''],
                    ['Total Test Cases', this.metrics.testing?.totalTestCases || 0, '100+', '', '', '', ''],
                    ['Automated Tests', this.metrics.testing?.automatedTests || 0, '70%', '', '', '', ''],
                    ['Manual Tests', this.metrics.testing?.manualTests || 0, '30%', '', '', '', ''],
                    ['Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '70%', this.metrics.testing?.automationRate >= 70 ? 'Good' : 'Needs Improvement', '', '', ''],
                    ['Test Coverage', `${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%`, '80%', this.metrics.testing?.testCoverage >= 80 ? 'Good' : 'At Risk', '', '', ''],
                    ['Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '95%', this.metrics.testing?.passRate >= 95 ? 'Excellent' : 'Good', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Test Execution Summary', '', '', '', '', '', ''],
                    ['Status', 'Count', 'Percentage', '', '', '', ''],
                    ['Passed', this.metrics.testing?.passedTests || 0, `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '', '', '', ''],
                    ['Failed', this.metrics.testing?.failedTests || 0, '', '', '', '', ''],
                    ['Not Executed', (this.metrics.testing?.totalTestCases || 0) - (this.metrics.testing?.executedTests || 0), '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['DETAILED TEST CASES', '', '', '', '', '', ''],
                    ['ID', 'Title', 'State', 'Assigned To', 'Automation', 'Suite', 'Categories']
                ];

                // Add test cases data
                this.currentData.testCases.forEach(tc => {
                    const automationStatus = this.getTestCaseAutomationStatus(tc);
                    const categories = this.getTestCaseCategories(tc);

                    data.push([
                        tc.id,
                        tc.fields['System.Title'] || '',
                        tc.fields['System.State'],
                        tc.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        automationStatus,
                        tc.suiteName || 'General',
                        categories.join(', ')
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 10 }, { wch: 50 }, { wch: 12 }, { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 25 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Testing Analytics');
            }

            addTeamPerformanceSheet(wb) {
                const data = [
                    ['TEAM PERFORMANCE DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Team Overview', '', '', '', '', '', ''],
                    ['Metric', 'Value', '', '', '', '', ''],
                    ['Team Size', this.metrics.team?.teamSize || 0, '', '', '', '', ''],
                    ['Total Velocity', this.metrics.team?.totalVelocity || 0, '', '', '', '', ''],
                    ['Average Velocity per Person', this.metrics.team?.averageVelocity?.toFixed(1) || 0, '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Team Contribution Summary (Anonymized)', '', '', '', '', '', ''],
                    ['Member ID', 'Stories', 'Features', 'Story Points', 'Tasks', 'Tests Created', 'Tests Executed']
                ];

                // Add anonymized individual data
                let memberIndex = 1;
                Array.from(this.metrics.individual.values()).forEach(memberData => {
                    data.push([
                        `Member ${memberIndex}`,
                        memberData.stories,
                        memberData.features,
                        memberData.completedPoints,
                        memberData.tasks,
                        memberData.testCasesCreated,
                        memberData.testCasesExecuted
                    ]);
                    memberIndex++;
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 15 }, { wch: 10 }, { wch: 10 }, { wch: 15 }, { wch: 10 }, { wch: 15 }, { wch: 15 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Team Performance');
            }

            addIndividualMetricsSheet(wb) {
                const data = [
                    ['INDIVIDUAL METRICS (ANONYMIZED)', '', '', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', '', '', ''],
                    ['Note: Individual metrics for 1:1 discussions and personal development', '', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', '', ''],
                    ['Individual Contributions', '', '', '', '', '', '', '', ''],
                    ['Member ID', 'Work Items Assigned', 'Work Items Completed', 'Story Points', 'Work in Progress', 'Quality Score', 'Testing Focus', 'Development Focus', 'Specialization']
                ];

                // Add individual metrics with privacy protection
                let memberIndex = 1;
                if (this.metrics.individualDetailed) {
                    this.metrics.individualDetailed.forEach((metrics, name) => {
                        const totalWork = metrics.workItems.assigned;
                        const completionRate = totalWork > 0 ? (metrics.workItems.completed / totalWork) * 100 : 0;
                        const testingWork = metrics.quality.testCasesCreated + metrics.quality.testCasesExecuted;
                        const devWork = metrics.workTypes.stories + metrics.workTypes.features;
                        const testingFocus = totalWork > 0 ? (testingWork / totalWork) * 100 : 0;
                        const devFocus = totalWork > 0 ? (devWork / totalWork) * 100 : 0;

                        let specialization = 'Balanced';
                        if (devFocus > 70) specialization = 'Development Focused';
                        else if (testingFocus > 50) specialization = 'Quality Focused';
                        else if (metrics.workTypes.tasks > devWork + testingWork) specialization = 'Task Focused';

                        data.push([
                            `Member ${memberIndex}`,
                            metrics.workItems.assigned,
                            metrics.workItems.completed,
                            metrics.storyPoints.completed,
                            metrics.workItems.inProgress,
                            this.calculateQualityScore(metrics),
                            `${testingFocus.toFixed(1)}%`,
                            `${devFocus.toFixed(1)}%`,
                            specialization
                        ]);
                        memberIndex++;
                    });
                }

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 12 }, { wch: 15 }, { wch: 12 }, { wch: 12 }, { wch: 15 }, { wch: 18 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Individual Metrics');
            }

            calculateQualityScore(metrics) {
                let score = 100;
                score -= metrics.quality.bugsCreated * 5;
                score -= metrics.quality.defectsCreated * 20;
                score += metrics.quality.bugsResolved * 3;
                score += metrics.quality.testCasesCreated * 2;
                score += metrics.quality.testCasesExecuted * 1;
                return Math.max(0, Math.min(100, Math.round(score)));
            }

            addRawDataSheets(wb) {
                // Raw work items data
                const workItemsData = [
                    ['ID', 'Title', 'Work Item Type', 'State', 'Assigned To', 'Story Points', 'Priority', 'Created Date', 'Changed Date', 'Area Path', 'Iteration Path', 'Tags']
                ];

                this.currentData.workItems.forEach(item => {
                    workItemsData.push([
                        item.id,
                        item.fields['System.Title'] || '',
                        item.fields['System.WorkItemType'],
                        item.fields['System.State'],
                        item.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0,
                        item.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        new Date(item.fields['System.CreatedDate']).toLocaleDateString(),
                        new Date(item.fields['System.ChangedDate']).toLocaleDateString(),
                        item.fields['System.AreaPath'] || '',
                        item.fields['System.IterationPath'] || '',
                        item.fields['System.Tags'] || ''
                    ]);
                });

                const wsWorkItems = XLSX.utils.aoa_to_sheet(workItemsData);
                wsWorkItems['!cols'] = [
                    { wch: 10 }, { wch: 60 }, { wch: 15 }, { wch: 12 }, { wch: 20 },
                    { wch: 12 }, { wch: 10 }, { wch: 12 }, { wch: 12 }, { wch: 30 }, { wch: 30 }, { wch: 40 }
                ];

                XLSX.utils.book_append_sheet(wb, wsWorkItems, 'Raw Work Items');
            }

            async exportToCSV() {
                try {
                    this.showLoading(true, 'Generating CSV export...');

                    let csv = 'Category,Metric,Value,Target,Status\n';

                    // Executive metrics
                    const healthScore = this.calculateProjectHealthScore();
                    csv += `Executive,Overall Health,${healthScore.overall}%,85%,${this.getHealthScoreLabel(healthScore.overall)}\n`;
                    csv += `Executive,Delivery Health,${healthScore.delivery}%,80%,${this.getHealthScoreLabel(healthScore.delivery)}\n`;
                    csv += `Executive,Quality Health,${healthScore.quality}%,90%,${this.getHealthScoreLabel(healthScore.quality)}\n`;
                    csv += `Executive,Testing Health,${healthScore.testing}%,85%,${this.getHealthScoreLabel(healthScore.testing)}\n`;

                    // Delivery metrics
                    csv += `Delivery,Total Stories,${this.metrics.delivery?.totalStories || 0},-,-\n`;
                    csv += `Delivery,Completed Stories,${this.metrics.delivery?.completedStories || 0},-,-\n`;
                    csv += `Delivery,Story Completion Rate,${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%,80%,${this.metrics.delivery?.completionRate >= 80 ? 'Good' : 'Needs Improvement'}\n`;
                    csv += `Delivery,Story Points Delivered,${this.metrics.delivery?.velocity || 0},-,-\n`;
                    csv += `Delivery,Blocked Items,${this.metrics.delivery?.blockedItems || 0},0,${this.metrics.delivery?.blockedItems === 0 ? 'Good' : 'Action Required'}\n`;

                    // Quality metrics
                    csv += `Quality,Total Bugs,${this.metrics.quality?.totalBugs || 0},-,-\n`;
                    csv += `Quality,Production Defects,${this.metrics.quality?.totalDefects || 0},0,${this.metrics.quality?.totalDefects === 0 ? 'Excellent' : 'Critical'}\n`;
                    csv += `Quality,Critical Issues,${this.metrics.quality?.criticalBugs || 0},0,${this.metrics.quality?.criticalBugs === 0 ? 'Good' : 'Urgent'}\n`;
                    csv += `Quality,Defect Escape Rate,${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%,<5%,${this.metrics.quality?.defectEscapeRate < 5 ? 'Good' : 'Needs Improvement'}\n`;

                    // Testing metrics
                    csv += `Testing,Total Test Cases,${this.metrics.testing?.totalTestCases || 0},-,-\n`;
                    csv += `Testing,Automation Rate,${this.metrics.testing?.automationRate?.toFixed(1) || 0}%,70%,${this.metrics.testing?.automationRate >= 70 ? 'Good' : 'Needs Improvement'}\n`;
                    csv += `Testing,Test Coverage,${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%,80%,${this.metrics.testing?.testCoverage >= 80 ? 'Good' : 'At Risk'}\n`;
                    csv += `Testing,Pass Rate,${this.metrics.testing?.passRate?.toFixed(1) || 0}%,95%,${this.metrics.testing?.passRate >= 95 ? 'Excellent' : 'Good'}\n`;

                    // Team metrics
                    csv += `Team,Team Size,${this.metrics.team?.teamSize || 0},-,-\n`;
                    csv += `Team,Total Velocity,${this.metrics.team?.totalVelocity || 0},-,-\n`;
                    csv += `Team,Average Velocity per Person,${this.metrics.team?.averageVelocity?.toFixed(1) || 0},-,-\n`;

                    // Download CSV
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    const areaPathNames = this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join('_');
                    link.setAttribute('download', `ADO_Metrics_${areaPathNames}_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    this.showLoading(false);
                    this.showToast('CSV data exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting CSV:', error);
                    this.showLoading(false);
                    this.showToast('Error exporting CSV data', 'error');
                }
            }

            async exportToPDF() {
                try {
                    this.showLoading(true, 'Generating PDF report...');

                    // Simple fallback PDF generation using browser print
                    const printWindow = window.open('', '_blank');
                    const healthScore = this.calculateProjectHealthScore();

                    printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>ADO Metrics Report</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        .header { text-align: center; margin-bottom: 30px; }
                        .metric { margin: 10px 0; padding: 10px; border: 1px solid #ddd; }
                        .health-score { font-size: 24px; font-weight: bold; color: #94196B; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>ADO Metrics Report</h1>
                        <p>Generated: ${new Date().toLocaleString()}</p>
                        <p>Area Paths: ${this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join(', ')}</p>
                        <p>Iterations: ${this.selectedIterations.map(it => it.displayName || it.name).join(', ')}</p>
                    </div>

                    <div class="metric">
                        <h2>Project Health Score</h2>
                        <div class="health-score">${healthScore.overall}% - ${this.getHealthScoreLabel(healthScore.overall)}</div>
                    </div>

                    <table>
                        <tr><th>Health Component</th><th>Score</th><th>Status</th></tr>
                        <tr><td>Delivery Health</td><td>${healthScore.delivery}%</td><td>${this.getHealthScoreLabel(healthScore.delivery)}</td></tr>
                        <tr><td>Quality Health</td><td>${healthScore.quality}%</td><td>${this.getHealthScoreLabel(healthScore.quality)}</td></tr>
                        <tr><td>Testing Health</td><td>${healthScore.testing}%</td><td>${this.getHealthScoreLabel(healthScore.testing)}</td></tr>
                        <tr><td>Team Health</td><td>${healthScore.team}%</td><td>${this.getHealthScoreLabel(healthScore.team)}</td></tr>
                    </table>

                    <table>
                        <tr><th>Delivery Metrics</th><th>Value</th></tr>
                        <tr><td>Total Stories</td><td>${this.metrics.delivery?.totalStories || 0}</td></tr>
                        <tr><td>Completed Stories</td><td>${this.metrics.delivery?.completedStories || 0}</td></tr>
                        <tr><td>Completion Rate</td><td>${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%</td></tr>
                        <tr><td>Story Points Delivered</td><td>${this.metrics.delivery?.velocity || 0}</td></tr>
                    </table>

                    <table>
                        <tr><th>Quality Metrics</th><th>Value</th></tr>
                        <tr><td>Bugs (Lower Environment)</td><td>${this.metrics.quality?.totalBugs || 0}</td></tr>
                        <tr><td>Production Defects</td><td>${this.metrics.quality?.totalDefects || 0}</td></tr>
                        <tr><td>Critical Issues</td><td>${this.metrics.quality?.criticalBugs || 0}</td></tr>
                        <tr><td>Defect Escape Rate</td><td>${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%</td></tr>
                    </table>

                    <table>
                        <tr><th>Testing Metrics</th><th>Value</th></tr>
                        <tr><td>Total Test Cases</td><td>${this.metrics.testing?.totalTestCases || 0}</td></tr>
                        <tr><td>Automation Rate</td><td>${this.metrics.testing?.automationRate?.toFixed(1) || 0}%</td></tr>
                        <tr><td>Test Coverage</td><td>${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%</td></tr>
                        <tr><td>Pass Rate</td><td>${this.metrics.testing?.passRate?.toFixed(1) || 0}%</td></tr>
                    </table>
                </body>
                </html>
            `);

                    printWindow.document.close();
                    printWindow.focus();

                    setTimeout(() => {
                        printWindow.print();
                        printWindow.close();
                        this.showLoading(false);
                        this.showToast('PDF report generated successfully', 'success');
                    }, 1000);

                } catch (error) {
                    console.error('Error exporting PDF:', error);
                    this.showLoading(false);
                    this.showToast('Error exporting PDF report', 'error');
                }
            }

            async exportToPowerBI() {
                try {
                    this.showLoading(true, 'Generating PowerBI template...');

                    const powerBIData = {
                        metadata: {
                            exportDate: new Date().toISOString(),
                            version: '2.0',
                            dataSource: 'ADO Metrics Dashboard Enhanced',
                            areaPaths: this.selectedAreaPaths.map(ap => ap.displayName || ap.name),
                            iterations: this.selectedIterations.map(it => it.displayName || it.name),
                            organization: this.config.organization,
                            project: this.config.project,
                            testPlan: this.selectedTestPlan,
                            teamMemberFilter: this.selectedTeamMember
                        },
                        executiveSummary: this.calculateProjectHealthScore(),
                        deliveryMetrics: this.metrics.delivery,
                        qualityMetrics: this.metrics.quality,
                        testingMetrics: this.metrics.testing,
                        teamMetrics: {
                            teamSize: this.metrics.team?.teamSize || 0,
                            totalVelocity: this.metrics.team?.totalVelocity || 0,
                            averageVelocity: this.metrics.team?.averageVelocity || 0
                        },
                        workItems: this.currentData.workItems.map(item => ({
                            id: item.id,
                            title: item.fields['System.Title'],
                            workItemType: item.fields['System.WorkItemType'],
                            state: item.fields['System.State'],
                            assignedTo: item.fields['System.AssignedTo']?.displayName,
                            storyPoints: item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0,
                            priority: item.fields['Microsoft.VSTS.Common.Priority'] || 3,
                            severity: item.fields['Microsoft.VSTS.Common.Severity'] || '',
                            createdDate: item.fields['System.CreatedDate'],
                            changedDate: item.fields['System.ChangedDate'],
                            areaPath: item.fields['System.AreaPath'],
                            iterationPath: item.fields['System.IterationPath'],
                            tags: item.fields['System.Tags'] || ''
                        })),
                        testCases: this.currentData.testCases.map(tc => ({
                            id: tc.id,
                            title: tc.fields['System.Title'],
                            state: tc.fields['System.State'],
                            assignedTo: tc.fields['System.AssignedTo']?.displayName,
                            automationStatus: this.getTestCaseAutomationStatus(tc),
                            categories: this.getTestCaseCategories(tc),
                            suiteName: tc.suiteName || 'General',
                            testPlanId: tc.testPlanId,
                            createdDate: tc.fields['System.CreatedDate'],
                            tags: tc.fields['System.Tags'] || ''
                        })),
                        releases: Array.from(this.currentData.releases.entries()).map(([name, release]) => ({
                            name: name,
                            date: release.date,
                            workItemCount: release.workItems.length,
                            userStoriesCount: release.userStories.length,
                            featuresCount: release.features.length,
                            bugsCount: release.bugs.length,
                            tasksCount: release.tasks.length
                        })),
                        suiteMetrics: Array.from(this.metrics.testing.suiteMetrics.entries()).map(([suiteName, metrics]) => ({
                            suiteName: suiteName,
                            totalTestCases: metrics.total,
                            automatedTests: metrics.automated,
                            manualTests: metrics.manual,
                            executedTests: metrics.executed,
                            passedTests: metrics.passed,
                            failedTests: metrics.failed,
                            blockedTests: metrics.blocked,
                            automationRate: metrics.total > 0 ? (metrics.automated / metrics.total) * 100 : 0,
                            passRate: metrics.executed > 0 ? (metrics.passed / metrics.executed) * 100 : 0
                        })),
                        iterationMetrics: Array.from(this.metrics.testing.iterationTestMetrics.entries()).map(([iterationName, metrics]) => ({
                            iterationName: iterationName,
                            totalStories: metrics.totalStories,
                            storiesWithCoverage: metrics.coverageStories,
                            testCases: metrics.testCases,
                            automatedTests: metrics.automatedTests,
                            manualTests: metrics.manualTests,
                            executedTests: metrics.executedTests,
                            passedTests: metrics.passedTests,
                            failedTests: metrics.failedTests,
                            coverageRate: metrics.totalStories > 0 ? (metrics.coverageStories / metrics.totalStories) * 100 : 0,
                            automationRate: metrics.testCases > 0 ? (metrics.automatedTests / metrics.testCases) * 100 : 0,
                            passRate: metrics.executedTests > 0 ? (metrics.passedTests / metrics.executedTests) * 100 : 0
                        })),
                        individualMetrics: this.metrics.individualDetailed ? Array.from(this.metrics.individualDetailed.entries()).map(([name, metrics], index) => ({
                            memberId: `Member_${index + 1}`, // Anonymized
                            workItemsAssigned: metrics.workItems.assigned,
                            workItemsCompleted: metrics.workItems.completed,
                            workItemsInProgress: metrics.workItems.inProgress,
                            storyPointsAssigned: metrics.storyPoints.assigned,
                            storyPointsCompleted: metrics.storyPoints.completed,
                            userStories: metrics.workTypes.stories,
                            features: metrics.workTypes.features,
                            tasks: metrics.workTypes.tasks,
                            bugs: metrics.workTypes.bugs,
                            testCases: metrics.workTypes.testCases,
                            bugsCreated: metrics.quality.bugsCreated,
                            bugsResolved: metrics.quality.bugsResolved,
                            defectsCreated: metrics.quality.defectsCreated,
                            testCasesCreated: metrics.quality.testCasesCreated,
                            testCasesExecuted: metrics.quality.testCasesExecuted,
                            qualityScore: this.calculateQualityScore(metrics),
                            completionRate: metrics.workItems.assigned > 0 ? (metrics.workItems.completed / metrics.workItems.assigned) * 100 : 0
                        })) : [],
                        environmentMetrics: {
                            dev: this.metrics.quality.bugsByEnvironment.dev || 0,
                            qa: this.metrics.quality.bugsByEnvironment.qa || 0,
                            uat: this.metrics.quality.bugsByEnvironment.uat || 0,
                            prod: this.metrics.quality.bugsByEnvironment.prod || 0
                        },
                        severityMetrics: this.metrics.quality.bugsBySeverity,
                        priorityMetrics: this.metrics.quality.bugsByPriority,
                        relationships: [
                            { from: 'workItems', to: 'deliveryMetrics', type: 'one-to-many', description: 'Work items contribute to delivery metrics' },
                            { from: 'workItems', to: 'qualityMetrics', type: 'one-to-many', description: 'Bugs and defects from work items' },
                            { from: 'testCases', to: 'testingMetrics', type: 'one-to-many', description: 'Test cases contribute to testing metrics' },
                            { from: 'individualMetrics', to: 'teamMetrics', type: 'many-to-one', description: 'Individual contributions to team performance' },
                            { from: 'suiteMetrics', to: 'testingMetrics', type: 'many-to-one', description: 'Suite metrics roll up to overall testing' },
                            { from: 'iterationMetrics', to: 'deliveryMetrics', type: 'many-to-one', description: 'Iteration metrics contribute to delivery' }
                        ],
                        powerBIConfiguration: {
                            recommendedVisualizations: [
                                {
                                    type: 'Card',
                                    title: 'Project Health Score',
                                    field: 'executiveSummary.overall',
                                    format: 'percentage'
                                },
                                {
                                    type: 'Donut Chart',
                                    title: 'Work Item Distribution by Type',
                                    categoryField: 'workItems.workItemType',
                                    valueField: 'count'
                                },
                                {
                                    type: 'Column Chart',
                                    title: 'Delivery Progress by Iteration',
                                    xAxis: 'iterationMetrics.iterationName',
                                    yAxis: 'iterationMetrics.coverageRate'
                                },
                                {
                                    type: 'Line Chart',
                                    title: 'Quality Trend',
                                    xAxis: 'Date',
                                    yAxis: 'Bug Count'
                                },
                                {
                                    type: 'Stacked Bar Chart',
                                    title: 'Test Automation by Suite',
                                    categoryField: 'suiteMetrics.suiteName',
                                    values: ['automatedTests', 'manualTests']
                                },
                                {
                                    type: 'Scatter Plot',
                                    title: 'Individual Performance Matrix',
                                    xAxis: 'individualMetrics.storyPointsCompleted',
                                    yAxis: 'individualMetrics.qualityScore',
                                    size: 'individualMetrics.workItemsCompleted'
                                },
                                {
                                    type: 'Matrix',
                                    title: 'Team Performance Overview',
                                    rows: 'individualMetrics.memberId',
                                    columns: ['userStories', 'features', 'tasks', 'testCases'],
                                    values: 'count'
                                },
                                {
                                    type: 'Waterfall Chart',
                                    title: 'Bug Distribution by Environment',
                                    categories: ['Dev', 'QA', 'UAT', 'Prod'],
                                    values: 'environmentMetrics'
                                }
                            ],
                            kpiTargets: {
                                storyCompletionRate: 80,
                                testAutomationRate: 70,
                                testCoverage: 80,
                                testPassRate: 95,
                                defectEscapeRate: 5,
                                bugDensity: 0.1
                            },
                            colorScheme: {
                                primary: '#94196B',
                                secondary: '#B64B8C',
                                success: '#28a745',
                                warning: '#ffc107',
                                danger: '#dc3545',
                                info: '#17a2b8'
                            }
                        }
                    };

                    // Download as JSON for PowerBI import
                    const blob = new Blob([JSON.stringify(powerBIData, null, 2)], { type: 'application/json' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const areaPathNames = this.selectedAreaPaths.map(ap => ap.displayName || ap.name).join('_');
                    a.download = `ADO_PowerBI_Data_${areaPathNames}_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    window.URL.revokeObjectURL(url);

                    this.showLoading(false);
                    this.showToast('PowerBI data template exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting PowerBI data:', error);
                    this.showLoading(false);
                    this.showToast('Error exporting PowerBI template', 'error');
                }
            }
        }

        // Initialize dashboard when DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            window.dashboard = new ADOMetricsDashboard();
        });

        // Production-ready error handling
        window.addEventListener('unhandledrejection', function (event) {
            console.error('Unhandled promise rejection:', event.reason);
            if (window.dashboard) {
                window.dashboard.showToast('An unexpected error occurred. Please try refreshing the page.', 'error');
            }
        });

        window.addEventListener('error', function (event) {
            console.error('Global error:', event.error);
            if (window.dashboard) {
                window.dashboard.showToast('An error occurred. Please check the console for details.', 'error');
            }
        });

        // Performance monitoring
        if ('performance' in window) {
            window.addEventListener('load', function () {
                setTimeout(function () {
                    const perfData = performance.getEntriesByType('navigation')[0];
                    console.log('Page Load Performance:', {
                        domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
                        loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
                        totalTime: perfData.loadEventEnd - perfData.fetchStart
                    });
                }, 0);
            });
        }

        // Auto-save configuration periodically
        setInterval(function () {
            if (window.dashboard && window.dashboard.config) {
                window.dashboard.saveConfiguration();
            }
        }, 300000); // Save every 5 minutes

        // Network status monitoring
        window.addEventListener('online', function () {
            if (window.dashboard) {
                window.dashboard.updateConnectionStatus('connected', 'Network connection restored');
            }
        });

        window.addEventListener('offline', function () {
            if (window.dashboard) {
                window.dashboard.updateConnectionStatus('disconnected', 'Network connection lost');
            }
        });

        // Advanced Data Validation Class
        class DataValidator {
            static validateWorkItem(item) {
                const errors = [];

                if (!item || typeof item !== 'object') {
                    errors.push('Work item must be an object');
                    return errors;
                }

                if (!item.id || typeof item.id !== 'number') {
                    errors.push('Work item must have a valid numeric ID');
                }

                if (!item.fields || typeof item.fields !== 'object') {
                    errors.push('Work item must have a fields object');
                    return errors;
                }

                const requiredFields = [
                    'System.Title',
                    'System.WorkItemType',
                    'System.State',
                    'System.CreatedDate'
                ];

                requiredFields.forEach(field => {
                    if (!item.fields[field]) {
                        errors.push(`Missing required field: ${field}`);
                    }
                });

                // Validate dates
                const dateFields = ['System.CreatedDate', 'System.ChangedDate'];
                dateFields.forEach(field => {
                    if (item.fields[field] && !this.isValidDate(item.fields[field])) {
                        errors.push(`Invalid date format for field: ${field}`);
                    }
                });

                // Validate story points
                if (item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] !== undefined) {
                    const points = item.fields['Microsoft.VSTS.Scheduling.StoryPoints'];
                    if (typeof points !== 'number' || points < 0 || points > 1000) {
                        errors.push('Story points must be a valid number between 0 and 1000');
                    }
                }

                return errors;
            }

            static validateTestCase(testCase) {
                const errors = [];

                if (!testCase || typeof testCase !== 'object') {
                    errors.push('Test case must be an object');
                    return errors;
                }

                if (!testCase.id) {
                    errors.push('Test case must have an ID');
                }

                return errors;
            }

            static validateConfiguration(config) {
                const errors = [];

                if (!config.organization || typeof config.organization !== 'string') {
                    errors.push('Organization is required and must be a string');
                }

                if (!config.project || typeof config.project !== 'string') {
                    errors.push('Project is required and must be a string');
                }

                if (!config.pat || typeof config.pat !== 'string') {
                    errors.push('Personal Access Token is required');
                }

                // Validate PAT format (basic check)
                if (config.pat && !/^[a-zA-Z0-9]{52}$/.test(config.pat)) {
                    errors.push('Personal Access Token appears to be in an invalid format');
                }

                return errors;
            }

            static isValidDate(dateString) {
                const date = new Date(dateString);
                return date instanceof Date && !isNaN(date.getTime());
            }

            static sanitizeString(str) {
                if (typeof str !== 'string') return '';
                return str.replace(/<[^>]*>/g, '').trim();
            }
        }

        // Advanced Caching System
        class ADODataCache {
            constructor() {
                this.cache = new Map();
                this.ttl = 5 * 60 * 1000; // 5 minutes TTL
                this.maxSize = 100; // Maximum cache entries
            }

            set(key, data) {
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now()
                });
            }

            get(key) {
                const entry = this.cache.get(key);
                if (!entry) return null;

                if (Date.now() - entry.timestamp > this.ttl) {
                    this.cache.delete(key);
                    return null;
                }

                return entry.data;
            }

            clear() {
                this.cache.clear();
            }

            getSize() {
                return this.cache.size;
            }

            getCacheStats() {
                const now = Date.now();
                let validEntries = 0;
                let expiredEntries = 0;

                this.cache.forEach((entry) => {
                    if (now - entry.timestamp <= this.ttl) {
                        validEntries++;
                    } else {
                        expiredEntries++;
                    }
                });

                return {
                    totalEntries: this.cache.size,
                    validEntries,
                    expiredEntries,
                    hitRate: validEntries / Math.max(1, this.cache.size)
                };
            }
        }

        // Production Logger
        class ProductionLogger {
            constructor() {
                this.logs = [];
                this.maxLogs = 1000;
                this.logLevel = 'info';
            }

            log(level, message, data = null) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level: level,
                    message: message,
                    data: data,
                    url: window.location.href,
                    userAgent: navigator.userAgent
                };

                this.logs.push(logEntry);

                if (this.logs.length > this.maxLogs) {
                    this.logs = this.logs.slice(-this.maxLogs);
                }

                const levels = { error: 0, warn: 1, info: 2, debug: 3 };
                const currentLevel = levels[this.logLevel] || 2;

                if (levels[level] <= currentLevel) {
                    const consoleMethod = console[level] || console.log;
                    consoleMethod(`[${logEntry.timestamp}] ${message}`, data || '');
                }

                if (level === 'error') {
                    try {
                        const storedErrors = JSON.parse(localStorage.getItem('adoErrors') || '[]');
                        storedErrors.push(logEntry);
                        localStorage.setItem('adoErrors', JSON.stringify(storedErrors.slice(-100)));
                    } catch (e) {
                        console.warn('Could not store error log:', e);
                    }
                }
            }

            error(message, data) { this.log('error', message, data); }
            warn(message, data) { this.log('warn', message, data); }
            info(message, data) { this.log('info', message, data); }
            debug(message, data) { this.log('debug', message, data); }

            getLogs(level = null) {
                if (level) {
                    return this.logs.filter(log => log.level === level);
                }
                return [...this.logs];
            }

            exportLogs() {
                const logsData = {
                    exportDate: new Date().toISOString(),
                    logs: this.logs,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                const blob = new Blob([JSON.stringify(logsData, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ado_metrics_logs_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            }

            clearLogs() {
                this.logs = [];
                localStorage.removeItem('adoErrors');
            }
        }

        // Initialize production utilities
        window.adoCache = new ADODataCache();
        window.logger = new ProductionLogger();

        // Health Check System
        class HealthCheck {
            constructor() {
                this.checks = new Map();
                this.interval = 60000; // Check every minute
                this.lastCheck = null;
                this.isRunning = false;
            }

            addCheck(name, checkFunction) {
                this.checks.set(name, {
                    name,
                    check: checkFunction,
                    lastResult: null,
                    lastRun: null
                });
            }

            async runChecks() {
                if (this.isRunning) return;
                this.isRunning = true;

                const results = new Map();
                this.lastCheck = new Date();

                try {
                    for (const [name, checkConfig] of this.checks) {
                        try {
                            const startTime = performance.now();
                            const result = await checkConfig.check();
                            const duration = performance.now() - startTime;

                            const checkResult = {
                                status: result.status || 'unknown',
                                message: result.message || '',
                                duration,
                                timestamp: new Date()
                            };

                            checkConfig.lastResult = checkResult;
                            checkConfig.lastRun = new Date();
                            results.set(name, checkResult);

                            window.logger.debug(`Health check ${name}: ${checkResult.status}`, checkResult);

                        } catch (error) {
                            const checkResult = {
                                status: 'error',
                                message: error.message,
                                duration: 0,
                                timestamp: new Date()
                            };

                            checkConfig.lastResult = checkResult;
                            checkConfig.lastRun = new Date();
                            results.set(name, checkResult);

                            window.logger.error(`Health check ${name} failed`, error);
                        }
                    }
                } finally {
                    this.isRunning = false;
                }

                return results;
            }

            getStatus() {
                const status = {
                    overall: 'healthy',
                    lastCheck: this.lastCheck,
                    checks: {}
                };

                let hasErrors = false;
                let hasWarnings = false;

                for (const [name, checkConfig] of this.checks) {
                    const result = checkConfig.lastResult;
                    status.checks[name] = result;

                    if (result?.status === 'error') {
                        hasErrors = true;
                    } else if (result?.status === 'warning') {
                        hasWarnings = true;
                    }
                }

                if (hasErrors) {
                    status.overall = 'unhealthy';
                } else if (hasWarnings) {
                    status.overall = 'degraded';
                }

                return status;
            }

            startMonitoring() {
                this.runChecks();
                setInterval(() => this.runChecks(), this.interval);
            }
        }

        // Initialize health monitoring
        window.healthCheck = new HealthCheck();

        // Add health checks
        window.healthCheck.addCheck('browser-storage', async () => {
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                return { status: 'healthy', message: 'LocalStorage working' };
            } catch (error) {
                return { status: 'error', message: 'LocalStorage not available' };
            }
        });

        window.healthCheck.addCheck('memory-usage', async () => {
            if ('memory' in performance) {
                const memory = performance.memory;
                const usagePercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;

                if (usagePercent > 90) {
                    return { status: 'error', message: `High memory usage: ${usagePercent.toFixed(1)}%` };
                } else if (usagePercent > 70) {
                    return { status: 'warning', message: `Elevated memory usage: ${usagePercent.toFixed(1)}%` };
                } else {
                    return { status: 'healthy', message: `Memory usage: ${usagePercent.toFixed(1)}%` };
                }
            }
            return { status: 'healthy', message: 'Memory monitoring not available' };
        });

        // Start health monitoring in production
        if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            window.healthCheck.startMonitoring();
        }

        // Analytics Collector (anonymized)
        class AnalyticsCollector {
            constructor() {
                this.events = [];
                this.sessionId = this.generateSessionId();
                this.startTime = Date.now();
            }

            generateSessionId() {
                return 'sess_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            track(event, properties = {}) {
                const analyticsEvent = {
                    sessionId: this.sessionId,
                    event,
                    properties: {
                        ...properties,
                        timestamp: Date.now(),
                        url: window.location.pathname,
                        userAgent: navigator.userAgent,
                        screenResolution: `${screen.width}x${screen.height}`,
                        viewportSize: `${window.innerWidth}x${window.innerHeight}`
                    }
                };

                this.events.push(analyticsEvent);
                window.logger.debug('Analytics event tracked', analyticsEvent);

                if (this.events.length > 1000) {
                    this.events = this.events.slice(-1000);
                }
            }

            getSessionSummary() {
                const now = Date.now();
                const sessionDuration = now - this.startTime;

                const eventCounts = {};
                this.events.forEach(event => {
                    eventCounts[event.event] = (eventCounts[event.event] || 0) + 1;
                });

                return {
                    sessionId: this.sessionId,
                    duration: sessionDuration,
                    eventCounts,
                    totalEvents: this.events.length,
                    startTime: this.startTime,
                    endTime: now
                };
            }

            exportAnalytics() {
                const data = {
                    session: this.getSessionSummary(),
                    events: this.events,
                    browser: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        platform: navigator.platform,
                        cookieEnabled: navigator.cookieEnabled
                    },
                    performance: 'performance' in window ? {
                        memory: performance.memory,
                        navigation: performance.getEntriesByType('navigation')[0]
                    } : null
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ado_analytics_${this.sessionId}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            }
        }

        // Initialize analytics in production
        if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            window.analytics = new AnalyticsCollector();

            // Track page views
            window.analytics.track('page_view', {
                page: 'dashboard',
                referrer: document.referrer
            });

            // Track user interactions
            document.addEventListener('click', function (e) {
                if (e.target.closest('button, a, .nav-link')) {
                    window.analytics.track('user_interaction', {
                        element: e.target.tagName.toLowerCase(),
                        className: e.target.className,
                        text: e.target.textContent?.slice(0, 50)
                    });
                }
            });
        }

        // Final cleanup on page unload
        window.addEventListener('beforeunload', function () {
            if (window.dashboard) {
                window.dashboard.saveConfiguration();
            }

            if (window.analytics) {
                window.analytics.track('session_end');
            }

            window.logger.info('ADO Metrics Dashboard session ended');
        });

        // Export global utilities for debugging in development
        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
            window.ADOMetricsDebug = {
                cache: window.adoCache,
                logger: window.logger,
                healthCheck: window.healthCheck,
                analytics: window.analytics,
                DataValidator,
                clearAllData: function () {
                    localStorage.clear();
                    window.adoCache.clear();
                    window.logger.clearLogs();
                    location.reload();
                },
                exportLogs: function () {
                    window.logger.exportLogs();
                },
                exportAnalytics: function () {
                    if (window.analytics) {
                        window.analytics.exportAnalytics();
                    }
                },
                getHealthStatus: function () {
                    return window.healthCheck.getStatus();
                },
                getCacheStats: function () {
                    return window.adoCache.getCacheStats();
                }
            };
        }

        // Final production validation
        document.addEventListener('DOMContentLoaded', function () {
            // Validate browser compatibility
            const requiredFeatures = [
                'fetch',
                'Promise',
                'Map',
                'Set',
                'localStorage',
                'JSON'
            ];

            const missingFeatures = requiredFeatures.filter(feature => !(feature in window));

            if (missingFeatures.length > 0) {
                document.body.innerHTML = `
            <div style="padding: 2rem; text-align: center; font-family: Arial, sans-serif;">
                <h2 style="color: #dc3545;">Browser Not Supported</h2>
                <p>Your browser is missing required features: ${missingFeatures.join(', ')}</p>
                <p>Please update your browser or use a modern browser like Chrome, Firefox, or Edge.</p>
            </div>
        `;
                return;
            }

            // Initialize dashboard
            if (!window.dashboard) {
                window.dashboard = new ADOMetricsDashboard();
            }

            // Set up production monitoring
            if (window.analytics) {
                window.analytics.track('dashboard_initialized');
            }

            window.logger.info('ADO Metrics Dashboard initialized successfully');
        });
    </script>
</body>

</html>