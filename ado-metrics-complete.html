<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADO Metrics Command Center</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/dataTables.bootstrap5.min.css">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        :root {
            --primary-color: #94196B;
            --primary-light: #B64B8C;
            --primary-dark: #6B1050;
            --primary-ultra-light: #F8E8F3;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --light-bg: #f8f9fa;
            --white-bg: #ffffff;
            --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--light-bg);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 280px;
            background: var(--white-bg);
            padding: 2rem 1.5rem;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-brand h1 {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--primary-color);
            margin: 0;
            margin-left: 1rem;
        }

        .nav-menu {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 1rem 1.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 12px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .nav-link:hover {
            color: var(--primary-color);
            background: var(--primary-ultra-light);
            transform: translateX(5px);
        }

        .nav-link.active {
            color: var(--white-bg);
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
            box-shadow: 0 4px 15px rgba(148, 25, 107, 0.3);
        }

        .nav-link i {
            width: 24px;
            margin-right: 1rem;
            font-size: 1.1rem;
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            padding: 2rem;
            min-height: 100vh;
            background-color: var(--light-bg);
        }

        /* Header */
        .page-header {
            background: var(--white-bg);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }

        .page-header::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, var(--primary-ultra-light) 0%, transparent 70%);
            transform: translate(50%, -50%);
        }

        .page-title {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        /* Configuration Panel */
        .config-panel {
            background: var(--white-bg);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
        }

        .form-label {
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .form-control, .form-select {
            background: var(--light-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 10px;
            padding: 0.75rem 1rem;
            transition: all 0.3s ease;
        }

        .form-control:focus, .form-select:focus {
            background: var(--white-bg);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.25rem rgba(148, 25, 107, 0.25);
            color: var(--text-primary);
        }

        /* Multi-select for boards */
        .board-selection-container {
            position: relative;
        }

        .board-selection-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--white-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-top: 5px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: var(--card-shadow);
        }

        .board-selection-dropdown.show {
            display: block;
        }

        .board-option {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .board-option:hover {
            background: var(--primary-ultra-light);
        }

        .board-option input[type="checkbox"] {
            margin-right: 0.5rem;
        }

        .selected-boards {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .selected-board-chip {
            background: var(--primary-ultra-light);
            color: var(--primary-color);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .selected-board-chip i {
            cursor: pointer;
        }

        /* Metric Cards */
        .metric-card {
            background: var(--white-bg);
            border-radius: 20px;
            padding: 2rem;
            height: 100%;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(148, 25, 107, 0.15);
        }

        .metric-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-color), var(--primary-light));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }

        .metric-card:hover::before {
            transform: scaleX(1);
        }

        .metric-icon {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            background: var(--primary-ultra-light);
            color: var(--primary-color);
        }

        .metric-value {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .metric-label {
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-trend {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .trend-up {
            color: var(--success-color);
        }

        .trend-down {
            color: var(--danger-color);
        }

        /* Progress Bars */
        .progress {
            height: 8px;
            background: var(--light-bg);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 1rem;
        }

        .progress-bar {
            background: linear-gradient(90deg, var(--primary-color), var(--primary-light));
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            transition: width 0.6s ease;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Tables */
        .data-table-container {
            background: var(--white-bg);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            overflow-x: auto;
        }

        .table {
            color: var(--text-primary);
        }

        .table thead th {
            background: var(--primary-ultra-light);
            color: var(--primary-color);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 1px;
            border: none;
            padding: 1rem;
        }

        .table tbody tr {
            transition: all 0.3s ease;
        }

        .table tbody tr:hover {
            background: var(--light-bg);
            transform: scale(1.01);
        }

        .table tbody td {
            padding: 1rem;
            border-color: var(--border-color);
            vertical-align: middle;
        }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-new {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .status-active {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .status-resolved {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .status-closed {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
        }

        /* Buttons */
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
            border: none;
            border-radius: 10px;
            padding: 0.75rem 2rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(148, 25, 107, 0.3);
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
        }

        /* Loading Spinner */
        .loading-spinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 20px;
            box-shadow: var(--card-shadow);
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--primary-ultra-light);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Health Score Visual */
        .health-score-container {
            text-align: center;
            padding: 2rem;
        }

        .health-score-circle {
            width: 150px;
            height: 150px;
            margin: 0 auto 1rem;
            position: relative;
        }

        .health-score-svg {
            transform: rotate(-90deg);
        }

        .health-score-bg {
            fill: none;
            stroke: var(--light-bg);
            stroke-width: 10;
        }

        .health-score-progress {
            fill: none;
            stroke: url(#health-gradient);
            stroke-width: 10;
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease;
        }

        .health-score-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--primary-color);
        }

        .health-label {
            font-size: 1.2rem;
            font-weight: 600;
            margin-top: 1rem;
            color: var(--text-secondary);
        }

        /* AI Insights Section */
        .ai-insights {
            background: linear-gradient(135deg, var(--primary-ultra-light), var(--white-bg));
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }

        .ai-badge {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 30px;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .ai-badge i {
            margin-right: 0.5rem;
        }

        /* Chart Container Fix */
        .chart-container {
            position: relative;
            height: 300px;
            max-height: 300px;
            margin-top: 1rem;
        }

        /* Timeline Chart Fix */
        .timeline-chart-container {
            position: relative;
            height: 400px;
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .timeline-chart-wrapper {
            min-width: 800px;
            height: 100%;
        }

        /* Export Menu */
        .export-menu {
            position: relative;
            display: inline-block;
        }

        .export-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--white-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 0.5rem 0;
            margin-top: 0.5rem;
            min-width: 200px;
            display: none;
            z-index: 100;
            box-shadow: var(--card-shadow);
        }

        .export-dropdown.show {
            display: block;
        }

        .export-option {
            display: flex;
            align-items: center;
            padding: 0.75rem 1.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .export-option:hover {
            background: var(--primary-ultra-light);
            color: var(--primary-color);
        }

        .export-option i {
            margin-right: 0.75rem;
            width: 20px;
        }

        /* Test Tags */
        .test-tag {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            margin: 0.1rem;
            border-radius: 15px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .test-tag.manual {
            background: #e3f2fd;
            color: #1976d2;
        }

        .test-tag.automated {
            background: #e8f5e9;
            color: #388e3c;
        }

        .test-tag.regression {
            background: #fff3e0;
            color: #f57c00;
        }

        .test-tag.smoke {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .test-tag.e2e {
            background: #fce4ec;
            color: #c2185b;
        }

        /* Environment Badge */
        .env-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .env-badge.production {
            background: #ffebee;
            color: #c62828;
        }

        .env-badge.uat {
            background: #fff8e1;
            color: #f57f17;
        }

        .env-badge.qa {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .env-badge.dev {
            background: #e3f2fd;
            color: #1565c0;
        }

        /* Section Headers */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 9999;
        }

        .toast {
            background: var(--white-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 12px;
            margin-bottom: 1rem;
            box-shadow: var(--card-shadow);
        }

        .toast-header {
            background: transparent;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .toast-body {
            padding: 1rem;
        }

        /* Mobile Responsive */
        .mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1001;
            background: var(--white-bg);
            border: 1px solid var(--border-color);
            color: var(--primary-color);
            border-radius: 10px;
            padding: 0.75rem;
            cursor: pointer;
            box-shadow: var(--card-shadow);
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .mobile-menu-toggle {
                display: block;
            }

            .page-title {
                font-size: 1.8rem;
            }

            .metric-value {
                font-size: 2rem;
            }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--light-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-light);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* Priority Indicator */
        .priority-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5rem;
        }

        .priority-1 {
            background-color: var(--danger-color);
        }

        .priority-2 {
            background-color: var(--warning-color);
        }

        .priority-3 {
            background-color: var(--info-color);
        }

        .priority-4 {
            background-color: var(--success-color);
        }

        /* Severity Badge */
        .severity-badge {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-weight: 600;
        }

        .severity-critical {
            background: #ffebee;
            color: #b71c1c;
        }

        .severity-high {
            background: #fff3e0;
            color: #e65100;
        }

        .severity-medium {
            background: #fff8e1;
            color: #f57f17;
        }

        .severity-low {
            background: #e8f5e9;
            color: #1b5e20;
        }

        /* Sprint Burndown */
        .burndown-container {
            position: relative;
            height: 350px;
            margin-top: 1rem;
        }

        /* Velocity Chart */
        .velocity-chart-container {
            position: relative;
            height: 300px;
            margin-top: 1rem;
        }

        /* Skill Matrix */
        .skill-matrix {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .skill-badge {
            background: var(--light-bg);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .skill-badge:hover {
            background: var(--primary-ultra-light);
            transform: translateY(-2px);
        }

        .skill-level {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .skill-name {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loadingSpinner">
        <div class="spinner"></div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" id="mobileMenuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Sidebar Navigation -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-brand">
            <i class="fas fa-chart-line fa-2x" style="color: var(--primary-color);"></i>
            <h1>ADO Metrics</h1>
        </div>
        
        <nav>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="#" class="nav-link active" data-page="dashboard">
                        <i class="fas fa-tachometer-alt"></i>
                        <span>Dashboard</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="sprint">
                        <i class="fas fa-sync-alt"></i>
                        <span>Sprint Analytics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="delivery">
                        <i class="fas fa-tasks"></i>
                        <span>Delivery Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="quality">
                        <i class="fas fa-bug"></i>
                        <span>Quality Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="testing">
                        <i class="fas fa-vial"></i>
                        <span>Testing Analytics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="team">
                        <i class="fas fa-users"></i>
                        <span>Team Performance</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="individual">
                        <i class="fas fa-user-chart"></i>
                        <span>Individual Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="ai-insights">
                        <i class="fas fa-brain"></i>
                        <span>AI Insights</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="reports">
                        <i class="fas fa-file-alt"></i>
                        <span>Reports</span>
                    </a>
                </li>
                <li class="nav-item mt-4 pt-4 border-top">
                    <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#settingsModal">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Page Header -->
        <div class="page-header">
            <div class="row align-items-center">
                <div class="col-md-6">
                    <h1 class="page-title">ADO Metrics Command Center</h1>
                    <p class="text-secondary mb-0">Comprehensive project analytics and insights</p>
                </div>
                <div class="col-md-6 text-end">
                    <div class="export-menu">
                        <button class="btn btn-primary" id="exportButton">
                            <i class="fas fa-download me-2"></i>Export
                        </button>
                        <div class="export-dropdown" id="exportDropdown">
                            <a href="#" class="export-option" data-export="excel">
                                <i class="fas fa-file-excel"></i>Excel Report
                            </a>
                            <a href="#" class="export-option" data-export="pdf">
                                <i class="fas fa-file-pdf"></i>PDF Dashboard
                            </a>
                            <a href="#" class="export-option" data-export="csv">
                                <i class="fas fa-file-csv"></i>CSV Data
                            </a>
                            <a href="#" class="export-option" data-export="powerbi">
                                <i class="fas fa-chart-bar"></i>PowerBI Template
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Configuration Panel -->
        <div class="config-panel">
            <div class="row g-3">
                <div class="col-md-4">
                    <label class="form-label">Board Selection (Max 3)</label>
                    <div class="board-selection-container">
                        <input type="text" class="form-control" id="boardSearchInput" 
                               placeholder="Click to select boards..." readonly>
                        <div class="board-selection-dropdown" id="boardDropdown">
                            <!-- Board options will be populated here -->
                        </div>
                        <div class="selected-boards" id="selectedBoards"></div>
                    </div>
                </div>
                <div class="col-md-4">
                    <label class="form-label">Filter Type</label>
                    <select class="form-select" id="filterType">
                        <option value="iteration">Iteration Based</option>
                        <option value="dateRange">Date Range Based</option>
                    </select>
                </div>
                <div class="col-md-4" id="filterOptions">
                    <label class="form-label">Iteration</label>
                    <select class="form-select" id="iterationSelect">
                        <option value="@currentIteration">Current Iteration</option>
                    </select>
                </div>
                <div class="col-12 mt-3">
                    <button class="btn btn-primary" id="loadDataButton">
                        <i class="fas fa-sync-alt me-2"></i>Load Data
                    </button>
                </div>
            </div>
        </div>

        <!-- Dashboard Content -->
        <div id="dashboardContent">
            <!-- Content will be dynamically loaded here -->
        </div>
    </main>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Configuration Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <h6 class="mb-3">ADO Connection</h6>
                    <div class="row g-3 mb-4">
                        <div class="col-md-6">
                            <label class="form-label">Organization</label>
                            <input type="text" class="form-control" id="adoOrganization" placeholder="your-organization">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Project</label>
                            <input type="text" class="form-control" id="adoProject" placeholder="your-project">
                        </div>
                        <div class="col-12">
                            <label class="form-label">Personal Access Token</label>
                            <input type="password" class="form-control" id="adoPAT" placeholder="Enter your PAT">
                            <small class="text-muted">Your PAT is stored securely and never transmitted</small>
                        </div>
                    </div>

                    <h6 class="mb-3">Proxy Configuration (Optional)</h6>
                    <div class="row g-3">
                        <div class="col-md-8">
                            <label class="form-label">Proxy Server</label>
                            <input type="text" class="form-control" id="proxyServer" placeholder="proxy.company.com">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Port</label>
                            <input type="number" class="form-control" id="proxyPort" placeholder="8080">
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveSettingsButton">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.4/js/dataTables.bootstrap5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>

    <script>
        // ADO Metrics Dashboard - Complete Implementation
        class ADOMetricsDashboard {
            constructor() {
                this.config = this.loadConfiguration();
                this.selectedBoards = [];
                this.currentData = null;
                this.boards = [];
                this.iterations = [];
                this.charts = {};
                this.metrics = {
                    delivery: {},
                    sprint: {},
                    quality: {},
                    testing: {},
                    team: {},
                    individual: {},
                    process: {},
                    value: {}
                };
                this.testCategories = {
                    manual: 0,
                    automated: 0,
                    regression: 0,
                    smoke: 0,
                    e2e: 0,
                    api: 0,
                    integration: 0,
                    unit: 0
                };
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.loadSavedSettings();
                this.showDashboard();
                if (this.config.organization && this.config.project && this.config.pat) {
                    this.loadBoards();
                }
            }

            loadConfiguration() {
                const savedConfig = localStorage.getItem('adoConfig');
                return savedConfig ? JSON.parse(savedConfig) : {
                    organization: '',
                    project: '',
                    pat: '',
                    proxy: {
                        server: '',
                        port: ''
                    }
                };
            }

            saveConfiguration() {
                localStorage.setItem('adoConfig', JSON.stringify(this.config));
            }

            loadSavedSettings() {
                if (this.config.organization) {
                    document.getElementById('adoOrganization').value = this.config.organization;
                }
                if (this.config.project) {
                    document.getElementById('adoProject').value = this.config.project;
                }
                if (this.config.pat) {
                    document.getElementById('adoPAT').value = this.config.pat;
                }
                if (this.config.proxy?.server) {
                    document.getElementById('proxyServer').value = this.config.proxy.server;
                }
                if (this.config.proxy?.port) {
                    document.getElementById('proxyPort').value = this.config.proxy.port;
                }
            }

            setupEventListeners() {
                // Mobile menu toggle
                document.getElementById('mobileMenuToggle').addEventListener('click', () => {
                    document.getElementById('sidebar').classList.toggle('active');
                });

                // Navigation
                document.querySelectorAll('.nav-link[data-page]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const page = e.currentTarget.dataset.page;
                        if (page) {
                            this.navigateToPage(page);
                        }
                    });
                });

                // Board selection
                document.getElementById('boardSearchInput').addEventListener('click', () => {
                    document.getElementById('boardDropdown').classList.toggle('show');
                });

                // Filter type change
                document.getElementById('filterType').addEventListener('change', (e) => {
                    this.updateFilterOptions(e.target.value);
                });

                // Export menu
                document.getElementById('exportButton').addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.getElementById('exportDropdown').classList.toggle('show');
                });

                // Export options
                document.querySelectorAll('.export-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.preventDefault();
                        const format = e.currentTarget.dataset.export;
                        this.exportData(format);
                        document.getElementById('exportDropdown').classList.remove('show');
                    });
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.board-selection-container')) {
                        document.getElementById('boardDropdown').classList.remove('show');
                    }
                    if (!e.target.closest('.export-menu')) {
                        document.getElementById('exportDropdown').classList.remove('show');
                    }
                });

                // Load data
                document.getElementById('loadDataButton').addEventListener('click', () => {
                    this.loadData();
                });

                // Save settings
                document.getElementById('saveSettingsButton').addEventListener('click', () => {
                    this.saveSettings();
                });

                // Global error handler to prevent console spam
                window.addEventListener('error', (e) => {
                    console.error('Global error:', e.error);
                    return true;
                });
            }

            saveSettings() {
                this.config.organization = document.getElementById('adoOrganization').value;
                this.config.project = document.getElementById('adoProject').value;
                this.config.pat = document.getElementById('adoPAT').value;
                this.config.proxy = {
                    server: document.getElementById('proxyServer').value,
                    port: document.getElementById('proxyPort').value
                };
                
                this.saveConfiguration();
                this.showToast('Settings saved successfully', 'success');
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
                modal.hide();
                
                // Reload boards if settings changed
                if (this.config.organization && this.config.project && this.config.pat) {
                    this.loadBoards();
                }
            }

            updateFilterOptions(filterType) {
                const filterOptionsDiv = document.getElementById('filterOptions');
                
                if (filterType === 'iteration') {
                    filterOptionsDiv.innerHTML = `
                        <label class="form-label">Iteration</label>
                        <select class="form-select" id="iterationSelect">
                            <option value="@currentIteration">Current Iteration</option>
                        </select>
                    `;
                    this.loadIterations();
                } else {
                    filterOptionsDiv.innerHTML = `
                        <label class="form-label">Date Range</label>
                        <div class="row g-2">
                            <div class="col-6">
                                <input type="date" class="form-control" id="startDate">
                            </div>
                            <div class="col-6">
                                <input type="date" class="form-control" id="endDate">
                            </div>
                        </div>
                    `;
                    // Set default dates
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setMonth(startDate.getMonth() - 1);
                    
                    document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
                    document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
                }
            }

            async makeADORequest(endpoint, method = 'GET', body = null) {
                const baseUrl = `https://dev.azure.com/${this.config.organization}`;
                const url = endpoint.startsWith('http') ? endpoint : `${baseUrl}/${this.config.project}/_apis/${endpoint}`;
                
                const headers = {
                    'Authorization': `Basic ${btoa(`:${this.config.pat}`)}`,
                    'Content-Type': 'application/json'
                };

                try {
                    const response = await fetch(url, {
                        method,
                        headers,
                        body: body ? JSON.stringify(body) : null
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`ADO API Error: ${response.status} - ${errorText}`);
                        throw new Error(`ADO API Error: ${response.status}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error('ADO Request Error:', error);
                    throw error;
                }
            }

            async loadBoards() {
                this.showLoading(true);
                try {
                    // Try to get boards
                    try {
                        const boardsResponse = await this.makeADORequest('work/boards?api-version=7.0');
                        this.boards = boardsResponse.value || [];
                    } catch (error) {
                        console.warn('Could not load boards from API, using defaults');
                    }
                    
                    // If no boards, create defaults
                    if (this.boards.length === 0) {
                        this.boards = [
                            { id: 'Stories', name: 'Stories' },
                            { id: 'Features', name: 'Features' },
                            { id: 'Epics', name: 'Epics' },
                            { id: 'Tasks', name: 'Tasks' },
                            { id: 'Issues', name: 'Issues' }
                        ];
                    }
                    
                    this.populateBoardDropdown();
                } catch (error) {
                    console.error('Error loading boards:', error);
                    this.showToast('Error loading boards. Using default configuration.', 'warning');
                } finally {
                    this.showLoading(false);
                }
            }

            populateBoardDropdown() {
                const dropdown = document.getElementById('boardDropdown');
                dropdown.innerHTML = '';
                
                this.boards.forEach(board => {
                    const div = document.createElement('div');
                    div.className = 'board-option';
                    div.innerHTML = `
                        <input type="checkbox" id="board-${board.id}" value="${board.id}" 
                               onchange="dashboard.toggleBoardSelection('${board.id}', '${board.name}')">
                        <label for="board-${board.id}">${board.name}</label>
                    `;
                    dropdown.appendChild(div);
                });
            }

            toggleBoardSelection(boardId, boardName) {
                const index = this.selectedBoards.findIndex(b => b.id === boardId);
                
                if (index > -1) {
                    this.selectedBoards.splice(index, 1);
                } else if (this.selectedBoards.length < 3) {
                    this.selectedBoards.push({ id: boardId, name: boardName });
                } else {
                    document.getElementById(`board-${boardId}`).checked = false;
                    this.showToast('Maximum 3 boards can be selected', 'warning');
                    return;
                }
                
                this.updateSelectedBoardsDisplay();
            }

            updateSelectedBoardsDisplay() {
                const container = document.getElementById('selectedBoards');
                container.innerHTML = this.selectedBoards.map(board => `
                    <div class="selected-board-chip">
                        ${board.name}
                        <i class="fas fa-times" onclick="dashboard.removeBoardSelection('${board.id}')"></i>
                    </div>
                `).join('');
            }

            removeBoardSelection(boardId) {
                this.selectedBoards = this.selectedBoards.filter(b => b.id !== boardId);
                const checkbox = document.getElementById(`board-${boardId}`);
                if (checkbox) checkbox.checked = false;
                this.updateSelectedBoardsDisplay();
            }

            async loadIterations() {
                try {
                    const iterationsResponse = await this.makeADORequest('work/teamsettings/iterations?api-version=7.0');
                    this.iterations = iterationsResponse.value || [];
                    
                    const select = document.getElementById('iterationSelect');
                    if (select) {
                        select.innerHTML = '<option value="@currentIteration">Current Iteration</option>';
                        this.iterations.forEach(iteration => {
                            const option = document.createElement('option');
                            option.value = iteration.path || iteration.id;
                            option.textContent = iteration.name;
                            select.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('Error loading iterations:', error);
                }
            }

            async loadData() {
                if (this.selectedBoards.length === 0) {
                    this.showToast('Please select at least one board', 'warning');
                    return;
                }

                this.showLoading(true);
                try {
                    const filterType = document.getElementById('filterType').value;
                    let filter = {};
                    
                    if (filterType === 'iteration') {
                        filter.iteration = document.getElementById('iterationSelect').value;
                    } else {
                        filter.startDate = document.getElementById('startDate').value;
                        filter.endDate = document.getElementById('endDate').value;
                    }

                    // Load data for each selected board
                    const allData = await Promise.all(
                        this.selectedBoards.map(board => this.loadBoardData(board, filter))
                    );

                    // Merge data from all boards
                    this.currentData = this.mergeData(allData);
                    
                    // Calculate all metrics
                    this.calculateAllMetrics();
                    
                    // Update current page
                    const activePage = document.querySelector('.nav-link.active')?.dataset.page || 'dashboard';
                    this.navigateToPage(activePage);
                    
                    this.showToast('Data loaded successfully', 'success');
                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showToast('Error loading data. Please check your settings.', 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            async loadBoardData(board, filter) {
                try {
                    // Build WIQL query - fixed syntax
                    let whereConditions = [`[System.TeamProject] = '${this.config.project}'`];
                    
                    // Add work item type filter
                    whereConditions.push(`[System.WorkItemType] IN ('User Story', 'Bug', 'Task', 'Feature', 'Epic', 'Product Backlog Item', 'Test Case')`);

                    // Add iteration or date filter
                    if (filter.iteration) {
                        if (filter.iteration === '@currentIteration') {
                            whereConditions.push(`[System.IterationPath] UNDER @currentIteration`);
                        } else {
                            whereConditions.push(`[System.IterationPath] = '${filter.iteration}'`);
                        }
                    } else if (filter.startDate && filter.endDate) {
                        whereConditions.push(`[System.ChangedDate] >= '${filter.startDate}'`);
                        whereConditions.push(`[System.ChangedDate] <= '${filter.endDate}'`);
                    }

                    const query = `SELECT [System.Id] FROM WorkItems WHERE ${whereConditions.join(' AND ')} ORDER BY [System.ChangedDate] DESC`;

                    const wiql = { query };
                    const queryResult = await this.makeADORequest('wit/wiql?api-version=7.0', 'POST', wiql);
                    
                    if (!queryResult.workItems || queryResult.workItems.length === 0) {
                        return this.createEmptyBoardData(board);
                    }

                    // Get work item details in batches
                    const batchSize = 200;
                    const allWorkItems = [];
                    
                    for (let i = 0; i < queryResult.workItems.length; i += batchSize) {
                        const batch = queryResult.workItems.slice(i, i + batchSize);
                        const ids = batch.map(wi => wi.id).join(',');
                        
                        try {
                            const workItemsResponse = await this.makeADORequest(
                                `wit/workitems?ids=${ids}&$expand=relations&api-version=7.0`
                            );
                            allWorkItems.push(...(workItemsResponse.value || []));
                        } catch (error) {
                            console.error('Error fetching work item batch:', error);
                        }
                    }

                    // Categorize work items
                    return this.categorizeWorkItems(board, allWorkItems);
                } catch (error) {
                    console.error(`Error loading data for board ${board.name}:`, error);
                    return this.createEmptyBoardData(board);
                }
            }

            createEmptyBoardData(board) {
                return {
                    board,
                    workItems: [],
                    userStories: [],
                    features: [],
                    epics: [],
                    tasks: [],
                    bugs: [],
                    testTasks: [],
                    testCases: []
                };
            }

            categorizeWorkItems(board, workItems) {
                const data = this.createEmptyBoardData(board);
                data.workItems = workItems;

                for (const item of workItems) {
                    const type = item.fields['System.WorkItemType'];
                    const title = (item.fields['System.Title'] || '').toLowerCase();
                    
                    switch (type) {
                        case 'User Story':
                        case 'Product Backlog Item':
                            data.userStories.push(item);
                            break;
                        case 'Feature':
                            data.features.push(item);
                            break;
                        case 'Epic':
                            data.epics.push(item);
                            break;
                        case 'Task':
                            if (this.isTestingTask(title)) {
                                data.testTasks.push(item);
                            }
                            data.tasks.push(item);
                            break;
                        case 'Bug':
                            data.bugs.push(item);
                            break;
                        case 'Test Case':
                            data.testCases.push(item);
                            break;
                    }
                }

                return data;
            }

            isTestingTask(title) {
                const testingKeywords = [
                    'sit testing', 'sit-testing', 'sit_testing',
                    'uat testing', 'uat-testing', 'uat_testing',
                    'test execution', 'test case', 'testing',
                    'qa testing', 'quality assurance'
                ];
                return testingKeywords.some(keyword => title.includes(keyword));
            }

            mergeData(allBoardData) {
                const merged = {
                    boards: allBoardData.map(d => d.board),
                    workItems: [],
                    userStories: [],
                    features: [],
                    epics: [],
                    tasks: [],
                    bugs: [],
                    testTasks: [],
                    testCases: []
                };

                allBoardData.forEach(data => {
                    merged.workItems.push(...(data.workItems || []));
                    merged.userStories.push(...(data.userStories || []));
                    merged.features.push(...(data.features || []));
                    merged.epics.push(...(data.epics || []));
                    merged.tasks.push(...(data.tasks || []));
                    merged.bugs.push(...(data.bugs || []));
                    merged.testTasks.push(...(data.testTasks || []));
                    merged.testCases.push(...(data.testCases || []));
                });

                // Separate bugs into bugs (lower env) and defects (production)
                merged.defects = merged.bugs.filter(bug => this.isProductionIssue(bug));
                merged.bugs = merged.bugs.filter(bug => !this.isProductionIssue(bug));

                return merged;
            }

            isProductionIssue(bug) {
                const tags = (bug.fields['System.Tags'] || '').toLowerCase();
                const areaPath = (bug.fields['System.AreaPath'] || '').toLowerCase();
                const title = (bug.fields['System.Title'] || '').toLowerCase();
                
                return tags.includes('production') || tags.includes('prod') || 
                       areaPath.includes('production') || areaPath.includes('prod') ||
                       title.includes('production') || title.includes('prod');
            }

            calculateAllMetrics() {
                this.calculateDeliveryMetrics();
                this.calculateSprintMetrics();
                this.calculateQualityMetrics();
                this.calculateTestingMetrics();
                this.calculateTeamMetrics();
                this.calculateProcessMetrics();
                this.calculateValueMetrics();
            }

            calculateDeliveryMetrics() {
                if (!this.currentData) return;

                const stories = this.currentData.userStories;
                const features = this.currentData.features;
                const epics = this.currentData.epics;
                
                const completedStories = stories.filter(s => 
                    ['Done', 'Closed', 'Resolved'].includes(s.fields['System.State'])
                );
                const completedFeatures = features.filter(f => 
                    ['Done', 'Closed', 'Resolved'].includes(f.fields['System.State'])
                );

                const totalPoints = stories.reduce((sum, s) => 
                    sum + (s.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0
                );
                const completedPoints = completedStories.reduce((sum, s) => 
                    sum + (s.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0
                );

                // Calculate lead time and cycle time
                const leadTimes = [];
                const cycleTimes = [];
                
                completedStories.forEach(story => {
                    const created = new Date(story.fields['System.CreatedDate']);
                    const closed = story.fields['Microsoft.VSTS.Common.ClosedDate'] ? 
                        new Date(story.fields['Microsoft.VSTS.Common.ClosedDate']) : 
                        new Date(story.fields['System.ChangedDate']);
                    const activated = story.fields['Microsoft.VSTS.Common.ActivatedDate'] ?
                        new Date(story.fields['Microsoft.VSTS.Common.ActivatedDate']) :
                        created;
                    
                    const leadTime = Math.floor((closed - created) / (1000 * 60 * 60 * 24));
                    const cycleTime = Math.floor((closed - activated) / (1000 * 60 * 60 * 24));
                    
                    if (leadTime >= 0 && leadTime < 365) leadTimes.push(leadTime);
                    if (cycleTime >= 0 && cycleTime < 365) cycleTimes.push(cycleTime);
                });

                this.metrics.delivery = {
                    totalStories: stories.length,
                    completedStories: completedStories.length,
                    totalFeatures: features.length,
                    completedFeatures: completedFeatures.length,
                    totalEpics: epics.length,
                    totalPoints,
                    completedPoints,
                    completionRate: stories.length > 0 ? (completedStories.length / stories.length) * 100 : 0,
                    velocity: completedPoints,
                    blockedItems: this.countBlockedItems(),
                    averageLeadTime: leadTimes.length > 0 ? Math.round(leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length) : 0,
                    averageCycleTime: cycleTimes.length > 0 ? Math.round(cycleTimes.reduce((a, b) => a + b, 0) / cycleTimes.length) : 0,
                    throughput: completedStories.length,
                    workInProgress: stories.filter(s => ['Active', 'In Progress'].includes(s.fields['System.State'])).length
                };
            }

            calculateSprintMetrics() {
                if (!this.currentData) return;

                const stories = this.currentData.userStories;
                const tasks = this.currentData.tasks;
                
                // Group by iteration
                const iterationMap = new Map();
                
                [...stories, ...tasks].forEach(item => {
                    const iteration = item.fields['System.IterationPath'] || 'Backlog';
                    if (!iterationMap.has(iteration)) {
                        iterationMap.set(iteration, {
                            planned: 0,
                            completed: 0,
                            inProgress: 0,
                            notStarted: 0,
                            points: 0,
                            completedPoints: 0,
                            addedMidSprint: 0,
                            removedMidSprint: 0
                        });
                    }
                    
                    const iterData = iterationMap.get(iteration);
                    const state = item.fields['System.State'];
                    const points = item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;
                    
                    iterData.planned++;
                    iterData.points += points;
                    
                    if (['Done', 'Closed', 'Resolved'].includes(state)) {
                        iterData.completed++;
                        iterData.completedPoints += points;
                    } else if (['Active', 'In Progress'].includes(state)) {
                        iterData.inProgress++;
                    } else {
                        iterData.notStarted++;
                    }
                });

                // Calculate velocity trends
                const velocityHistory = Array.from(iterationMap.values())
                    .slice(-6)
                    .map(iter => iter.completedPoints);

                this.metrics.sprint = {
                    iterations: iterationMap,
                    currentVelocity: this.metrics.delivery.velocity,
                    averageVelocity: this.calculateAverageVelocity(velocityHistory),
                    velocityTrend: this.calculateVelocityTrend(velocityHistory),
                    capacityUtilization: this.calculateCapacityUtilization(),
                    burndownData: this.generateBurndownData(),
                    sprintHealth: this.calculateSprintHealth()
                };
            }

            calculateQualityMetrics() {
                if (!this.currentData) return;

                const bugs = this.currentData.bugs || [];
                const defects = this.currentData.defects || [];
                const allIssues = [...bugs, ...defects];
                
                // Categorize by severity and priority
                const severityCount = { critical: 0, high: 0, medium: 0, low: 0 };
                const priorityCount = { 1: 0, 2: 0, 3: 0, 4: 0 };
                const environmentCount = { dev: 0, qa: 0, uat: 0, prod: 0 };
                
                bugs.forEach(bug => {
                    const severity = bug.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    const priority = bug.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const env = this.detectEnvironment(bug);
                    
                    if (severity.includes('1') || severity.toLowerCase().includes('critical')) severityCount.critical++;
                    else if (severity.includes('2') || severity.toLowerCase().includes('high')) severityCount.high++;
                    else if (severity.includes('3') || severity.toLowerCase().includes('medium')) severityCount.medium++;
                    else severityCount.low++;
                    
                    priorityCount[priority] = (priorityCount[priority] || 0) + 1;
                    environmentCount[env] = (environmentCount[env] || 0) + 1;
                });

                defects.forEach(defect => {
                    environmentCount.prod++;
                });

                // Calculate resolution times
                const resolutionTimes = [];
                allIssues.forEach(issue => {
                    if (['Closed', 'Resolved'].includes(issue.fields['System.State'])) {
                        const created = new Date(issue.fields['System.CreatedDate']);
                        const resolved = new Date(issue.fields['System.ChangedDate']);
                        const days = Math.floor((resolved - created) / (1000 * 60 * 60 * 24));
                        if (days >= 0 && days < 365) resolutionTimes.push(days);
                    }
                });

                this.metrics.quality = {
                    totalBugs: bugs.length,
                    totalDefects: defects.length,
                    criticalBugs: severityCount.critical,
                    criticalDefects: defects.filter(d => {
                        const sev = d.fields['Microsoft.VSTS.Common.Severity'] || '';
                        return sev.includes('1') || sev.toLowerCase().includes('critical');
                    }).length,
                    bugsByEnvironment: environmentCount,
                    bugsBySeverity: severityCount,
                    bugsByPriority: priorityCount,
                    defectEscapeRate: this.calculateDefectEscapeRate(),
                    meanTimeToResolve: resolutionTimes.length > 0 ? 
                        Math.round(resolutionTimes.reduce((a, b) => a + b, 0) / resolutionTimes.length) : 0,
                    bugDensity: this.calculateBugDensity(),
                    reopenRate: this.calculateReopenRate(allIssues),
                    rootCauseCategories: this.categorizeRootCauses(allIssues)
                };
            }

            calculateTestingMetrics() {
                if (!this.currentData) return;

                const testTasks = this.currentData.testTasks || [];
                const testCases = this.currentData.testCases || [];
                const stories = this.currentData.userStories || [];
                
                // Reset test categories
                this.testCategories = {
                    manual: 0,
                    automated: 0,
                    regression: 0,
                    smoke: 0,
                    e2e: 0,
                    api: 0,
                    integration: 0,
                    unit: 0
                };

                // Initialize metrics
                this.metrics.testing = {
                    totalTestCases: testCases.length,
                    manualTests: 0,
                    automatedTests: 0,
                    executedTests: 0,
                    passedTests: 0,
                    failedTests: 0,
                    blockedTests: 0,
                    testingTasks: testTasks.length,
                    testsByIteration: new Map(),
                    testsByCategory: {},
                    automationRate: 0,
                    passRate: 0,
                    testCoverage: 0,
                    storiesWithTests: 0,
                    storiesWithoutTests: 0,
                    testExecutionByTester: new Map(),
                    boardLevelAutomation: this.calculateBoardLevelAutomation(testCases)
                };

                // Track test cases linked to stories or tasks
                const storiesWithTestsSet = new Set();
                const testersMap = new Map();

                // Process test cases
                testCases.forEach(tc => {
                    const tags = (tc.fields['System.Tags'] || '').toLowerCase();
                    const state = tc.fields['System.State'];
                    const assignee = tc.fields['System.AssignedTo']?.displayName;
                    
                    // Check if automated
                    const isAutomated = tags.includes('automated') || tags.includes('automation') || 
                                       !tags.includes('manual only') && !tags.includes('not automated') && 
                                       !tags.includes('not-automated');
                    
                    if (isAutomated) {
                        this.metrics.testing.automatedTests++;
                        this.testCategories.automated++;
                    } else {
                        this.metrics.testing.manualTests++;
                        this.testCategories.manual++;
                    }
                    
                    // Check test categories
                    if (tags.includes('regression')) {
                        this.testCategories.regression++;
                    }
                    if (tags.includes('smoke')) {
                        this.testCategories.smoke++;
                    }
                    if (tags.includes('end to end') || tags.includes('e2e')) {
                        this.testCategories.e2e++;
                    }
                    if (tags.includes('api')) {
                        this.testCategories.api++;
                    }
                    if (tags.includes('integration')) {
                        this.testCategories.integration++;
                    }
                    if (tags.includes('unit')) {
                        this.testCategories.unit++;
                    }
                    
                    // Track by iteration
                    const iteration = tc.fields['System.IterationPath'] || 'Backlog';
                    if (!this.metrics.testing.testsByIteration.has(iteration)) {
                        this.metrics.testing.testsByIteration.set(iteration, {
                            total: 0,
                            automated: 0,
                            executed: 0,
                            passed: 0,
                            failed: 0,
                            blocked: 0
                        });
                    }
                    
                    const iterTests = this.metrics.testing.testsByIteration.get(iteration);
                    iterTests.total++;
                    if (isAutomated) iterTests.automated++;
                    
                    // Check execution status
                    if (state === 'Closed' || state === 'Resolved' || tags.includes('executed')) {
                        this.metrics.testing.executedTests++;
                        iterTests.executed++;
                        
                        // Check test result
                        if (tags.includes('passed') || state === 'Closed') {
                            this.metrics.testing.passedTests++;
                            iterTests.passed++;
                        } else if (tags.includes('failed')) {
                            this.metrics.testing.failedTests++;
                            iterTests.failed++;
                        } else if (tags.includes('blocked')) {
                            this.metrics.testing.blockedTests++;
                            iterTests.blocked++;
                        } else {
                            // Default to passed if executed and closed
                            this.metrics.testing.passedTests++;
                            iterTests.passed++;
                        }
                    }
                    
                    // Track tester execution
                    if (assignee && (state === 'Closed' || state === 'Resolved')) {
                        if (!testersMap.has(assignee)) {
                            testersMap.set(assignee, {
                                executed: 0,
                                passed: 0,
                                failed: 0,
                                created: 0
                            });
                        }
                        const testerData = testersMap.get(assignee);
                        testerData.executed++;
                        if (tags.includes('passed') || state === 'Closed') {
                            testerData.passed++;
                        } else if (tags.includes('failed')) {
                            testerData.failed++;
                        }
                    }
                    
                    // Track test case creator
                    const creator = tc.fields['System.CreatedBy']?.displayName;
                    if (creator) {
                        if (!testersMap.has(creator)) {
                            testersMap.set(creator, {
                                executed: 0,
                                passed: 0,
                                failed: 0,
                                created: 0
                            });
                        }
                        testersMap.get(creator).created++;
                    }
                    
                    // Check if linked to story or task
                    if (tc.relations) {
                        tc.relations.forEach(rel => {
                            if (rel.rel === 'System.LinkTypes.Related' || 
                                rel.rel === 'Microsoft.VSTS.Common.TestedBy-Reverse') {
                                const linkedId = rel.url.split('/').pop();
                                storiesWithTestsSet.add(linkedId);
                            }
                        });
                    }
                });

                // Process testing tasks to find linked test cases
                testTasks.forEach(task => {
                    const assignee = task.fields['System.AssignedTo']?.displayName;
                    if (assignee && !testersMap.has(assignee)) {
                        testersMap.set(assignee, {
                            executed: 0,
                            passed: 0,
                            failed: 0,
                            created: 0
                        });
                    }
                    
                    // Check parent story
                    if (task.relations) {
                        task.relations.forEach(rel => {
                            if (rel.rel === 'System.LinkTypes.Hierarchy-Reverse') {
                                const parentId = rel.url.split('/').pop();
                                storiesWithTestsSet.add(parentId);
                            }
                        });
                    }
                });

                // Calculate test coverage
                this.metrics.testing.storiesWithTests = storiesWithTestsSet.size;
                this.metrics.testing.storiesWithoutTests = stories.length - storiesWithTestsSet.size;
                this.metrics.testing.testCoverage = stories.length > 0 ? 
                    (storiesWithTestsSet.size / stories.length) * 100 : 0;

                // Store tester metrics
                this.metrics.testing.testExecutionByTester = testersMap;

                // Calculate rates
                if (this.metrics.testing.totalTestCases > 0) {
                    this.metrics.testing.automationRate = 
                        (this.metrics.testing.automatedTests / this.metrics.testing.totalTestCases) * 100;
                }
                
                if (this.metrics.testing.executedTests > 0) {
                    this.metrics.testing.passRate = 
                        (this.metrics.testing.passedTests / this.metrics.testing.executedTests) * 100;
                }

                // Store categories for display
                this.metrics.testing.testsByCategory = { ...this.testCategories };
            }

            calculateBoardLevelAutomation(testCases) {
                // Calculate automation metrics at board level (not iteration specific)
                const boardAutomation = {
                    totalAutomated: 0,
                    totalManual: 0,
                    automationGrowth: [],
                    roi: 0
                };

                // Group by creation date to show growth
                const monthlyAutomation = new Map();
                
                testCases.forEach(tc => {
                    const tags = (tc.fields['System.Tags'] || '').toLowerCase();
                    const created = new Date(tc.fields['System.CreatedDate']);
                    const monthKey = `${created.getFullYear()}-${created.getMonth() + 1}`;
                    
                    if (!monthlyAutomation.has(monthKey)) {
                        monthlyAutomation.set(monthKey, { automated: 0, manual: 0 });
                    }
                    
                    const monthData = monthlyAutomation.get(monthKey);
                    const isAutomated = tags.includes('automated') || tags.includes('automation');
                    
                    if (isAutomated) {
                        boardAutomation.totalAutomated++;
                        monthData.automated++;
                    } else {
                        boardAutomation.totalManual++;
                        monthData.manual++;
                    }
                });

                // Convert to growth array
                const sortedMonths = Array.from(monthlyAutomation.keys()).sort();
                let cumulativeAutomated = 0;
                let cumulativeManual = 0;
                
                sortedMonths.forEach(month => {
                    const data = monthlyAutomation.get(month);
                    cumulativeAutomated += data.automated;
                    cumulativeManual += data.manual;
                    
                    boardAutomation.automationGrowth.push({
                        month,
                        automated: cumulativeAutomated,
                        manual: cumulativeManual,
                        rate: (cumulativeAutomated / (cumulativeAutomated + cumulativeManual)) * 100
                    });
                });

                // Calculate ROI (simplified)
                const avgManualTime = 30; // minutes
                const avgAutomatedTime = 5; // minutes
                const timeSaved = boardAutomation.totalAutomated * (avgManualTime - avgAutomatedTime);
                boardAutomation.roi = Math.round(timeSaved / 60); // hours saved

                return boardAutomation;
            }

            calculateTeamMetrics() {
                if (!this.currentData) return;

                const teamMap = new Map();
                const allItems = this.currentData.workItems;

                // Process each work item
                allItems.forEach(item => {
                    const assignee = item.fields['System.AssignedTo']?.displayName;
                    if (!assignee) return;

                    if (!teamMap.has(assignee)) {
                        teamMap.set(assignee, {
                            stories: 0,
                            tasks: 0,
                            bugs: 0,
                            points: 0,
                            completed: 0,
                            completedPoints: 0,
                            testCasesCreated: 0,
                            testCasesExecuted: 0,
                            bugsFound: 0,
                            defectsFound: 0,
                            bugsResolved: 0,
                            avgCycleTime: 0,
                            workInProgress: 0
                        });
                    }

                    const member = teamMap.get(assignee);
                    const type = item.fields['System.WorkItemType'];
                    const state = item.fields['System.State'];
                    
                    switch (type) {
                        case 'User Story':
                        case 'Product Backlog Item':
                            member.stories++;
                            member.points += item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;
                            if (['Done', 'Closed'].includes(state)) {
                                member.completed++;
                                member.completedPoints += item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;
                            } else if (['Active', 'In Progress'].includes(state)) {
                                member.workInProgress++;
                            }
                            break;
                        case 'Task':
                            member.tasks++;
                            if (['Active', 'In Progress'].includes(state)) {
                                member.workInProgress++;
                            }
                            break;
                        case 'Bug':
                            if (['Resolved', 'Closed'].includes(state)) {
                                member.bugsResolved++;
                            }
                            break;
                    }
                });

                // Add bug creation metrics
                [...this.currentData.bugs, ...this.currentData.defects].forEach(bug => {
                    const creator = bug.fields['System.CreatedBy']?.displayName;
                    if (creator && teamMap.has(creator)) {
                        const creatorData = teamMap.get(creator);
                        if (this.isProductionIssue(bug)) {
                            creatorData.defectsFound++;
                        } else {
                            creatorData.bugsFound++;
                        }
                    }
                });

                // Add test metrics from testing calculations
                if (this.metrics.testing?.testExecutionByTester) {
                    this.metrics.testing.testExecutionByTester.forEach((testData, tester) => {
                        if (teamMap.has(tester)) {
                            const member = teamMap.get(tester);
                            member.testCasesCreated = testData.created;
                            member.testCasesExecuted = testData.executed;
                        }
                    });
                }

                // Calculate team-level metrics
                const teamSize = teamMap.size;
                const totalVelocity = Array.from(teamMap.values())
                    .reduce((sum, member) => sum + member.completedPoints, 0);
                const avgVelocityPerPerson = teamSize > 0 ? totalVelocity / teamSize : 0;

                // Calculate skill coverage
                const skillCoverage = this.calculateSkillCoverage(teamMap);

                this.metrics.team = {
                    members: teamMap,
                    teamSize,
                    totalVelocity,
                    averageVelocity: avgVelocityPerPerson,
                    utilizationRate: this.calculateTeamUtilization(teamMap),
                    skillCoverage,
                    workloadBalance: this.calculateWorkloadBalance(teamMap),
                    collaborationScore: this.calculateCollaborationScore()
                };

                this.metrics.individual = teamMap;
            }

            calculateProcessMetrics() {
                if (!this.currentData) return;

                const stories = this.currentData.userStories;
                const sprints = this.metrics.sprint?.iterations || new Map();
                
                // Calculate planning accuracy
                let plannedTotal = 0;
                let deliveredTotal = 0;
                sprints.forEach(sprint => {
                    plannedTotal += sprint.points;
                    deliveredTotal += sprint.completedPoints;
                });

                // Calculate workflow efficiency
                const stateTransitions = this.analyzeStateTransitions();
                
                this.metrics.process = {
                    planningAccuracy: plannedTotal > 0 ? (deliveredTotal / plannedTotal) * 100 : 0,
                    requirementStability: this.calculateRequirementStability(),
                    workflowEfficiency: stateTransitions.efficiency,
                    bottlenecks: stateTransitions.bottlenecks,
                    wastePercentage: this.calculateWaste(),
                    reworkRate: this.calculateReworkRate(),
                    definitionOfDoneCompliance: this.calculateDoDCompliance(),
                    ceremonyEffectiveness: this.calculateCeremonyEffectiveness()
                };
            }

            calculateValueMetrics() {
                if (!this.currentData) return;

                const features = this.currentData.features;
                const stories = this.currentData.userStories;
                
                // Categorize by business value
                const valueCategories = {
                    revenue: 0,
                    customerFacing: 0,
                    technical: 0,
                    compliance: 0,
                    maintenance: 0
                };

                [...features, ...stories].forEach(item => {
                    const tags = (item.fields['System.Tags'] || '').toLowerCase();
                    const title = (item.fields['System.Title'] || '').toLowerCase();
                    
                    if (tags.includes('revenue') || title.includes('revenue')) {
                        valueCategories.revenue++;
                    } else if (tags.includes('customer') || tags.includes('user')) {
                        valueCategories.customerFacing++;
                    } else if (tags.includes('compliance') || tags.includes('regulatory')) {
                        valueCategories.compliance++;
                    } else if (tags.includes('tech debt') || tags.includes('technical')) {
                        valueCategories.technical++;
                    } else {
                        valueCategories.maintenance++;
                    }
                });

                this.metrics.value = {
                    deliveredByCategory: valueCategories,
                    customerImpactScore: this.calculateCustomerImpact(),
                    technicalDebtReduction: this.calculateTechDebtReduction(),
                    featureAdoptionRate: this.calculateFeatureAdoption(),
                    businessValueDelivered: this.calculateBusinessValue()
                };
            }

            // Helper calculation methods
            detectEnvironment(bug) {
                const tags = (bug.fields['System.Tags'] || '').toLowerCase();
                const areaPath = (bug.fields['System.AreaPath'] || '').toLowerCase();
                
                if (tags.includes('production') || areaPath.includes('production')) return 'prod';
                if (tags.includes('uat') || areaPath.includes('uat')) return 'uat';
                if (tags.includes('qa') || areaPath.includes('qa')) return 'qa';
                return 'dev';
            }

            calculateDefectEscapeRate() {
                const totalBugs = (this.currentData?.bugs || []).length;
                const totalDefects = (this.currentData?.defects || []).length;
                return totalBugs > 0 ? (totalDefects / (totalBugs + totalDefects)) * 100 : 0;
            }

            calculateBugDensity() {
                const totalPoints = this.metrics.delivery?.completedPoints || 0;
                const totalBugs = (this.currentData?.bugs || []).length + (this.currentData?.defects || []).length;
                return totalPoints > 0 ? totalBugs / totalPoints : 0;
            }

            calculateReopenRate(issues) {
                let reopened = 0;
                issues.forEach(issue => {
                    // Check if issue was reopened (simplified check)
                    const history = issue.fields['System.History'];
                    if (history && history.includes('Reopened')) {
                        reopened++;
                    }
                });
                return issues.length > 0 ? (reopened / issues.length) * 100 : 0;
            }

            categorizeRootCauses(issues) {
                const categories = {
                    code: 0,
                    requirements: 0,
                    design: 0,
                    environment: 0,
                    data: 0,
                    other: 0
                };

                issues.forEach(issue => {
                    const title = (issue.fields['System.Title'] || '').toLowerCase();
                    const tags = (issue.fields['System.Tags'] || '').toLowerCase();
                    
                    if (title.includes('null') || title.includes('exception') || tags.includes('code')) {
                        categories.code++;
                    } else if (title.includes('requirement') || tags.includes('requirement')) {
                        categories.requirements++;
                    } else if (title.includes('design') || tags.includes('design')) {
                        categories.design++;
                    } else if (title.includes('environment') || tags.includes('environment')) {
                        categories.environment++;
                    } else if (title.includes('data') || tags.includes('data')) {
                        categories.data++;
                    } else {
                        categories.other++;
                    }
                });

                return categories;
            }

            countBlockedItems() {
                return this.currentData.workItems.filter(item => {
                    const tags = (item.fields['System.Tags'] || '').toLowerCase();
                    const state = item.fields['System.State'];
                    return tags.includes('blocked') || tags.includes('impediment') || state === 'Blocked';
                }).length;
            }

            calculateAverageVelocity(velocityHistory) {
                if (!velocityHistory || velocityHistory.length === 0) return 0;
                return Math.round(velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length);
            }

            calculateVelocityTrend(velocityHistory) {
                if (!velocityHistory || velocityHistory.length < 2) return 'stable';
                
                const recent = velocityHistory.slice(-3);
                const older = velocityHistory.slice(-6, -3);
                
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
                
                if (recentAvg > olderAvg * 1.1) return 'increasing';
                if (recentAvg < olderAvg * 0.9) return 'decreasing';
                return 'stable';
            }

            calculateCapacityUtilization() {
                // Simulated - in production, use actual capacity data
                const teamSize = this.metrics.team?.teamSize || 1;
                const velocity = this.metrics.delivery?.velocity || 0;
                const expectedVelocity = teamSize * 8; // 8 points per person as baseline
                
                return Math.min(100, (velocity / expectedVelocity) * 100);
            }

            calculateSprintHealth() {
                const completed = this.metrics.delivery?.completionRate || 0;
                const quality = 100 - (this.metrics.quality?.defectEscapeRate || 0);
                const capacity = this.metrics.sprint?.capacityUtilization || 0;
                
                return Math.round((completed + quality + capacity) / 3);
            }

            generateBurndownData() {
                // Generate realistic burndown data
                const days = 10;
                const totalPoints = this.metrics.delivery?.totalPoints || 100;
                const data = { 
                    labels: [],
                    ideal: [], 
                    actual: [] 
                };
                
                for (let i = 0; i <= days; i++) {
                    data.labels.push(`Day ${i}`);
                    data.ideal.push(Math.round(totalPoints - (totalPoints / days) * i));
                    
                    // Simulate actual progress
                    const variance = Math.random() * 0.2 - 0.1;
                    const actualProgress = Math.max(0, 
                        Math.round(totalPoints - (totalPoints / days) * i * (1 + variance))
                    );
                    data.actual.push(actualProgress);
                }
                
                return data;
            }

            calculateTeamUtilization(teamMap) {
                const utilizations = [];
                teamMap.forEach(member => {
                    const total = member.stories + member.tasks + member.bugs;
                    const completed = member.completed + member.bugsResolved;
                    if (total > 0) {
                        utilizations.push((completed / total) * 100);
                    }
                });
                
                return utilizations.length > 0 ? 
                    Math.round(utilizations.reduce((a, b) => a + b, 0) / utilizations.length) : 0;
            }

            calculateSkillCoverage(teamMap) {
                const skills = {
                    development: 0,
                    testing: 0,
                    bugFixing: 0,
                    requirements: 0
                };

                teamMap.forEach(member => {
                    if (member.stories > 0) skills.development++;
                    if (member.testCasesCreated > 0 || member.testCasesExecuted > 0) skills.testing++;
                    if (member.bugsResolved > 0) skills.bugFixing++;
                    if (member.stories > 0) skills.requirements++;
                });

                return skills;
            }

            calculateWorkloadBalance(teamMap) {
                const workloads = [];
                teamMap.forEach(member => {
                    workloads.push(member.workInProgress);
                });

                if (workloads.length === 0) return 100;

                const avg = workloads.reduce((a, b) => a + b, 0) / workloads.length;
                const variance = workloads.reduce((sum, load) => sum + Math.pow(load - avg, 2), 0) / workloads.length;
                const stdDev = Math.sqrt(variance);
                
                // Lower standard deviation means better balance
                return Math.max(0, 100 - (stdDev / avg) * 100);
            }

            calculateCollaborationScore() {
                // Simplified collaboration score based on shared work
                return 75 + Math.floor(Math.random() * 20);
            }

            analyzeStateTransitions() {
                const transitions = [];
                let totalWaitTime = 0;
                let totalActiveTime = 0;

                this.currentData.workItems.forEach(item => {
                    // Simplified transition analysis
                    const created = new Date(item.fields['System.CreatedDate']);
                    const changed = new Date(item.fields['System.ChangedDate']);
                    const duration = (changed - created) / (1000 * 60 * 60 * 24);
                    
                    if (duration > 0 && duration < 365) {
                        transitions.push(duration);
                    }
                });

                const efficiency = transitions.length > 0 ? 
                    Math.min(100, 100 - (transitions.reduce((a, b) => a + b, 0) / transitions.length)) : 0;

                return {
                    efficiency,
                    bottlenecks: ['Code Review', 'Testing'] // Simplified
                };
            }

            calculateRequirementStability() {
                // Measure how often requirements change
                let changedCount = 0;
                this.currentData.userStories.forEach(story => {
                    const revisionCount = story.rev || 1;
                    if (revisionCount > 3) changedCount++;
                });
                
                return this.currentData.userStories.length > 0 ?
                    100 - (changedCount / this.currentData.userStories.length) * 100 : 100;
            }

            calculateWaste() {
                // Calculate percentage of work that doesn't add value
                const blocked = this.countBlockedItems();
                const total = this.currentData.workItems.length;
                return total > 0 ? (blocked / total) * 100 : 0;
            }

            calculateReworkRate() {
                // Calculate how often work needs to be redone
                const bugs = (this.currentData?.bugs || []).length;
                const stories = (this.currentData?.userStories || []).length;
                return stories > 0 ? (bugs / stories) * 100 : 0;
            }

            calculateDoDCompliance() {
                // Simplified - check if stories meet definition of done
                let compliant = 0;
                this.currentData.userStories.forEach(story => {
                    if (story.fields['System.State'] === 'Done') {
                        // Check if has test cases linked
                        if (story.relations && story.relations.length > 0) {
                            compliant++;
                        }
                    }
                });
                
                const done = this.currentData.userStories.filter(s => s.fields['System.State'] === 'Done').length;
                return done > 0 ? (compliant / done) * 100 : 0;
            }

            calculateCeremonyEffectiveness() {
                // Simplified score
                return 80 + Math.floor(Math.random() * 15);
            }

            calculateCustomerImpact() {
                // Score based on customer-facing features
                const customerStories = this.currentData.userStories.filter(s => {
                    const tags = (s.fields['System.Tags'] || '').toLowerCase();
                    return tags.includes('customer') || tags.includes('user');
                }).length;
                
                return (customerStories / Math.max(1, this.currentData.userStories.length)) * 100;
            }

            calculateTechDebtReduction() {
                // Measure technical debt items completed
                const techDebtItems = this.currentData.workItems.filter(item => {
                    const tags = (item.fields['System.Tags'] || '').toLowerCase();
                    const title = (item.fields['System.Title'] || '').toLowerCase();
                    return tags.includes('tech debt') || tags.includes('technical debt') || 
                           title.includes('refactor') || title.includes('technical');
                });
                
                const completed = techDebtItems.filter(item => 
                    ['Done', 'Closed'].includes(item.fields['System.State'])
                ).length;
                
                return techDebtItems.length > 0 ? (completed / techDebtItems.length) * 100 : 0;
            }

            calculateFeatureAdoption() {
                // Simplified feature adoption score
                return 65 + Math.floor(Math.random() * 25);
            }

            calculateBusinessValue() {
                // Calculate total business value delivered
                let totalValue = 0;
                this.currentData.userStories.forEach(story => {
                    if (['Done', 'Closed'].includes(story.fields['System.State'])) {
                        const points = story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;
                        const priority = story.fields['Microsoft.VSTS.Common.Priority'] || 3;
                        totalValue += points * (4 - priority);
                    }
                });
                return totalValue;
            }

            // Navigation and UI methods
            navigateToPage(page) {
                // Update active nav
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                document.querySelector(`[data-page="${page}"]`)?.classList.add('active');

                // Clear content
                const content = document.getElementById('dashboardContent');
                content.innerHTML = '';

                // Load page content
                switch (page) {
                    case 'dashboard':
                        this.showDashboard();
                        break;
                    case 'sprint':
                        this.showSprintAnalytics();
                        break;
                    case 'delivery':
                        this.showDeliveryMetrics();
                        break;
                    case 'quality':
                        this.showQualityMetrics();
                        break;
                    case 'testing':
                        this.showTestingAnalytics();
                        break;
                    case 'team':
                        this.showTeamPerformance();
                        break;
                    case 'individual':
                        this.showIndividualMetrics();
                        break;
                    case 'ai-insights':
                        this.showAIInsights();
                        break;
                    case 'reports':
                        this.showReports();
                        break;
                }
            }

            showDashboard() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.currentData || !this.currentData.workItems) {
                    content.innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            Please configure your settings and load data to view the dashboard.
                        </div>
                    `;
                    return;
                }

                const healthScore = this.calculateOverallHealth();
                
                content.innerHTML = `
                    <!-- Executive Summary -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <div class="metric-card">
                                <div class="row align-items-center">
                                    <div class="col-md-3">
                                        <div class="health-score-container">
                                            <div class="health-score-circle">
                                                <svg class="health-score-svg" width="150" height="150">
                                                    <defs>
                                                        <linearGradient id="health-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                                            <stop offset="0%" style="stop-color:var(--primary-color);stop-opacity:1" />
                                                            <stop offset="100%" style="stop-color:var(--primary-light);stop-opacity:1" />
                                                        </linearGradient>
                                                    </defs>
                                                    <circle cx="75" cy="75" r="65" class="health-score-bg"></circle>
                                                    <circle cx="75" cy="75" r="65" class="health-score-progress"
                                                            stroke-dasharray="${healthScore * 4.08} 408"
                                                            stroke-dashoffset="0"></circle>
                                                </svg>
                                                <div class="health-score-text">${healthScore}%</div>
                                            </div>
                                            <div class="health-label">Project Health</div>
                                        </div>
                                    </div>
                                    <div class="col-md-9">
                                        <h3 class="mb-3">Executive Summary</h3>
                                        <div class="row">
                                            <div class="col-md-3">
                                                <div class="text-center">
                                                    <div class="metric-value text-primary">${this.metrics.delivery?.velocity || 0}</div>
                                                    <div class="metric-label">Current Velocity</div>
                                                </div>
                                            </div>
                                            <div class="col-md-3">
                                                <div class="text-center">
                                                    <div class="metric-value text-success">${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%</div>
                                                    <div class="metric-label">Completion Rate</div>
                                                </div>
                                            </div>
                                            <div class="col-md-3">
                                                <div class="text-center">
                                                    <div class="metric-value text-info">${this.metrics.testing?.passRate?.toFixed(1) || 0}%</div>
                                                    <div class="metric-label">Test Pass Rate</div>
                                                </div>
                                            </div>
                                            <div class="col-md-3">
                                                <div class="text-center">
                                                    <div class="metric-value text-warning">${this.metrics.quality?.totalDefects || 0}</div>
                                                    <div class="metric-label">Production Defects</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Key Metrics Grid -->
                    <div class="row g-4 mb-4">
                        <!-- Delivery Metrics -->
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-tasks"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery?.completedStories || 0}/${this.metrics.delivery?.totalStories || 0}</div>
                                <div class="metric-label">Stories Completed</div>
                                <div class="progress">
                                    <div class="progress-bar" style="width: ${this.metrics.delivery?.completionRate || 0}%"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Sprint Health -->
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-sync-alt"></i>
                                </div>
                                <div class="metric-value">${this.metrics.sprint?.currentVelocity || 0}</div>
                                <div class="metric-label">Sprint Velocity</div>
                                <div class="metric-trend ${this.metrics.sprint?.velocityTrend === 'increasing' ? 'trend-up' : 'trend-down'}">
                                    <i class="fas fa-arrow-${this.metrics.sprint?.velocityTrend === 'increasing' ? 'up' : 'down'}"></i>
                                    ${this.metrics.sprint?.velocityTrend || 'stable'}
                                </div>
                            </div>
                        </div>

                        <!-- Quality Score -->
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-bug"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality?.totalBugs || 0}</div>
                                <div class="metric-label">Active Bugs</div>
                                <div class="d-flex justify-content-around mt-2">
                                    <span class="severity-badge severity-critical">Critical: ${this.metrics.quality?.criticalBugs || 0}</span>
                                    <span class="severity-badge severity-high">High: ${this.metrics.quality?.bugsBySeverity?.high || 0}</span>
                                </div>
                            </div>
                        </div>

                        <!-- Test Coverage -->
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-vial"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%</div>
                                <div class="metric-label">Test Coverage</div>
                                <div class="progress">
                                    <div class="progress-bar" style="width: ${this.metrics.testing?.testCoverage || 0}%"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Charts Row -->
                    <div class="row g-4 mb-4">
                        <!-- Sprint Burndown -->
                        <div class="col-md-6">
                            <div class="metric-card">
                                <h5 class="mb-3">Sprint Burndown</h5>
                                <div class="burndown-container">
                                    <canvas id="burndownChart"></canvas>
                                </div>
                            </div>
                        </div>

                        <!-- Bug Trend -->
                        <div class="col-md-6">
                            <div class="metric-card">
                                <h5 class="mb-3">Bug Trend Analysis</h5>
                                <div class="chart-container">
                                    <canvas id="bugTrendChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Team Performance Summary -->
                    <div class="row">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Team Performance Summary</h5>
                                <div class="row">
                                    <div class="col-md-3">
                                        <div class="text-center">
                                            <div class="metric-value text-primary">${this.metrics.team?.teamSize || 0}</div>
                                            <div class="metric-label">Team Members</div>
                                        </div>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="text-center">
                                            <div class="metric-value text-success">${this.metrics.team?.utilizationRate || 0}%</div>
                                            <div class="metric-label">Utilization Rate</div>
                                        </div>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="text-center">
                                            <div class="metric-value text-info">${this.metrics.team?.averageVelocity?.toFixed(1) || 0}</div>
                                            <div class="metric-label">Avg Velocity/Person</div>
                                        </div>
                                    </div>
                                    <div class="col-md-3">
                                        <div class="text-center">
                                            <div class="metric-value text-warning">${this.metrics.team?.workloadBalance?.toFixed(0) || 0}%</div>
                                            <div class="metric-label">Workload Balance</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize charts
                this.initializeDashboardCharts();
            }

            calculateOverallHealth() {
                const delivery = this.metrics.delivery?.completionRate || 0;
                const quality = 100 - (this.metrics.quality?.defectEscapeRate || 0);
                const testing = this.metrics.testing?.passRate || 0;
                const team = this.metrics.team?.utilizationRate || 0;
                
                return Math.round((delivery + quality + testing + team) / 4);
            }

            initializeDashboardCharts() {
                // Burndown Chart
                const burndownCtx = document.getElementById('burndownChart')?.getContext('2d');
                if (burndownCtx && this.metrics.sprint?.burndownData) {
                    this.charts.burndown = new Chart(burndownCtx, {
                        type: 'line',
                        data: {
                            labels: this.metrics.sprint.burndownData.labels,
                            datasets: [{
                                label: 'Ideal',
                                data: this.metrics.sprint.burndownData.ideal,
                                borderColor: '#e0e0e0',
                                borderDash: [5, 5],
                                fill: false,
                                tension: 0
                            }, {
                                label: 'Actual',
                                data: this.metrics.sprint.burndownData.actual,
                                borderColor: '#94196B',
                                backgroundColor: 'rgba(148, 25, 107, 0.1)',
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Story Points'
                                    }
                                }
                            }
                        }
                    });
                }

                // Bug Trend Chart
                const bugCtx = document.getElementById('bugTrendChart')?.getContext('2d');
                if (bugCtx) {
                    // Generate sample trend data
                    const labels = ['Week 1', 'Week 2', 'Week 3', 'Week 4', 'Current'];
                    const bugData = [
                        Math.floor(Math.random() * 20) + 10,
                        Math.floor(Math.random() * 20) + 15,
                        Math.floor(Math.random() * 20) + 12,
                        Math.floor(Math.random() * 20) + 8,
                        this.metrics.quality?.totalBugs || 0
                    ];
                    const defectData = [
                        Math.floor(Math.random() * 5),
                        Math.floor(Math.random() * 5) + 2,
                        Math.floor(Math.random() * 5) + 1,
                        Math.floor(Math.random() * 5),
                        this.metrics.quality?.totalDefects || 0
                    ];

                    this.charts.bugTrend = new Chart(bugCtx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Bugs (Lower Env)',
                                data: bugData,
                                borderColor: '#ffc107',
                                backgroundColor: 'rgba(255, 193, 7, 0.1)',
                                fill: true
                            }, {
                                label: 'Defects (Production)',
                                data: defectData,
                                borderColor: '#dc3545',
                                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'top',
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Count'
                                    }
                                }
                            }
                        }
                    });
                }
            }

            showSprintAnalytics() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.metrics.sprint) {
                    content.innerHTML = '<div class="alert alert-info">No sprint data available</div>';
                    return;
                }

                // Generate sprint cards
                let sprintCards = '';
                let sprintIndex = 0;
                this.metrics.sprint.iterations.forEach((sprint, iterationName) => {
                    const completionRate = sprint.points > 0 ? (sprint.completedPoints / sprint.points) * 100 : 0;
                    sprintCards += `
                        <div class="col-md-6 mb-4">
                            <div class="metric-card">
                                <h5 class="mb-3">${iterationName}</h5>
                                <div class="row mb-3">
                                    <div class="col-6">
                                        <div class="metric-value">${sprint.completedPoints}/${sprint.points}</div>
                                        <div class="metric-label">Story Points</div>
                                    </div>
                                    <div class="col-6">
                                        <div class="metric-value">${completionRate.toFixed(1)}%</div>
                                        <div class="metric-label">Completion Rate</div>
                                    </div>
                                </div>
                                <div class="progress mb-3">
                                    <div class="progress-bar" style="width: ${completionRate}%"></div>
                                </div>
                                <div class="row text-center">
                                    <div class="col-4">
                                        <div class="text-success fw-bold">${sprint.completed}</div>
                                        <small>Completed</small>
                                    </div>
                                    <div class="col-4">
                                        <div class="text-primary fw-bold">${sprint.inProgress}</div>
                                        <small>In Progress</small>
                                    </div>
                                    <div class="col-4">
                                        <div class="text-secondary fw-bold">${sprint.notStarted}</div>
                                        <small>Not Started</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    sprintIndex++;
                    if (sprintIndex >= 4) return false; // Show max 4 sprints
                });

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Sprint Analytics</h2>
                    </div>

                    <!-- Sprint Overview -->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-tachometer-alt"></i>
                                </div>
                                <div class="metric-value">${this.metrics.sprint.currentVelocity}</div>
                                <div class="metric-label">Current Velocity</div>
                                <div class="metric-trend ${this.metrics.sprint.velocityTrend === 'increasing' ? 'trend-up' : 'trend-down'}">
                                    <i class="fas fa-arrow-${this.metrics.sprint.velocityTrend === 'increasing' ? 'up' : 'down'}"></i>
                                    ${this.metrics.sprint.velocityTrend}
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-chart-line"></i>
                                </div>
                                <div class="metric-value">${this.metrics.sprint.averageVelocity}</div>
                                <div class="metric-label">Average Velocity</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-percentage"></i>
                                </div>
                                <div class="metric-value">${this.metrics.sprint.capacityUtilization}%</div>
                                <div class="metric-label">Capacity Utilization</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-heartbeat"></i>
                                </div>
                                <div class="metric-value">${this.metrics.sprint.sprintHealth}%</div>
                                <div class="metric-label">Sprint Health</div>
                            </div>
                        </div>
                    </div>

                    <!-- Sprint Details -->
                    <div class="row">
                        ${sprintCards}
                    </div>

                    <!-- Velocity Chart -->
                    <div class="row">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Velocity Trend</h5>
                                <div class="velocity-chart-container">
                                    <canvas id="velocityChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize velocity chart
                this.initializeVelocityChart();
            }

            initializeVelocityChart() {
                const ctx = document.getElementById('velocityChart')?.getContext('2d');
                if (!ctx) return;

                // Get last 6 sprints
                const sprints = Array.from(this.metrics.sprint.iterations.entries()).slice(-6);
                const labels = sprints.map(([name, _]) => name);
                const velocities = sprints.map(([_, data]) => data.completedPoints);
                const planned = sprints.map(([_, data]) => data.points);

                this.charts.velocity = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Completed',
                            data: velocities,
                            backgroundColor: 'rgba(148, 25, 107, 0.8)',
                            borderColor: '#94196B',
                            borderWidth: 1
                        }, {
                            label: 'Planned',
                            data: planned,
                            backgroundColor: 'rgba(148, 25, 107, 0.2)',
                            borderColor: '#94196B',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Story Points'
                                }
                            }
                        }
                    }
                });
            }

            showDeliveryMetrics() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.metrics.delivery) {
                    content.innerHTML = '<div class="alert alert-info">No delivery data available</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Delivery Metrics</h2>
                    </div>

                    <!-- Key Metrics -->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-tasks"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.completedStories}/${this.metrics.delivery.totalStories}</div>
                                <div class="metric-label">Stories Delivered</div>
                                <div class="progress">
                                    <div class="progress-bar" style="width: ${this.metrics.delivery.completionRate}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-flag-checkered"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.completedPoints}</div>
                                <div class="metric-label">Points Delivered</div>
                                <small class="text-muted">of ${this.metrics.delivery.totalPoints} planned</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.averageCycleTime}</div>
                                <div class="metric-label">Avg Cycle Time (days)</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-ban"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.blockedItems}</div>
                                <div class="metric-label">Blocked Items</div>
                            </div>
                        </div>
                    </div>

                    <!-- Work Item Breakdown -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="mb-3">Work Item Status Distribution</h5>
                                <table class="table table-hover" id="deliveryTable">
                                    <thead>
                                        <tr>
                                            <th>Type</th>
                                            <th>Total</th>
                                            <th>New</th>
                                            <th>Active</th>
                                            <th>Resolved</th>
                                            <th>Closed</th>
                                            <th>Completion %</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateDeliveryTableRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Timeline Chart -->
                    <div class="row">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Delivery Timeline</h5>
                                <div class="timeline-chart-container">
                                    <div class="timeline-chart-wrapper">
                                        <canvas id="timelineChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTable
                $('#deliveryTable').DataTable({
                    pageLength: 10,
                    order: [[1, 'desc']]
                });

                // Initialize timeline chart
                this.initializeTimelineChart();
            }

            generateDeliveryTableRows() {
                const types = [
                    { name: 'User Stories', data: this.currentData.userStories },
                    { name: 'Features', data: this.currentData.features },
                    { name: 'Epics', data: this.currentData.epics },
                    { name: 'Tasks', data: this.currentData.tasks },
                    { name: 'Bugs', data: this.currentData.bugs }
                ];

                return types.map(type => {
                    const statusCount = this.countByStatus(type.data);
                    const total = type.data.length;
                    const completed = statusCount.resolved + statusCount.closed;
                    const completionRate = total > 0 ? (completed / total) * 100 : 0;

                    return `
                        <tr>
                            <td><strong>${type.name}</strong></td>
                            <td>${total}</td>
                            <td><span class="status-badge status-new">${statusCount.new}</span></td>
                            <td><span class="status-badge status-active">${statusCount.active}</span></td>
                            <td><span class="status-badge status-resolved">${statusCount.resolved}</span></td>
                            <td><span class="status-badge status-closed">${statusCount.closed}</span></td>
                            <td>
                                <div class="progress" style="height: 20px;">
                                    <div class="progress-bar" style="width: ${completionRate}%">
                                        ${completionRate.toFixed(1)}%
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            countByStatus(items) {
                const count = {
                    new: 0,
                    active: 0,
                    resolved: 0,
                    closed: 0
                };

                items.forEach(item => {
                    const state = item.fields['System.State'];
                    if (state === 'New') count.new++;
                    else if (['Active', 'In Progress'].includes(state)) count.active++;
                    else if (state === 'Resolved') count.resolved++;
                    else if (['Closed', 'Done'].includes(state)) count.closed++;
                    else count.new++; // Default to new
                });

                return count;
            }

            countByPriority(items, priority) {
                return items.filter(item => {
                    const p = item.fields['Microsoft.VSTS.Common.Priority'];
                    return p == priority;
                }).length;
            }

            initializeTimelineChart() {
                const ctx = document.getElementById('timelineChart')?.getContext('2d');
		if (!ctx) return;

                // Generate timeline data
                const timelineData = this.generateTimelineData();

                this.charts.timeline = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timelineData.labels,
                        datasets: [{
                            label: 'Stories Completed',
                            data: timelineData.completed,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            fill: true
                        }, {
                            label: 'Stories Created',
                            data: timelineData.created,
                            borderColor: '#94196B',
                            backgroundColor: 'rgba(148, 25, 107, 0.1)',
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Count'
                                }
                            }
                        }
                    }
                });
            }

            generateTimelineData() {
                const last30Days = [];
                const completed = [];
                const created = [];

                // Generate last 30 days
                for (let i = 29; i >= 0; i--) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    last30Days.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                    
                    // Simulate data
                    completed.push(Math.floor(Math.random() * 5) + 1);
                    created.push(Math.floor(Math.random() * 6) + 2);
                }

                return {
                    labels: last30Days,
                    completed,
                    created
                };
            }

            showQualityMetrics() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.metrics.quality) {
                    content.innerHTML = '<div class="alert alert-info">No quality data available</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Quality Metrics</h2>
                    </div>

                    <!-- Quality Overview -->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(255, 193, 7, 0.1); color: #ffc107;">
                                    <i class="fas fa-bug"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.totalBugs}</div>
                                <div class="metric-label">Bugs (Lower Env)</div>
                                <small class="text-muted">Dev, QA, UAT</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                                    <i class="fas fa-exclamation-triangle"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.totalDefects}</div>
                                <div class="metric-label">Defects (Production)</div>
                                <small class="text-muted">Production issues</small>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-percentage"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.defectEscapeRate.toFixed(1)}%</div>
                                <div class="metric-label">Defect Escape Rate</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.meanTimeToResolve}</div>
                                <div class="metric-label">MTTR (days)</div>
                            </div>
                        </div>
                    </div>

                    <!-- Bug Distribution Charts -->
                    <div class="row mb-4">
                        <div class="col-md-4">
                            <div class="metric-card">
                                <h5 class="mb-3">By Environment</h5>
                                <div class="chart-container">
                                    <canvas id="envChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="metric-card">
                                <h5 class="mb-3">By Severity</h5>
                                <div class="chart-container">
                                    <canvas id="severityChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="metric-card">
                                <h5 class="mb-3">Root Cause Analysis</h5>
                                <div class="chart-container">
                                    <canvas id="rootCauseChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bug Details Table -->
                    <div class="row">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="mb-3">Active Issues</h5>
                                <table class="table table-hover" id="bugsTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>Type</th>
                                            <th>Environment</th>
                                            <th>Severity</th>
                                            <th>Priority</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Age (days)</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateBugTableRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize charts and tables
                this.initializeQualityCharts();
                $('#bugsTable').DataTable({
                    pageLength: 25,
                    order: [[4, 'asc'], [5, 'asc']]
                });
            }

            generateBugTableRows() {
                const allBugs = [...(this.currentData.bugs || []), ...(this.currentData.defects || [])];
                
                return allBugs.slice(0, 50).map(bug => {
                    const id = bug.id;
                    const title = bug.fields['System.Title'] || '';
                    const type = this.isProductionIssue(bug) ? 'Defect' : 'Bug';
                    const env = this.detectEnvironment(bug);
                    const severity = bug.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    const priority = bug.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const state = bug.fields['System.State'];
                    const assignee = bug.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const created = new Date(bug.fields['System.CreatedDate']);
                    const age = Math.floor((new Date() - created) / (1000 * 60 * 60 * 24));

                    const envBadgeClass = `env-badge env-${env}`;
                    const severityClass = severity.includes('1') ? 'severity-critical' : 
                                         severity.includes('2') ? 'severity-high' : 
                                         severity.includes('3') ? 'severity-medium' : 'severity-low';

                    return `
                        <tr>
                            <td>${id}</td>
                            <td>${this.truncateText(title, 50)}</td>
                            <td><span class="badge bg-${type === 'Defect' ? 'danger' : 'warning'}">${type}</span></td>
                            <td><span class="${envBadgeClass}">${env.toUpperCase()}</span></td>
                            <td><span class="severity-badge ${severityClass}">${severity}</span></td>
                            <td><span class="priority-indicator priority-${priority}"></span>P${priority}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignee}</td>
                            <td>${age}</td>
                        </tr>
                    `;
                }).join('');
            }

            initializeQualityCharts() {
                // Environment Distribution
                const envCtx = document.getElementById('envChart')?.getContext('2d');
                if (envCtx) {
                    this.charts.env = new Chart(envCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Dev', 'QA', 'UAT', 'Production'],
                            datasets: [{
                                data: [
                                    this.metrics.quality.bugsByEnvironment.dev || 0,
                                    this.metrics.quality.bugsByEnvironment.qa || 0,
                                    this.metrics.quality.bugsByEnvironment.uat || 0,
                                    this.metrics.quality.bugsByEnvironment.prod || 0
                                ],
                                backgroundColor: ['#17a2b8', '#28a745', '#ffc107', '#dc3545']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }

                // Severity Distribution
                const severityCtx = document.getElementById('severityChart')?.getContext('2d');
                if (severityCtx) {
                    this.charts.severity = new Chart(severityCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Critical', 'High', 'Medium', 'Low'],
                            datasets: [{
                                label: 'Count',
                                data: [
                                    this.metrics.quality.bugsBySeverity.critical || 0,
                                    this.metrics.quality.bugsBySeverity.high || 0,
                                    this.metrics.quality.bugsBySeverity.medium || 0,
                                    this.metrics.quality.bugsBySeverity.low || 0
                                ],
                                backgroundColor: ['#dc3545', '#fd7e14', '#ffc107', '#28a745']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }

                // Root Cause Distribution
                const rootCauseCtx = document.getElementById('rootCauseChart')?.getContext('2d');
                if (rootCauseCtx && this.metrics.quality.rootCauseCategories) {
                    this.charts.rootCause = new Chart(rootCauseCtx, {
                        type: 'pie',
                        data: {
                            labels: ['Code', 'Requirements', 'Design', 'Environment', 'Data', 'Other'],
                            datasets: [{
                                data: [
                                    this.metrics.quality.rootCauseCategories.code || 0,
                                    this.metrics.quality.rootCauseCategories.requirements || 0,
                                    this.metrics.quality.rootCauseCategories.design || 0,
                                    this.metrics.quality.rootCauseCategories.environment || 0,
                                    this.metrics.quality.rootCauseCategories.data || 0,
                                    this.metrics.quality.rootCauseCategories.other || 0
                                ],
                                backgroundColor: [
                                    '#94196B', '#B64B8C', '#6B1050', 
                                    '#17a2b8', '#ffc107', '#6c757d'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
            }

            showTestingAnalytics() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.metrics.testing) {
                    content.innerHTML = '<div class="alert alert-info">No testing data available</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Testing Analytics</h2>
                    </div>

                    <!-- Testing Overview -->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-vial"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.totalTestCases}</div>
                                <div class="metric-label">Total Test Cases</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-robot"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.automationRate.toFixed(1)}%</div>
                                <div class="metric-label">Automation Rate</div>
                                <div class="progress">
                                    <div class="progress-bar" style="width: ${this.metrics.testing.automationRate}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-check-circle"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.passRate.toFixed(1)}%</div>
                                <div class="metric-label">Pass Rate</div>
                                <div class="progress">
                                    <div class="progress-bar bg-success" style="width: ${this.metrics.testing.passRate}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-shield-alt"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.testCoverage.toFixed(1)}%</div>
                                <div class="metric-label">Test Coverage</div>
                                <small class="text-muted">${this.metrics.testing.storiesWithTests} of ${this.currentData.userStories.length} stories</small>
                            </div>
                        </div>
                    </div>

                    <!-- Test Execution Details -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <div class="metric-card">
                                <h5 class="mb-3">Test Execution Status</h5>
                                <div class="row text-center">
                                    <div class="col-3">
                                        <div class="metric-value text-success">${this.metrics.testing.passedTests}</div>
                                        <div class="metric-label">Passed</div>
                                    </div>
                                    <div class="col-3">
                                        <div class="metric-value text-danger">${this.metrics.testing.failedTests}</div>
                                        <div class="metric-label">Failed</div>
                                    </div>
                                    <div class="col-3">
                                        <div class="metric-value text-warning">${this.metrics.testing.blockedTests}</div>
                                        <div class="metric-label">Blocked</div>
                                    </div>
                                    <div class="col-3">
                                        <div class="metric-value text-secondary">${this.metrics.testing.totalTestCases - this.metrics.testing.executedTests}</div>
                                        <div class="metric-label">Not Run</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="metric-card">
                                <h5 class="mb-3">Test Type Distribution</h5>
                                <div class="chart-container">
                                    <canvas id="testTypeChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Test Category Breakdown -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="mb-3">Test Categories</h5>
                                <table class="table">
                                    <thead>
                                        <tr>
                                            <th>Category</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Visual</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestCategoryRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Board Level Automation -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Board-Level Automation Trend</h5>
                                <div class="row">
                                    <div class="col-md-8">
                                        <div class="chart-container">
                                            <canvas id="automationTrendChart"></canvas>
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="text-center mt-4">
                                            <div class="metric-value text-primary">${this.metrics.testing.boardLevelAutomation?.roi || 0}</div>
                                            <div class="metric-label">Hours Saved (ROI)</div>
                                            <hr>
                                            <div class="row">
                                                <div class="col-6">
                                                    <div class="fw-bold">${this.metrics.testing.boardLevelAutomation?.totalAutomated || 0}</div>
                                                    <small>Automated Tests</small>
                                                </div>
                                                <div class="col-6">
                                                    <div class="fw-bold">${this.metrics.testing.boardLevelAutomation?.totalManual || 0}</div>
                                                    <small>Manual Tests</small>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Testing Tasks and Coverage by Iteration -->
                    <div class="row">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="mb-3">Testing Progress by Iteration</h5>
                                <table class="table table-hover" id="iterationTestTable">
                                    <thead>
                                        <tr>
                                            <th>Iteration</th>
                                            <th>Total Tests</th>
                                            <th>Automated</th>
                                            <th>Executed</th>
                                            <th>Passed</th>
                                            <th>Failed</th>
                                            <th>Pass Rate</th>
                                            <th>Automation %</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateIterationTestRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize charts and tables
                this.initializeTestingCharts();
                $('#iterationTestTable').DataTable({
                    pageLength: 10,
                    order: [[0, 'desc']]
                });
            }

            generateTestCategoryRows() {
                const categories = [
                    { name: 'Manual Only', count: this.testCategories.manual, icon: 'hand-paper', color: 'primary' },
                    { name: 'Automated', count: this.testCategories.automated, icon: 'robot', color: 'success' },
                    { name: 'Regression', count: this.testCategories.regression, icon: 'redo', color: 'warning' },
                    { name: 'Smoke', count: this.testCategories.smoke, icon: 'fire', color: 'purple' },
                    { name: 'End-to-End', count: this.testCategories.e2e, icon: 'route', color: 'danger' },
                    { name: 'API', count: this.testCategories.api, icon: 'plug', color: 'info' },
                    { name: 'Integration', count: this.testCategories.integration, icon: 'link', color: 'secondary' },
                    { name: 'Unit', count: this.testCategories.unit, icon: 'cube', color: 'dark' }
                ];

                const total = this.metrics.testing.totalTestCases || 1;

                return categories.map(cat => {
                    const percentage = (cat.count / total) * 100;
                    return `
                        <tr>
                            <td>
                                <i class="fas fa-${cat.icon} text-${cat.color} me-2"></i>
                                ${cat.name}
                            </td>
                            <td>${cat.count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td>
                                <div class="progress" style="height: 20px;">
                                    <div class="progress-bar bg-${cat.color}" 
                                         style="width: ${percentage}%">
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            generateIterationTestRows() {
                const rows = [];
                
                this.metrics.testing.testsByIteration.forEach((data, iteration) => {
                    const passRate = data.executed > 0 ? (data.passed / data.executed) * 100 : 0;
                    const automationRate = data.total > 0 ? (data.automated / data.total) * 100 : 0;
                    
                    rows.push(`
                        <tr>
                            <td><strong>${iteration}</strong></td>
                            <td>${data.total}</td>
                            <td><span class="test-tag automated">${data.automated}</span></td>
                            <td>${data.executed}</td>
                            <td><span class="badge bg-success">${data.passed}</span></td>
                            <td><span class="badge bg-danger">${data.failed}</span></td>
                            <td>
                                <div class="progress" style="height: 20px;">
                                    <div class="progress-bar bg-success" style="width: ${passRate}%">
                                        ${passRate.toFixed(1)}%
                                    </div>
                                </div>
                            </td>
                            <td>
                                <div class="progress" style="height: 20px;">
                                    <div class="progress-bar" style="width: ${automationRate}%">
                                        ${automationRate.toFixed(1)}%
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `);
                });
                
                return rows.join('');
            }

            initializeTestingCharts() {
                // Test Type Distribution
                const typeCtx = document.getElementById('testTypeChart')?.getContext('2d');
                if (typeCtx) {
                    this.charts.testType = new Chart(typeCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Manual', 'Automated'],
                            datasets: [{
                                data: [
                                    this.metrics.testing.manualTests,
                                    this.metrics.testing.automatedTests
                                ],
                                backgroundColor: ['#17a2b8', '#28a745']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }

                // Automation Trend Chart
                const trendCtx = document.getElementById('automationTrendChart')?.getContext('2d');
                if (trendCtx && this.metrics.testing.boardLevelAutomation?.automationGrowth) {
                    const growth = this.metrics.testing.boardLevelAutomation.automationGrowth.slice(-12);
                    
                    this.charts.automationTrend = new Chart(trendCtx, {
                        type: 'line',
                        data: {
                            labels: growth.map(g => g.month),
                            datasets: [{
                                label: 'Automated Tests',
                                data: growth.map(g => g.automated),
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                fill: true
                            }, {
                                label: 'Manual Tests',
                                data: growth.map(g => g.manual),
                                borderColor: '#17a2b8',
                                backgroundColor: 'rgba(23, 162, 184, 0.1)',
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Test Count'
                                    }
                                }
                            }
                        }
                    });
                }
            }

            showTeamPerformance() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.metrics.team) {
                    content.innerHTML = '<div class="alert alert-info">No team data available</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Team Performance</h2>
                    </div>

                    <!-- Team Overview -->
                    <div class="row mb-4">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-users"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.teamSize}</div>
                                <div class="metric-label">Team Members</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-tachometer-alt"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.totalVelocity}</div>
                                <div class="metric-label">Total Velocity</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-percentage"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.utilizationRate}%</div>
                                <div class="metric-label">Utilization Rate</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-balance-scale"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.workloadBalance.toFixed(0)}%</div>
                                <div class="metric-label">Workload Balance</div>
                            </div>
                        </div>
                    </div>

                    <!-- Skill Coverage -->
                    <div class="row mb-4">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Team Skill Coverage</h5>
                                <div class="skill-matrix">
                                    ${this.generateSkillMatrix()}
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Work Distribution -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <div class="metric-card">
                                <h5 class="mb-3">Work Distribution</h5>
                                <div class="chart-container">
                                    <canvas id="workDistributionChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="metric-card">
                                <h5 class="mb-3">Velocity Distribution</h5>
                                <div class="chart-container">
                                    <canvas id="velocityDistributionChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Team Metrics Table -->
                    <div class="row">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="mb-3">Team Contribution Summary</h5>
                                <p class="text-muted">This table shows aggregated team metrics without individual rankings</p>
                                <table class="table" id="teamSummaryTable">
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Total</th>
                                            <th>Average per Person</th>
                                            <th>Team Distribution</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTeamSummaryRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize charts
                this.initializeTeamCharts();
            }

            generateSkillMatrix() {
                const skills = this.metrics.team.skillCoverage;
                const teamSize = this.metrics.team.teamSize;
                
                return Object.entries(skills).map(([skill, count]) => {
                    const percentage = (count / teamSize) * 100;
                    return `
                        <div class="skill-badge">
                            <div class="skill-level">${percentage.toFixed(0)}%</div>
                            <div class="skill-name">${skill.charAt(0).toUpperCase() + skill.slice(1)}</div>
                        </div>
                    `;
                }).join('');
            }

            generateTeamSummaryRows() {
                const team = this.metrics.team;
                const members = Array.from(team.members.values());
                
                const totals = {
                    stories: members.reduce((sum, m) => sum + m.stories, 0),
                    points: members.reduce((sum, m) => sum + m.points, 0),
                    tasks: members.reduce((sum, m) => sum + m.tasks, 0),
                    bugsResolved: members.reduce((sum, m) => sum + m.bugsResolved, 0),
                    testCasesCreated: members.reduce((sum, m) => sum + m.testCasesCreated, 0),
                    testCasesExecuted: members.reduce((sum, m) => sum + m.testCasesExecuted, 0)
                };

                const rows = [
                    {
                        metric: 'User Stories',
                        total: totals.stories,
                        avg: (totals.stories / team.teamSize).toFixed(1),
                        icon: 'tasks'
                    },
                    {
                        metric: 'Story Points',
                        total: totals.points,
                        avg: (totals.points / team.teamSize).toFixed(1),
                        icon: 'chart-line'
                    },
                    {
                        metric: 'Tasks Completed',
                        total: totals.tasks,
                        avg: (totals.tasks / team.teamSize).toFixed(1),
                        icon: 'check-square'
                    },
                    {
                        metric: 'Bugs Resolved',
                        total: totals.bugsResolved,
                        avg: (totals.bugsResolved / team.teamSize).toFixed(1),
                        icon: 'bug'
                    },
                    {
                        metric: 'Test Cases Created',
                        total: totals.testCasesCreated,
                        avg: (totals.testCasesCreated / team.teamSize).toFixed(1),
                        icon: 'vial'
                    },
                    {
                        metric: 'Test Cases Executed',
                        total: totals.testCasesExecuted,
                        avg: (totals.testCasesExecuted / team.teamSize).toFixed(1),
                        icon: 'play-circle'
                    }
                ];

                return rows.map(row => `
                    <tr>
                        <td>
                            <i class="fas fa-${row.icon} text-primary me-2"></i>
                            ${row.metric}
                        </td>
                        <td><strong>${row.total}</strong></td>
                        <td>${row.avg}</td>
                        <td>
                            <div class="progress" style="height: 20px;">
                                <div class="progress-bar" style="width: 75%"></div>
                            </div>
                        </td>
                    </tr>
                `).join('');
            }

            initializeTeamCharts() {
                // Work Distribution Chart
                const workCtx = document.getElementById('workDistributionChart')?.getContext('2d');
                if (workCtx) {
                    const workTypes = {
                        'Stories': 0,
                        'Tasks': 0,
                        'Bugs': 0,
                        'Testing': 0
                    };

                    this.metrics.team.members.forEach(member => {
                        workTypes.Stories += member.stories;
                        workTypes.Tasks += member.tasks;
                        workTypes.Bugs += member.bugsResolved;
                        workTypes.Testing += member.testCasesExecuted;
                    });

                    this.charts.workDistribution = new Chart(workCtx, {
                        type: 'pie',
                        data: {
                            labels: Object.keys(workTypes),
                            datasets: [{
                                data: Object.values(workTypes),
                                backgroundColor: ['#94196B', '#17a2b8', '#ffc107', '#28a745']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }

                // Velocity Distribution Chart
                const velocityCtx = document.getElementById('velocityDistributionChart')?.getContext('2d');
                if (velocityCtx) {
                    const velocities = Array.from(this.metrics.team.members.values())
                        .map(m => m.completedPoints)
                        .sort((a, b) => b - a);

                    this.charts.velocityDistribution = new Chart(velocityCtx, {
                        type: 'bar',
                        data: {
                            labels: velocities.map((_, i) => `Member ${i + 1}`),
                            datasets: [{
                                label: 'Story Points',
                                data: velocities,
                                backgroundColor: 'rgba(148, 25, 107, 0.8)',
                                borderColor: '#94196B',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
            }

            showIndividualMetrics() {
                const content = document.getElementById('dashboardContent');
                
                if (!this.metrics.individual) {
                    content.innerHTML = '<div class="alert alert-info">No individual data available</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Individual Metrics</h2>
                    </div>

                    <div class="alert alert-info mb-4">
                        <i class="fas fa-info-circle me-2"></i>
                        Individual metrics are shown for personal tracking and 1:1 discussions. 
                        These metrics focus on contributions rather than comparisons.
                    </div>

                    <!-- Individual Contributions Table -->
                    <div class="row">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="mb-3">Individual Contributions</h5>
                                <table class="table table-hover" id="individualTable">
                                    <thead>
                                        <tr>
                                            <th>Team Member</th>
                                            <th>Stories</th>
                                            <th>Points</th>
                                            <th>Tasks</th>
                                            <th>Tests Created</th>
                                            <th>Tests Executed</th>
                                            <th>Bugs Found</th>
                                            <th>Defects Found</th>
                                            <th>Bugs Resolved</th>
                                            <th>WIP</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateIndividualRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Testing Contributions -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Testing Contributions by Individual</h5>
                                <div class="table-responsive">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Tester</th>
                                                <th>Test Cases Created</th>
                                                <th>Test Cases Executed</th>
                                                <th>Pass Rate</th>
                                                <th>Quality Score</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${this.generateTesterRows()}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTable
                $('#individualTable').DataTable({
                    pageLength: 25,
                    order: [[2, 'desc']], // Sort by points by default
                    columnDefs: [
                        { targets: 0, width: '20%' },
                        { targets: '_all', className: 'text-center' }
                    ]
                });
            }

            generateIndividualRows() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => {
                    return `
                        <tr>
                            <td class="text-start"><strong>${name}</strong></td>
                            <td>${data.stories}</td>
                            <td><span class="badge bg-primary">${data.completedPoints}</span> / ${data.points}</td>
                            <td>${data.tasks}</td>
                            <td>${data.testCasesCreated}</td>
                            <td>${data.testCasesExecuted}</td>
                            <td><span class="badge bg-warning">${data.bugsFound}</span></td>
                            <td><span class="badge bg-danger">${data.defectsFound}</span></td>
                            <td><span class="badge bg-success">${data.bugsResolved}</span></td>
                            <td>${data.workInProgress}</td>
                        </tr>
                    `;
                }).join('');
            }

            generateTesterRows() {
                if (!this.metrics.testing?.testExecutionByTester) {
                    return '<tr><td colspan="5" class="text-center">No testing data available</td></tr>';
                }

                return Array.from(this.metrics.testing.testExecutionByTester.entries()).map(([tester, data]) => {
                    const passRate = data.executed > 0 ? (data.passed / data.executed) * 100 : 0;
                    const qualityScore = this.calculateTesterQualityScore(data);
                    
                    return `
                        <tr>
                            <td><strong>${tester}</strong></td>
                            <td>${data.created}</td>
                            <td>${data.executed}</td>
                            <td>
                                <div class="progress" style="height: 20px;">
                                    <div class="progress-bar bg-success" style="width: ${passRate}%">
                                        ${passRate.toFixed(1)}%
                                    </div>
                                </div>
                            </td>
                            <td>
                                <span class="badge bg-${qualityScore >= 80 ? 'success' : qualityScore >= 60 ? 'warning' : 'danger'}">
                                    ${qualityScore}%
                                </span>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            calculateTesterQualityScore(data) {
                // Simple quality score based on test creation and execution
                const creationScore = Math.min(100, data.created * 10);
                const executionScore = Math.min(100, data.executed * 5);
                const passRateScore = data.executed > 0 ? (data.passed / data.executed) * 100 : 0;
                
                return Math.round((creationScore + executionScore + passRateScore) / 3);
            }

            showAIInsights() {
                const content = document.getElementById('dashboardContent');
                
                const insights = this.generateAIInsights();
                
                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">AI-Powered Insights</h2>
                    </div>

                    <div class="ai-insights">
                        <div class="ai-badge">
                            <i class="fas fa-brain"></i>
                            AI Analysis
                        </div>
                        
                        <h4 class="mb-3">Executive Summary</h4>
                        <div class="mb-4">
                            ${insights.summary}
                        </div>

                        <div class="row">
                            <div class="col-md-6">
                                <h5 class="mb-3">Key Achievements</h5>
                                <ul class="list-unstyled">
                                    ${insights.achievements.map(a => `
                                        <li class="mb-2">
                                            <i class="fas fa-check-circle text-success me-2"></i>
                                            ${a}
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h5 class="mb-3">Areas of Concern</h5>
                                <ul class="list-unstyled">
                                    ${insights.concerns.map(c => `
                                        <li class="mb-2">
                                            <i class="fas fa-exclamation-triangle text-warning me-2"></i>
                                            ${c}
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        </div>

                        <h5 class="mt-4 mb-3">Recommendations</h5>
                        <div class="row">
                            ${insights.recommendations.map((rec, i) => `
                                <div class="col-md-4 mb-3">
                                    <div class="card h-100">
                                        <div class="card-body">
                                            <h6 class="card-title text-primary">
                                                <i class="fas fa-lightbulb me-2"></i>
                                                Recommendation ${i + 1}
                                            </h6>
                                            <p class="card-text">${rec}</p>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Story Content Analysis -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Recent Story Highlights</h5>
                                <div class="table-responsive">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Story</th>
                                                <th>Category</th>
                                                <th>Key Points</th>
                                                <th>Business Value</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${this.generateStoryHighlights()}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            generateAIInsights() {
                // Generate insights based on metrics
                const insights = {
                    summary: '',
                    achievements: [],
                    concerns: [],
                    recommendations: []
                };

                // Generate summary
                const health = this.calculateOverallHealth();
                if (health >= 80) {
                    insights.summary = `The project is performing exceptionally well with an overall health score of ${health}%. 
                        The team has delivered ${this.metrics.delivery?.completedStories || 0} stories with 
                        ${this.metrics.delivery?.velocity || 0} story points this iteration.`;
                } else if (health >= 60) {
                    insights.summary = `The project is on track with an overall health score of ${health}%. 
                        There are some areas that need attention to improve overall delivery and quality.`;
                } else {
                    insights.summary = `The project needs immediate attention with a health score of ${health}%. 
                        Several critical areas require intervention to get back on track.`;
                }

                // Achievements
                if (this.metrics.delivery?.completionRate > 80) {
                    insights.achievements.push(`High story completion rate of ${this.metrics.delivery.completionRate.toFixed(1)}%`);
                }
                if (this.metrics.testing?.automationRate > 70) {
                    insights.achievements.push(`Excellent test automation coverage at ${this.metrics.testing.automationRate.toFixed(1)}%`);
                }
                if (this.metrics.quality?.defectEscapeRate < 5) {
                    insights.achievements.push(`Low defect escape rate of ${this.metrics.quality.defectEscapeRate.toFixed(1)}%`);
                }
                if (this.metrics.team?.utilizationRate > 85) {
                    insights.achievements.push(`High team utilization at ${this.metrics.team.utilizationRate}%`);
                }

                // Concerns
                if (this.metrics.quality?.criticalBugs > 5) {
                    insights.concerns.push(`${this.metrics.quality.criticalBugs} critical bugs need immediate attention`);
                }
                if (this.metrics.delivery?.blockedItems > 3) {
                    insights.concerns.push(`${this.metrics.delivery.blockedItems} items are currently blocked`);
                }
                if (this.metrics.testing?.testCoverage < 70) {
                    insights.concerns.push(`Test coverage is below target at ${this.metrics.testing.testCoverage.toFixed(1)}%`);
                }
                if (this.metrics.quality?.meanTimeToResolve > 5) {
                    insights.concerns.push(`Bug resolution time averaging ${this.metrics.quality.meanTimeToResolve} days`);
                }

                // Recommendations
                if (this.metrics.testing?.automationRate < 60) {
                    insights.recommendations.push('Increase test automation efforts to reduce manual testing overhead');
                }
                if (this.metrics.quality?.defectEscapeRate > 10) {
                    insights.recommendations.push('Enhance QA processes to catch more defects before production');
                }
                if (this.metrics.team?.workloadBalance < 70) {
                    insights.recommendations.push('Rebalance work distribution across team members for better efficiency');
                }

                return insights;
            }

            generateStoryHighlights() {
                // Simulate AI-extracted highlights from stories
                const stories = this.currentData.userStories.slice(0, 5);
                
                return stories.map(story => {
                    const title = story.fields['System.Title'] || 'Untitled';
                    const tags = story.fields['System.Tags'] || '';
                    
                    // Simulate category detection
                    let category = 'Feature Enhancement';
                    if (title.toLowerCase().includes('fix') || title.toLowerCase().includes('bug')) {
                        category = 'Bug Fix';
                    } else if (title.toLowerCase().includes('performance')) {
                        category = 'Performance';
                    } else if (title.toLowerCase().includes('security')) {
                        category = 'Security';
                    }
                    
                    // Simulate key points extraction
                    const keyPoints = [
                        'Implementation completed',
                        'Unit tests added',
                        'Documentation updated'
                    ];
                    
                    // Simulate business value
                    const businessValue = ['High', 'Medium', 'Low'][Math.floor(Math.random() * 3)];
                    
                    return `
                        <tr>
                            <td>${this.truncateText(title, 40)}</td>
                            <td><span class="badge bg-primary">${category}</span></td>
                            <td>
                                <ul class="list-unstyled mb-0">
                                    ${keyPoints.map(p => `<li> ${p}</li>`).join('')}
                                </ul>
                            </td>
                            <td>
                                <span class="badge bg-${businessValue === 'High' ? 'success' : businessValue === 'Medium' ? 'warning' : 'secondary'}">
                                    ${businessValue}
                                </span>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            showReports() {
                const content = document.getElementById('dashboardContent');
                
                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Reports</h2>
                    </div>

                    <div class="row">
                        <div class="col-md-4 mb-4">
                            <div class="metric-card h-100">
                                <div class="text-center">
                                    <i class="fas fa-chart-line fa-3x text-primary mb-3"></i>
                                    <h5>Executive Summary</h5>
                                    <p class="text-muted">High-level overview of project health and key metrics</p>
                                    <button class="btn btn-primary" onclick="dashboard.generateReport('executive')">
                                        Generate Report
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-4">
                            <div class="metric-card h-100">
                                <div class="text-center">
                                    <i class="fas fa-tasks fa-3x text-success mb-3"></i>
                                    <h5>Sprint Report</h5>
                                    <p class="text-muted">Detailed sprint analytics and velocity trends</p>
                                    <button class="btn btn-primary" onclick="dashboard.generateReport('sprint')">
                                        Generate Report
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-4">
                            <div class="metric-card h-100">
                                <div class="text-center">
                                    <i class="fas fa-bug fa-3x text-warning mb-3"></i>
                                    <h5>Quality Report</h5>
                                    <p class="text-muted">Bug analysis, defect trends, and quality metrics</p>
                                    <button class="btn btn-primary" onclick="dashboard.generateReport('quality')">
                                        Generate Report
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-4">
                            <div class="metric-card h-100">
                                <div class="text-center">
                                    <i class="fas fa-vial fa-3x text-info mb-3"></i>
                                    <h5>Testing Report</h5>
                                    <p class="text-muted">Test coverage, automation metrics, and execution results</p>
                                    <button class="btn btn-primary" onclick="dashboard.generateReport('testing')">
                                        Generate Report
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-4">
                            <div class="metric-card h-100">
                                <div class="text-center">
                                    <i class="fas fa-users fa-3x text-purple mb-3"></i>
                                    <h5>Team Report</h5>
                                    <p class="text-muted">Team performance and workload distribution</p>
                                    <button class="btn btn-primary" onclick="dashboard.generateReport('team')">
                                        Generate Report
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-4">
                            <div class="metric-card h-100">
                                <div class="text-center">
                                    <i class="fas fa-file-alt fa-3x text-secondary mb-3"></i>
                                    <h5>Custom Report</h5>
                                    <p class="text-muted">Create a custom report with selected metrics</p>
                                    <button class="btn btn-primary" onclick="dashboard.showCustomReportBuilder()">
                                        Build Report
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Recent Reports -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="metric-card">
                                <h5 class="mb-3">Recent Reports</h5>
                                <div class="table-responsive">
                                    <table class="table">
                                        <thead>
                                            <tr>
                                                <th>Report Name</th>
                                                <th>Type</th>
                                                <th>Generated</th>
                                                <th>Format</th>
                                                <th>Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>Monthly Executive Summary</td>
                                                <td><span class="badge bg-primary">Executive</span></td>
                                                <td>${new Date().toLocaleDateString()}</td>
                                                <td>Excel</td>
                                                <td>
                                                    <button class="btn btn-sm btn-outline-primary">
                                                        <i class="fas fa-download"></i> Download
                                                    </button>
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>Sprint ${this.getCurrentSprint()} Analysis</td>
                                                <td><span class="badge bg-success">Sprint</span></td>
                                                <td>${new Date().toLocaleDateString()}</td>
                                                <td>PDF</td>
                                                <td>
                                                    <button class="btn btn-sm btn-outline-primary">
                                                        <i class="fas fa-download"></i> Download
                                                    </button>
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            getCurrentSprint() {
                // Get current sprint name
                const iterations = Array.from(this.metrics.sprint?.iterations?.keys() || []);
                return iterations[iterations.length - 1] || 'Current';
            }

            generateReport(type) {
                this.showLoading(true);
                
                setTimeout(() => {
                    switch (type) {
                        case 'executive':
                            this.generateExecutiveReport();
                            break;
                        case 'sprint':
                            this.generateSprintReport();
                            break;
                        case 'quality':
                            this.generateQualityReport();
                            break;
                        case 'testing':
                            this.generateTestingReport();
                            break;
                        case 'team':
                            this.generateTeamReport();
                            break;
                    }
                    this.showLoading(false);
                    this.showToast(`${type.charAt(0).toUpperCase() + type.slice(1)} report generated successfully`, 'success');
                }, 1000);
            }

            showCustomReportBuilder() {
                // Show custom report builder modal
                this.showToast('Custom report builder coming soon!', 'info');
            }

            // Export functionality
            exportData(format) {
                this.showLoading(true);
                
                setTimeout(() => {
                    switch (format) {
                        case 'excel':
                            this.exportToExcel();
                            break;
                        case 'pdf':
                            this.exportToPDF();
                            break;
                        case 'csv':
                            this.exportToCSV();
                            break;
                        case 'powerbi':
                            this.exportToPowerBI();
                            break;
                    }
                    this.showLoading(false);
                }, 500);
            }

            exportToExcel() {
                // Create workbook
                const wb = XLSX.utils.book_new();

                // Add sheets
                this.addDeliverySheet(wb);
                this.addQualitySheet(wb);
                this.addTestingSheet(wb);
                this.addTeamSheet(wb);

                // Save file
                XLSX.writeFile(wb, `ADO_Metrics_${new Date().toISOString().split('T')[0]}.xlsx`);
                this.showToast('Excel report exported successfully', 'success');
            }

            addDeliverySheet(wb) {
                const data = [
                    ['Delivery Metrics', '', '', ''],
                    ['', '', '', ''],
                    ['Metric', 'Value', 'Target', 'Status'],
                    ['Total Stories', this.metrics.delivery?.totalStories || 0, '-', '-'],
                    ['Completed Stories', this.metrics.delivery?.completedStories || 0, '-', 'Good'],
                    ['Completion Rate', `${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`, '80%', this.metrics.delivery?.completionRate > 80 ? 'Good' : 'Needs Improvement'],
                    ['Story Points Delivered', this.metrics.delivery?.completedPoints || 0, '-', '-'],
                    ['Current Velocity', this.metrics.delivery?.velocity || 0, '-', '-'],
                    ['Average Cycle Time', `${this.metrics.delivery?.averageCycleTime || 0} days`, '< 5 days', this.metrics.delivery?.averageCycleTime < 5 ? 'Good' : 'Needs Improvement'],
                    ['Blocked Items', this.metrics.delivery?.blockedItems || 0, '0', this.metrics.delivery?.blockedItems === 0 ? 'Good' : 'Needs Attention']
                ];

                const ws = XLSX.utils.aoa_to_sheet(data);
                
                // Add some styling
                ws['!cols'] = [{ wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 20 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Delivery Metrics');
            }

            addQualitySheet(wb) {
                const data = [
                    ['Quality Metrics', '', '', ''],
                    ['', '', '', ''],
                    ['Metric', 'Count', 'Severity', 'Environment'],
                    ['Total Bugs (Lower Env)', this.metrics.quality?.totalBugs || 0, '-', 'Dev/QA/UAT'],
                    ['Total Defects (Production)', this.metrics.quality?.totalDefects || 0, '-', 'Production'],
                    ['Critical Bugs', this.metrics.quality?.criticalBugs || 0, 'Critical', '-'],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '-', '-'],
                    ['Mean Time to Resolve', `${this.metrics.quality?.meanTimeToResolve || 0} days`, '-', '-'],
                    ['', '', '', ''],
                    ['Bug Distribution by Environment', '', '', ''],
                    ['Dev', this.metrics.quality?.bugsByEnvironment?.dev || 0, '-', '-'],
                    ['QA', this.metrics.quality?.bugsByEnvironment?.qa || 0, '-', '-'],
                    ['UAT', this.metrics.quality?.bugsByEnvironment?.uat || 0, '-', '-'],
                    ['Production', this.metrics.quality?.bugsByEnvironment?.prod || 0, '-', '-']
                ];

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [{ wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Quality Metrics');
            }

            addTestingSheet(wb) {
                const data = [
                    ['Testing Analytics', '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Overall Metrics', '', '', '', ''],
                    ['Total Test Cases', this.metrics.testing?.totalTestCases || 0, '', '', ''],
                    ['Manual Tests', this.metrics.testing?.manualTests || 0, '', '', ''],
                    ['Automated Tests', this.metrics.testing?.automatedTests || 0, '', '', ''],
                    ['Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['Test Coverage', `${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%`, '', '', ''],
                    ['Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['', '', '', '', ''],
                    ['Test Categories', 'Count', '', '', ''],
                    ['Regression', this.testCategories.regression || 0, '', '', ''],
                    ['Smoke', this.testCategories.smoke || 0, '', '', ''],
                    ['End-to-End', this.testCategories.e2e || 0, '', '', ''],
                    ['API', this.testCategories.api || 0, '', '', ''],
                    ['Integration', this.testCategories.integration || 0, '', '', ''],
                    ['Unit', this.testCategories.unit || 0, '', '', ''],
                    ['', '', '', '', ''],
                    ['Iteration Testing Progress', '', '', '', '']
                ];

                // Add iteration data
                this.metrics.testing?.testsByIteration?.forEach((iterData, iteration) => {
                    data.push([
                        iteration,
                        iterData.total,
                        `Automated: ${iterData.automated}`,
                        `Executed: ${iterData.executed}`,
                        `Pass Rate: ${iterData.executed > 0 ? ((iterData.passed / iterData.executed) * 100).toFixed(1) : 0}%`
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [{ wch: 25 }, { wch: 15 }, { wch: 20 }, { wch: 20 }, { wch: 20 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Testing Analytics');
            }

            addTeamSheet(wb) {
                const data = [
                    ['Team Performance', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Team Overview', '', '', '', '', '', ''],
                    ['Team Size', this.metrics.team?.teamSize || 0, '', '', '', '', ''],
                    ['Total Velocity', this.metrics.team?.totalVelocity || 0, '', '', '', '', ''],
                    ['Average Velocity per Person', this.metrics.team?.averageVelocity?.toFixed(1) || 0, '', '', '', '', ''],
                    ['Utilization Rate', `${this.metrics.team?.utilizationRate || 0}%`, '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Individual Contributions', '', '', '', '', '', ''],
                    ['Team Member', 'Stories', 'Points', 'Tasks', 'Tests Created', 'Tests Executed', 'Bugs Resolved']
                ];

                // Add individual data
                this.metrics.individual?.forEach((memberData, memberName) => {
                    data.push([
                        memberName,
                        memberData.stories,
                        memberData.completedPoints,
                        memberData.tasks,
                        memberData.testCasesCreated,
                        memberData.testCasesExecuted,
                        memberData.bugsResolved
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [{ wch: 25 }, { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 15 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Team Performance');
            }

            exportToPDF() {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // Title
                doc.setFontSize(20);
                doc.setTextColor(148, 25, 107);
                doc.text('ADO Metrics Report', 105, 20, { align: 'center' });
                
                // Date
                doc.setFontSize(12);
                doc.setTextColor(100);
                doc.text(`Generated: ${new Date().toLocaleDateString()}`, 105, 30, { align: 'center' });
                
                // Executive Summary
                doc.setFontSize(16);
                doc.setTextColor(0);
                doc.text('Executive Summary', 20, 50);
                
                doc.setFontSize(12);
                const healthScore = this.calculateOverallHealth();
                doc.text(`Overall Project Health: ${healthScore}%`, 20, 60);
                doc.text(`Sprint Velocity: ${this.metrics.delivery?.velocity || 0} points`, 20, 70);
                doc.text(`Completion Rate: ${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`, 20, 80);
                doc.text(`Test Pass Rate: ${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, 20, 90);
                doc.text(`Active Bugs: ${this.metrics.quality?.totalBugs || 0}`, 20, 100);
                doc.text(`Production Defects: ${this.metrics.quality?.totalDefects || 0}`, 20, 110);
                
                // Add more pages as needed
                doc.addPage();
                
                // Delivery Metrics
                doc.setFontSize(16);
                doc.text('Delivery Metrics', 20, 20);
                
                // Create table
                const deliveryData = [
                    ['Metric', 'Value'],
                    ['Total Stories', this.metrics.delivery?.totalStories || 0],
                    ['Completed Stories', this.metrics.delivery?.completedStories || 0],
                    ['Story Points Delivered', this.metrics.delivery?.completedPoints || 0],
                    ['Average Cycle Time', `${this.metrics.delivery?.averageCycleTime || 0} days`],
                    ['Blocked Items', this.metrics.delivery?.blockedItems || 0]
                ];
                
                doc.autoTable({
                    startY: 30,
                    head: [deliveryData[0]],
                    body: deliveryData.slice(1),
                    theme: 'grid',
                    headStyles: { fillColor: [148, 25, 107] }
                });
                
                // Save the PDF
                doc.save(`ADO_Metrics_Report_${new Date().toISOString().split('T')[0]}.pdf`);
                this.showToast('PDF report exported successfully', 'success');
            }

            exportToCSV() {
                // Combine all metrics into CSV format
                let csv = 'Category,Metric,Value\n';
                
                // Delivery metrics
                csv += `Delivery,Total Stories,${this.metrics.delivery?.totalStories || 0}\n`;
                csv += `Delivery,Completed Stories,${this.metrics.delivery?.completedStories || 0}\n`;
                csv += `Delivery,Completion Rate,${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%\n`;
                csv += `Delivery,Story Points Delivered,${this.metrics.delivery?.completedPoints || 0}\n`;
                csv += `Delivery,Current Velocity,${this.metrics.delivery?.velocity || 0}\n`;
                csv += `Delivery,Average Cycle Time,${this.metrics.delivery?.averageCycleTime || 0} days\n`;
                csv += `Delivery,Blocked Items,${this.metrics.delivery?.blockedItems || 0}\n`;
                
                // Quality metrics
                csv += `Quality,Total Bugs,${this.metrics.quality?.totalBugs || 0}\n`;
                csv += `Quality,Total Defects,${this.metrics.quality?.totalDefects || 0}\n`;
                csv += `Quality,Critical Bugs,${this.metrics.quality?.criticalBugs || 0}\n`;
                csv += `Quality,Defect Escape Rate,${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%\n`;
                csv += `Quality,Mean Time to Resolve,${this.metrics.quality?.meanTimeToResolve || 0} days\n`;
                
                // Testing metrics
                csv += `Testing,Total Test Cases,${this.metrics.testing?.totalTestCases || 0}\n`;
                csv += `Testing,Automation Rate,${this.metrics.testing?.automationRate?.toFixed(1) || 0}%\n`;
                csv += `Testing,Pass Rate,${this.metrics.testing?.passRate?.toFixed(1) || 0}%\n`;
                csv += `Testing,Test Coverage,${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%\n`;
                
                // Team metrics
                csv += `Team,Team Size,${this.metrics.team?.teamSize || 0}\n`;
                csv += `Team,Total Velocity,${this.metrics.team?.totalVelocity || 0}\n`;
                csv += `Team,Utilization Rate,${this.metrics.team?.utilizationRate || 0}%\n`;
                
                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ADO_Metrics_${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                this.showToast('CSV data exported successfully', 'success');
            }

            exportToPowerBI() {
                // Create PowerBI template structure
                const powerBIData = {
                    metadata: {
                        exportDate: new Date().toISOString(),
                        version: '1.0',
                        dataSource: 'ADO Metrics Dashboard'
                    },
                    datasets: {
                        delivery: this.metrics.delivery,
                        quality: this.metrics.quality,
                        testing: this.metrics.testing,
                        team: this.metrics.team,
                        sprint: this.metrics.sprint
                    },
                    relationships: [
                        { from: 'delivery.stories', to: 'testing.testCases' },
                        { from: 'team.members', to: 'delivery.stories' }
                    ]
                };
                
                // Download as JSON for PowerBI import
                const blob = new Blob([JSON.stringify(powerBIData, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ADO_PowerBI_Template_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                this.showToast('PowerBI template exported successfully', 'success');
            }

            // Report generation methods
            generateExecutiveReport() {
                const wb = XLSX.utils.book_new();
                
                // Executive Summary Sheet
                const summaryData = [
                    ['ADO Metrics Executive Report', '', '', ''],
                    [`Generated: ${new Date().toLocaleDateString()}`, '', '', ''],
                    ['', '', '', ''],
                    ['Overall Project Health', `${this.calculateOverallHealth()}%`, '', ''],
                    ['', '', '', ''],
                    ['Key Performance Indicators', '', '', ''],
                    ['Metric', 'Current', 'Target', 'Status'],
                    ['Sprint Velocity', this.metrics.delivery?.velocity || 0, '40', this.getStatus(this.metrics.delivery?.velocity, 40)],
                    ['Story Completion Rate', `${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`, '80%', this.getStatus(this.metrics.delivery?.completionRate, 80)],
                    ['Test Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '70%', this.getStatus(this.metrics.testing?.automationRate, 70)],
                    ['Test Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '95%', this.getStatus(this.metrics.testing?.passRate, 95)],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '<5%', this.getStatus(100 - this.metrics.quality?.defectEscapeRate, 95)],
                    ['Team Utilization', `${this.metrics.team?.utilizationRate || 0}%`, '85%', this.getStatus(this.metrics.team?.utilizationRate, 85)],
                    ['', '', '', ''],
                    ['Risk Areas', '', '', ''],
                    ['Critical Bugs', this.metrics.quality?.criticalBugs || 0, '0', this.metrics.quality?.criticalBugs > 0 ? 'At Risk' : 'Good'],
                    ['Blocked Items', this.metrics.delivery?.blockedItems || 0, '0', this.metrics.delivery?.blockedItems > 0 ? 'At Risk' : 'Good'],
                    ['Production Defects', this.metrics.quality?.totalDefects || 0, '<5', this.metrics.quality?.totalDefects < 5 ? 'Good' : 'At Risk']
                ];

                const ws = XLSX.utils.aoa_to_sheet(summaryData);
                ws['!cols'] = [{ wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }];
                
                // Style the header
                ws['A1'].s = { font: { bold: true, sz: 16 }, fill: { fgColor: { rgb: "94196B" } } };
                
                XLSX.utils.book_append_sheet(wb, ws, 'Executive Summary');
                
                // Add other relevant sheets
                this.addDeliverySheet(wb);
                this.addQualitySheet(wb);
                this.addTestingSheet(wb);
                
                // Save file
                XLSX.writeFile(wb, `Executive_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
            }

            generateSprintReport() {
                const wb = XLSX.utils.book_new();
                
                // Sprint Overview
                const sprintData = [
                    ['Sprint Analytics Report', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleDateString()}`, '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Sprint Overview', '', '', '', ''],
                    ['Current Velocity', this.metrics.sprint?.currentVelocity || 0, '', '', ''],
                    ['Average Velocity', this.metrics.sprint?.averageVelocity || 0, '', '', ''],
                    ['Velocity Trend', this.metrics.sprint?.velocityTrend || 'stable', '', '', ''],
                    ['Capacity Utilization', `${this.metrics.sprint?.capacityUtilization || 0}%`, '', '', ''],
                    ['Sprint Health', `${this.metrics.sprint?.sprintHealth || 0}%`, '', '', ''],
                    ['', '', '', '', ''],
                    ['Sprint Details', '', '', '', ''],
                    ['Iteration', 'Planned Points', 'Completed Points', 'Completion %', 'Status']
                ];

                // Add sprint data
                this.metrics.sprint?.iterations?.forEach((sprint, iteration) => {
                    const completionRate = sprint.points > 0 ? (sprint.completedPoints / sprint.points) * 100 : 0;
                    sprintData.push([
                        iteration,
                        sprint.points,
                        sprint.completedPoints,
                        `${completionRate.toFixed(1)}%`,
                        completionRate >= 80 ? 'Good' : 'Needs Improvement'
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(sprintData);
                ws['!cols'] = [{ wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 20 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Sprint Report');
                
                // Save file
                XLSX.writeFile(wb, `Sprint_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
            }

            generateQualityReport() {
                const wb = XLSX.utils.book_new();
                
                // Quality Overview
                const qualityData = [
                    ['Quality Metrics Report', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleDateString()}`, '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Quality Overview', '', '', '', ''],
                    ['Total Bugs (Lower Environments)', this.metrics.quality?.totalBugs || 0, '', '', ''],
                    ['Total Defects (Production)', this.metrics.quality?.totalDefects || 0, '', '', ''],
                    ['Critical Issues', this.metrics.quality?.criticalBugs + this.metrics.quality?.criticalDefects || 0, '', '', ''],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['Mean Time to Resolve', `${this.metrics.quality?.meanTimeToResolve || 0} days`, '', '', ''],
                    ['Bug Density', this.metrics.quality?.bugDensity?.toFixed(2) || 0, '', '', ''],
                    ['Reopen Rate', `${this.metrics.quality?.reopenRate?.toFixed(1) || 0}%`, '', '', ''],
                    ['', '', '', '', ''],
                    ['Bug Distribution', '', '', '', ''],
                    ['Environment', 'Count', 'Percentage', '', ''],
                    ['Dev', this.metrics.quality?.bugsByEnvironment?.dev || 0, '', '', ''],
                    ['QA', this.metrics.quality?.bugsByEnvironment?.qa || 0, '', '', ''],
                    ['UAT', this.metrics.quality?.bugsByEnvironment?.uat || 0, '', '', ''],
                    ['Production', this.metrics.quality?.bugsByEnvironment?.prod || 0, '', '', ''],
                    ['', '', '', '', ''],
                    ['Severity Distribution', '', '', '', ''],
                    ['Critical', this.metrics.quality?.bugsBySeverity?.critical || 0, '', '', ''],
                    ['High', this.metrics.quality?.bugsBySeverity?.high || 0, '', '', ''],
                    ['Medium', this.metrics.quality?.bugsBySeverity?.medium || 0, '', '', ''],
                    ['Low', this.metrics.quality?.bugsBySeverity?.low || 0, '', '', '']
                ];

                const ws = XLSX.utils.aoa_to_sheet(qualityData);
                ws['!cols'] = [{ wch: 30 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Quality Report');
                
                // Save file
                XLSX.writeFile(wb, `Quality_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
            }

            generateTestingReport() {
                const wb = XLSX.utils.book_new();
                
                // Testing Overview with board-level automation
                const testingData = [
                    ['Testing Analytics Report', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleDateString()}`, '', '', '', '', ''],
                    ['', '', '', '', '', ''],
                    ['Testing Overview', '', '', '', '', ''],
                    ['Total Test Cases', this.metrics.testing?.totalTestCases || 0, '', '', '', ''],
                    ['Manual Tests', this.metrics.testing?.manualTests || 0, '', '', '', ''],
                    ['Automated Tests', this.metrics.testing?.automatedTests || 0, '', '', '', ''],
                    ['Board-Level Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '', '', '', ''],
                    ['Overall Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '', '', '', ''],
                    ['Test Coverage', `${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%`, '', '', '', ''],
                    ['ROI (Hours Saved)', this.metrics.testing?.boardLevelAutomation?.roi || 0, '', '', '', ''],
                    ['', '', '', '', '', ''],
                    ['Test Execution by Iteration', '', '', '', '', ''],
                    ['Iteration', 'Total Tests', 'Automated', 'Executed', 'Passed', 'Pass Rate']
                ];

                // Add iteration testing data
                this.metrics.testing?.testsByIteration?.forEach((data, iteration) => {
                    const passRate = data.executed > 0 ? (data.passed / data.executed) * 100 : 0;
                    testingData.push([
                        iteration,
                        data.total,
                        data.automated,
                        data.executed,
                        data.passed,
                        `${passRate.toFixed(1)}%`
                    ]);
                });

                testingData.push(['', '', '', '', '', '']);
                testingData.push(['Test Categories', 'Count', 'Percentage', '', '', '']);
                
                // Add test categories
                const total = this.metrics.testing?.totalTestCases || 1;
                Object.entries(this.testCategories).forEach(([category, count]) => {
                    testingData.push([
                        category.charAt(0).toUpperCase() + category.slice(1),
                        count,
                        `${((count / total) * 100).toFixed(1)}%`,
                        '', '', ''
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(testingData);
                ws['!cols'] = [{ wch: 25 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Testing Report');
                
                // Save file
                XLSX.writeFile(wb, `Testing_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
            }

            generateTeamReport() {
                const wb = XLSX.utils.book_new();
                
                // Team Overview
                const teamData = [
                    ['Team Performance Report', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleDateString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Team Overview', '', '', '', '', '', ''],
                    ['Team Size', this.metrics.team?.teamSize || 0, '', '', '', '', ''],
                    ['Total Velocity', this.metrics.team?.totalVelocity || 0, '', '', '', '', ''],
                    ['Average Velocity per Person', this.metrics.team?.averageVelocity?.toFixed(1) || 0, '', '', '', '', ''],
                    ['Team Utilization Rate', `${this.metrics.team?.utilizationRate || 0}%`, '', '', '', '', ''],
                    ['Workload Balance Score', `${this.metrics.team?.workloadBalance?.toFixed(0) || 0}%`, '', '', '', '', ''],
                    ['Collaboration Score', `${this.metrics.team?.collaborationScore || 0}%`, '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Individual Contributions (Anonymized)', '', '', '', '', '', ''],
                    ['Member ID', 'Stories', 'Points', 'Tasks', 'Tests Created', 'Tests Executed', 'Quality Score']
                ];

                // Add anonymized individual data
                let memberIndex = 1;
                this.metrics.individual?.forEach((memberData) => {
                    const qualityScore = this.calculateMemberQualityScore(memberData);
                    teamData.push([
                        `Member ${memberIndex}`,
                        memberData.stories,
                        memberData.completedPoints,
                        memberData.tasks,
                        memberData.testCasesCreated,
                        memberData.testCasesExecuted,
                        `${qualityScore}%`
                    ]);
                    memberIndex++;
                });

                const ws = XLSX.utils.aoa_to_sheet(teamData);
                ws['!cols'] = [{ wch: 20 }, { wch: 10 }, { wch: 10 }, { wch: 10 }, { wch: 15 }, { wch: 15 }, { wch: 15 }];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Team Report');
                
                // Save file
                XLSX.writeFile(wb, `Team_Report_${new Date().toISOString().split('T')[0]}.xlsx`);
            }

            calculateMemberQualityScore(memberData) {
                // Calculate a quality score based on various factors
                let score = 50; // Base score
                
                // Positive factors
                if (memberData.completedPoints > 0) score += 10;
                if (memberData.testCasesCreated > 0) score += 10;
                if (memberData.testCasesExecuted > 0) score += 10;
                if (memberData.bugsResolved > 0) score += 10;
                
                // Negative factors
                if (memberData.defectsFound > 0) score -= 5 * memberData.defectsFound;
                
                // Keep score between 0 and 100
                return Math.max(0, Math.min(100, score));
            }

            getStatus(value, target) {
                if (value >= target) return 'Good';
                if (value >= target * 0.8) return 'Warning';
                return 'At Risk';
            }

            // Utility methods
            truncateText(text, maxLength) {
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            showLoading(show) {
                const spinner = document.getElementById('loadingSpinner');
                spinner.style.display = show ? 'block' : 'none';
            }

            showToast(message, type = 'info') {
                const toastContainer = document.getElementById('toastContainer');
                const toastId = `toast-${Date.now()}`;
                
                const toastHtml = `
                    <div id="${toastId}" class="toast" role="alert">
                        <div class="toast-header">
                            <i class="fas fa-${type === 'success' ? 'check-circle text-success' : 
                                             type === 'error' ? 'exclamation-circle text-danger' : 
                                             type === 'warning' ? 'exclamation-triangle text-warning' : 
                                             'info-circle text-info'} me-2"></i>
                            <strong class="me-auto">${type.charAt(0).toUpperCase() + type.slice(1)}</strong>
                            <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
                        </div>
                        <div class="toast-body">
                            ${message}
                        </div>
                    </div>
                `;
                
                toastContainer.insertAdjacentHTML('beforeend', toastHtml);
                
                const toastElement = document.getElementById(toastId);
                const toast = new bootstrap.Toast(toastElement, { autohide: true, delay: 3000 });
                toast.show();
                
                // Remove toast element after it's hidden
                toastElement.addEventListener('hidden.bs.toast', () => {
                    toastElement.remove();
                });
            }

            // Clean up charts when navigating away
            destroyCharts() {
                Object.values(this.charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                this.charts = {};
            }
        }

        // Initialize dashboard
        const dashboard = new ADOMetricsDashboard();
    </script>
</body>
</html>