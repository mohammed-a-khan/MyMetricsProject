<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADO Metrics Command Center</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- DataTables CSS -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/dataTables.bootstrap5.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.3.6/css/buttons.bootstrap5.min.css">

    <style>
        :root {
            --primary-color: #94196B;
            --primary-light: #B64B8C;
            --primary-dark: #6B1050;
            --primary-ultra-light: #F8E8F3;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --light-bg: #f8f9fa;
            --white-bg: #ffffff;
            --card-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--light-bg);
            color: var(--text-primary);
            min-height: 100vh;
            font-size: 11px;
            /* Reduced global font size */
        }

        /* Global Font Size Reductions */
        h1 {
            font-size: 1.5rem;
        }

        h2 {
            font-size: 1.3rem;
        }

        h3 {
            font-size: 1.1rem;
        }

        h4 {
            font-size: 1rem;
        }

        h5 {
            font-size: 0.9rem;
        }

        h6 {
            font-size: 0.8rem;
        }

        .btn {
            font-size: 0.8rem;
            padding: 0.5rem 1rem;
        }

        .form-control,
        .form-select {
            font-size: 0.8rem;
            padding: 0.5rem 0.75rem;
        }

        .table {
            font-size: 0.75rem;
        }

        .table th {
            font-size: 0.7rem;
            padding: 0.5rem;
        }

        .table td {
            padding: 0.4rem;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 260px;
            /* Reduced width */
            background: var(--white-bg);
            padding: 1.5rem 1rem;
            /* Reduced padding */
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
            /* Reduced margin */
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-brand h1 {
            font-size: 1.2rem;
            /* Reduced font size */
            font-weight: 800;
            color: var(--primary-color);
            margin: 0;
            margin-left: 0.8rem;
        }

        .nav-menu {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 0.3rem;
            /* Reduced margin */
        }

        .nav-link {
            display: flex;
            align-items: center;
            padding: 0.7rem 1rem;
            /* Reduced padding */
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 10px;
            /* Reduced border radius */
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            font-size: 0.8rem;
            /* Reduced font size */
        }

        .nav-link:hover {
            color: var(--primary-color);
            background: var(--primary-ultra-light);
            transform: translateX(3px);
            /* Reduced transform */
        }

        .nav-link.active {
            color: var(--white-bg);
            background: linear-gradient(135deg, var(--primary-color), var(--primary-light));
            box-shadow: 0 3px 12px rgba(148, 25, 107, 0.3);
            /* Reduced shadow */
        }

        .nav-link i {
            width: 20px;
            /* Reduced icon width */
            margin-right: 0.8rem;
            font-size: 0.9rem;
            /* Reduced icon size */
        }

        /* Main Content */
        .main-content {
            margin-left: 260px;
            /* Adjusted for reduced sidebar */
            padding: 1.5rem;
            /* Reduced padding */
            min-height: 100vh;
            background-color: var(--light-bg);
        }

        /* Header */
        .page-header {
            background: var(--white-bg);
            border-radius: 15px;
            /* Reduced border radius */
            padding: 1.5rem;
            /* Reduced padding */
            margin-bottom: 1.5rem;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }

        .page-title {
            font-size: 1.8rem;
            /* Reduced font size */
            font-weight: 800;
            margin-bottom: 0.3rem;
            color: var(--primary-color);
        }

        /* Configuration Panel */
        .config-panel {
            background: var(--white-bg);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--card-shadow);
        }

        .form-label {
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 0.3rem;
            font-size: 0.75rem;
            /* Reduced font size */
        }

        /* Area Path and Iteration Selection */
        .area-path-container,
        .iteration-container {
            position: relative;
        }

        .dropdown-menu-custom {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--white-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 3px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: var(--card-shadow);
        }

        .dropdown-menu-custom.show {
            display: block;
        }

        .dropdown-option {
            padding: 0.5rem 0.8rem;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.8rem;
        }

        .dropdown-option:hover {
            background: var(--primary-ultra-light);
        }

        .dropdown-option.selected {
            background: var(--primary-color);
            color: white;
        }

        /* Metric Cards */
        .metric-card {
            background: var(--white-bg);
            border-radius: 15px;
            padding: 1.2rem;
            /* Reduced padding */
            height: 100%;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .metric-card:hover {
            transform: translateY(-3px);
            /* Reduced transform */
            box-shadow: 0 8px 25px rgba(148, 25, 107, 0.15);
            /* Reduced shadow */
        }

        .metric-icon {
            width: 45px;
            /* Reduced size */
            height: 45px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            /* Reduced font size */
            margin-bottom: 0.8rem;
            background: var(--primary-ultra-light);
            color: var(--primary-color);
        }

        .metric-value {
            font-size: 1.8rem;
            /* Reduced font size */
            font-weight: 800;
            margin-bottom: 0.3rem;
            color: var(--primary-color);
        }

        .metric-label {
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 0.7rem;
            /* Reduced font size */
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Tables */
        .data-table-container {
            background: var(--white-bg);
            border-radius: 15px;
            padding: 1.2rem;
            /* Reduced padding */
            margin-bottom: 1.5rem;
            box-shadow: var(--card-shadow);
            overflow-x: auto;
        }

        .table-title {
            font-size: 1rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        .table thead th {
            background: var(--primary-ultra-light);
            color: var(--primary-color);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.65rem;
            /* Reduced font size */
            letter-spacing: 0.5px;
            border: none;
            padding: 0.6rem 0.4rem;
            /* Reduced padding */
        }

        .table tbody tr {
            transition: all 0.3s ease;
        }

        .table tbody tr:hover {
            background: var(--light-bg);
            transform: scale(1.005);
            /* Reduced transform */
        }

        .table tbody td {
            padding: 0.5rem 0.4rem;
            /* Reduced padding */
            border-color: var(--border-color);
            vertical-align: middle;
            font-size: 0.7rem;
            /* Reduced font size */
        }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            /* Reduced padding */
            border-radius: 15px;
            font-size: 0.65rem;
            /* Reduced font size */
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Priority and Severity Indicators */
        .priority-indicator {
            width: 6px;
            /* Reduced size */
            height: 6px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.3rem;
        }

        .severity-badge {
            font-size: 0.65rem;
            /* Reduced font size */
            padding: 0.15rem 0.4rem;
            border-radius: 10px;
            font-weight: 600;
        }

        /* Progress Bars */
        .progress {
            height: 6px;
            /* Reduced height */
            background: var(--light-bg);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-bar {
            background: linear-gradient(90deg, var(--primary-color), var(--primary-light));
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            transition: width 0.6s ease;
        }

        /* Loading Spinner */
        .loading-spinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: var(--card-shadow);
        }

        .spinner {
            width: 50px;
            /* Reduced size */
            height: 50px;
            border: 3px solid var(--primary-ultra-light);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Section Headers */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            /* Reduced margin */
            padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 1.2rem;
            /* Reduced font size */
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Error and Info Messages */
        .error-container {
            background: #fff5f5;
            border: 1px solid #fed7d7;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            color: #c53030;
        }

        .info-container {
            background: #ebf8ff;
            border: 1px solid #bee3f8;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            color: #2b6cb0;
        }

        /* DataTables Customization */
        .dataTables_wrapper .dataTables_length select {
            font-size: 0.75rem;
        }

        .dataTables_wrapper .dataTables_filter input {
            font-size: 0.75rem;
        }

        .dataTables_wrapper .dataTables_info {
            font-size: 0.7rem;
        }

        .dataTables_wrapper .dataTables_paginate .paginate_button {
            font-size: 0.7rem;
            padding: 0.3rem 0.6rem;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                width: 240px;
                /* Reduced mobile width */
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
                padding: 1rem;
                /* Reduced mobile padding */
            }

            .page-title {
                font-size: 1.4rem;
                /* Reduced mobile font size */
            }

            .metric-value {
                font-size: 1.5rem;
                /* Reduced mobile font size */
            }
        }

        /* Test Tags */
        .test-tag {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            /* Reduced padding */
            margin: 0.05rem;
            /* Reduced margin */
            border-radius: 12px;
            font-size: 0.65rem;
            /* Reduced font size */
            font-weight: 600;
        }

        /* Environment Badge */
        .env-badge {
            padding: 0.15rem 0.5rem;
            /* Reduced padding */
            border-radius: 12px;
            font-size: 0.65rem;
            /* Reduced font size */
            font-weight: 600;
        }

        /* Connection Status Indicator */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            box-shadow: var(--card-shadow);
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .connection-status.testing {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        #dateRangeContainer {
            transition: all 0.3s ease;
        }

        #dateRangeContainer .alert {
            border-radius: 8px;
            border: 1px solid #bee5eb;
            background-color: #d1ecf1;
            color: #0c5460;
        }

        #customStartDate,
        #customEndDate {
            font-size: 0.8rem;
        }

        .date-range-info {
            background: var(--primary-ultra-light);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 1rem;
        }
    </style>
</head>

<body>
    <!-- Connection Status -->
    <div id="connectionStatus" class="connection-status disconnected">
        <i class="fas fa-circle me-1"></i>
        <span id="connectionText">Disconnected</span>
    </div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loadingSpinner">
        <div class="spinner"></div>
        <div class="mt-2 text-center">
            <small id="loadingText">Loading data...</small>
        </div>
    </div>

    <!-- Sidebar Navigation -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-brand">
            <i class="fas fa-chart-line fa-2x" style="color: var(--primary-color);"></i>
            <h1>ADO Metrics</h1>
        </div>

        <nav>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="#" class="nav-link active" data-page="dashboard">
                        <i class="fas fa-tachometer-alt"></i>
                        <span>Dashboard</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="delivery">
                        <i class="fas fa-tasks"></i>
                        <span>Delivery Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="quality">
                        <i class="fas fa-bug"></i>
                        <span>Quality Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="testing">
                        <i class="fas fa-vial"></i>
                        <span>Testing Analytics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="team">
                        <i class="fas fa-users"></i>
                        <span>Team Performance</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="individual">
                        <i class="fas fa-user-check"></i>
                        <span>Individual Metrics</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a href="#" class="nav-link" data-page="reports">
                        <i class="fas fa-file-alt"></i>
                        <span>Reports</span>
                    </a>
                </li>
                <li class="nav-item mt-3 pt-3 border-top">
                    <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#settingsModal">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </a>
                </li>
            </ul>
        </nav>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Page Header -->
        <div class="page-header">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="page-title">ADO Metrics Command Center</h1>
                    <p class="text-secondary mb-0" style="font-size: 0.8rem;">Real-time project analytics and insights
                    </p>
                </div>
                <div class="col-md-4 text-end">
                    <button class="btn btn-primary" id="exportButton">
                        <i class="fas fa-download me-1"></i>Export
                    </button>
                    <button class="btn btn-outline-primary ms-2" id="refreshButton">
                        <i class="fas fa-sync-alt me-1"></i>Refresh
                    </button>
                </div>
            </div>
        </div>

        <!-- Configuration Panel -->
        <div class="config-panel">
            <div class="row g-3">
                <div class="col-md-3">
                    <label class="form-label">Area Path</label>
                    <div class="area-path-container">
                        <input type="text" class="form-control" id="areaPathInput" placeholder="Select area path..."
                            readonly>
                        <div class="dropdown-menu-custom" id="areaPathDropdown">
                            <!-- Area path options will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Iteration</label>
                    <div class="iteration-container">
                        <input type="text" class="form-control" id="iterationInput" placeholder="Select iteration..."
                            readonly>
                        <div class="dropdown-menu-custom" id="iterationDropdown">
                            <!-- Iteration options will be populated here -->
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Test Plan (Optional)</label>
                    <select class="form-select" id="testPlanSelect">
                        <option value="">No test plan selected</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Data Range</label>
                    <select class="form-select" id="dataRangeSelect">
                        <option value="current">Current Period</option>
                        <option value="last30">Last 30 Days</option>
                        <option value="last90">Last 90 Days</option>
                        <option value="custom">Custom Range</option>
                    </select>
                </div>
                <!-- Date range container will be dynamically added here -->
                <div class="col-12" id="dateRangeContainer">
                    <!-- Dynamic date range fields will appear here -->
                </div>
                <div class="col-12 mt-3">
                    <button class="btn btn-primary" id="loadDataButton">
                        <i class="fas fa-sync-alt me-1"></i>Load Data
                    </button>
                    <button class="btn btn-outline-secondary ms-2" id="testConnectionButton">
                        <i class="fas fa-plug me-1"></i>Test Connection
                    </button>
                </div>
            </div>
        </div>

        <!-- Dashboard Content -->
        <div id="dashboardContent">
            <!-- Content will be dynamically loaded here -->
        </div>
    </main>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Configuration Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <h6 class="mb-3">ADO Connection</h6>
                    <div class="row g-3 mb-4">
                        <div class="col-md-6">
                            <label class="form-label">Organization</label>
                            <input type="text" class="form-control" id="adoOrganization"
                                placeholder="your-organization">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Project</label>
                            <input type="text" class="form-control" id="adoProject" placeholder="your-project">
                        </div>
                        <div class="col-12">
                            <label class="form-label">Personal Access Token</label>
                            <input type="password" class="form-control" id="adoPAT" placeholder="Enter your PAT">
                            <small class="text-muted">Your PAT is stored securely in browser storage</small>
                        </div>
                    </div>

                    <h6 class="mb-3">Proxy Configuration (Optional)</h6>
                    <div class="row g-3">
                        <div class="col-md-8">
                            <label class="form-label">Proxy Server</label>
                            <input type="text" class="form-control" id="proxyServer" placeholder="proxy.company.com">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Port</label>
                            <input type="number" class="form-control" id="proxyPort" placeholder="8080">
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveSettingsButton">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.4/js/dataTables.bootstrap5.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.3.6/js/dataTables.buttons.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.3.6/js/buttons.bootstrap5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // ADO Metrics Dashboard - Complete Production Implementation
        class ADOMetricsDashboard {
            constructor() {
                this.config = this.loadConfiguration();
                this.selectedAreaPath = null;
                this.selectedIteration = null;
                this.selectedTestPlan = null;
                this.currentData = null;
                this.areaPaths = [];
                this.iterations = [];
                this.testPlans = [];
                this.connectionStatus = 'disconnected';
                this.dataTables = {};
                this.metrics = {
                    delivery: {},
                    quality: {},
                    testing: {},
                    team: {},
                    individual: new Map(),
                    workItems: []
                };
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.loadSavedSettings();
                this.updateConnectionStatus('disconnected');
                this.showInitialState();

                // Auto-load if settings are configured
                if (this.config.organization && this.config.project && this.config.pat) {
                    this.testConnection();
                }
            }

            loadConfiguration() {
                const savedConfig = localStorage.getItem('adoConfig');
                return savedConfig ? JSON.parse(savedConfig) : {
                    organization: '',
                    project: '',
                    pat: '',
                    proxy: { server: '', port: '' }
                };
            }

            saveConfiguration() {
                localStorage.setItem('adoConfig', JSON.stringify(this.config));
            }

            loadSavedSettings() {
                document.getElementById('adoOrganization').value = this.config.organization || '';
                document.getElementById('adoProject').value = this.config.project || '';
                document.getElementById('adoPAT').value = this.config.pat || '';
                document.getElementById('proxyServer').value = this.config.proxy?.server || '';
                document.getElementById('proxyPort').value = this.config.proxy?.port || '';
            }

            setupEventListeners() {
                // Navigation
                document.querySelectorAll('.nav-link[data-page]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const page = e.currentTarget.dataset.page;
                        this.navigateToPage(page);
                    });
                });

                // Area Path Selection
                document.getElementById('areaPathInput').addEventListener('click', () => {
                    this.toggleDropdown('areaPathDropdown');
                });

                // Iteration Selection
                document.getElementById('iterationInput').addEventListener('click', () => {
                    this.toggleDropdown('iterationDropdown');
                });

                // Test Plan Selection
                document.getElementById('testPlanSelect').addEventListener('change', (e) => {
                    this.selectedTestPlan = e.target.value;
                });

                // Buttons
                document.getElementById('loadDataButton').addEventListener('click', () => {
                    this.loadData();
                });

                document.getElementById('testConnectionButton').addEventListener('click', () => {
                    this.testConnection();
                });

                document.getElementById('refreshButton').addEventListener('click', () => {
                    this.loadData();
                });

                document.getElementById('saveSettingsButton').addEventListener('click', () => {
                    this.saveSettings();
                });

                document.getElementById('dataRangeSelect').addEventListener('change', (e) => {
                    this.updateDateRangeOptions(e.target.value);
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.area-path-container')) {
                        document.getElementById('areaPathDropdown').classList.remove('show');
                    }
                    if (!e.target.closest('.iteration-container')) {
                        document.getElementById('iterationDropdown').classList.remove('show');
                    }
                });
            }

            updateConnectionStatus(status, message = '') {
                this.connectionStatus = status;
                const statusElement = document.getElementById('connectionStatus');
                const textElement = document.getElementById('connectionText');

                statusElement.className = `connection-status ${status}`;

                switch (status) {
                    case 'connected':
                        textElement.innerHTML = '<i class="fas fa-check-circle me-1"></i>Connected';
                        break;
                    case 'testing':
                        textElement.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Testing...';
                        break;
                    case 'disconnected':
                    default:
                        textElement.innerHTML = '<i class="fas fa-times-circle me-1"></i>Disconnected';
                        break;
                }

                if (message) {
                    setTimeout(() => this.showToast(message, status === 'connected' ? 'success' : 'error'), 500);
                }
            }

            updateDateRangeOptions(rangeType) {
                // Find or create the date range container
                let dateRangeContainer = document.getElementById('dateRangeContainer');

                if (!dateRangeContainer) {
                    // Create the container if it doesn't exist
                    const configPanel = document.querySelector('.config-panel .row');
                    const newCol = document.createElement('div');
                    newCol.className = 'col-md-12 mt-3';
                    newCol.id = 'dateRangeContainer';
                    configPanel.appendChild(newCol);
                    dateRangeContainer = newCol;
                }

                // Clear existing content
                dateRangeContainer.innerHTML = '';

                if (rangeType === 'custom') {
                    dateRangeContainer.innerHTML = `
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Start Date</label>
                    <input type="date" class="form-control" id="customStartDate" 
                           value="${this.getDefaultStartDate()}">
                </div>
                <div class="col-md-6">
                    <label class="form-label">End Date</label>
                    <input type="date" class="form-control" id="customEndDate" 
                           value="${this.getDefaultEndDate()}">
                </div>
            </div>
        `;
                } else {
                    // Show the selected range info for other options
                    const rangeInfo = this.getDateRangeInfo(rangeType);
                    if (rangeInfo) {
                        dateRangeContainer.innerHTML = `
                <div class="alert alert-info" style="margin-bottom: 0; padding: 0.75rem; font-size: 0.8rem;">
                    <i class="fas fa-calendar-alt me-2"></i>
                    <strong>${rangeInfo.label}:</strong> ${rangeInfo.description}
                </div>
            `;
                    }
                }
            }


            getDefaultStartDate() {
                const date = new Date();
                date.setMonth(date.getMonth() - 1); // 1 month ago
                return date.toISOString().split('T')[0];
            }

            getDefaultEndDate() {
                const date = new Date();
                return date.toISOString().split('T')[0];
            }

            getDateRangeInfo(rangeType) {
                const endDate = new Date();
                let startDate = new Date();

                switch (rangeType) {
                    case 'current':
                        return {
                            label: 'Current Period',
                            description: 'Based on selected iteration or last 30 days if no iteration selected'
                        };
                    case 'last30':
                        startDate.setDate(endDate.getDate() - 30);
                        return {
                            label: 'Last 30 Days',
                            description: `${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`
                        };
                    case 'last90':
                        startDate.setDate(endDate.getDate() - 90);
                        return {
                            label: 'Last 90 Days',
                            description: `${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}`
                        };
                    default:
                        return null;
                }
            }

            getSelectedDateRange() {
                const rangeType = document.getElementById('dataRangeSelect').value;
                const endDate = new Date();
                let startDate = new Date();

                switch (rangeType) {
                    case 'current':
                        // Use iteration dates if available, otherwise last 30 days
                        if (this.selectedIteration && this.selectedIteration.startDate) {
                            return {
                                start: this.selectedIteration.startDate,
                                end: this.selectedIteration.finishDate || endDate,
                                type: 'iteration'
                            };
                        } else {
                            startDate.setDate(endDate.getDate() - 30);
                            return {
                                start: startDate,
                                end: endDate,
                                type: 'relative'
                            };
                        }

                    case 'last30':
                        startDate.setDate(endDate.getDate() - 30);
                        return {
                            start: startDate,
                            end: endDate,
                            type: 'relative'
                        };

                    case 'last90':
                        startDate.setDate(endDate.getDate() - 90);
                        return {
                            start: startDate,
                            end: endDate,
                            type: 'relative'
                        };

                    case 'custom':
                        const customStart = document.getElementById('customStartDate')?.value;
                        const customEnd = document.getElementById('customEndDate')?.value;

                        if (!customStart || !customEnd) {
                            throw new Error('Please select both start and end dates for custom range');
                        }

                        return {
                            start: new Date(customStart),
                            end: new Date(customEnd),
                            type: 'custom'
                        };

                    default:
                        startDate.setDate(endDate.getDate() - 30);
                        return {
                            start: startDate,
                            end: endDate,
                            type: 'default'
                        };
                }
            }

            // Add enhanced work items loading with date range:
            async loadWorkItemsWithDateRange(dateRange) {
                try {
                    // Build WIQL query
                    let whereConditions = [`[System.TeamProject] = '${this.config.project}'`];

                    // Add area path filter
                    if (this.selectedAreaPath) {
                        if (this.selectedAreaPath.subAreas && this.selectedAreaPath.subAreas.length > 1) {
                            // Multiple sub-areas under this team, use UNDER parent path
                            whereConditions.push(`[System.AreaPath] UNDER '${this.selectedAreaPath.parentPath}'`);
                        } else if (this.selectedAreaPath.subAreas && this.selectedAreaPath.subAreas.length === 1) {
                            // Single sub-area, use specific path
                            whereConditions.push(`[System.AreaPath] UNDER '${this.selectedAreaPath.subAreas[0].fullPath}'`);
                        } else {
                            // Fallback to parent path
                            whereConditions.push(`[System.AreaPath] UNDER '${this.selectedAreaPath.parentPath}'`);
                        }
                    }

                    // Add iteration filter (only if not using custom date range)
                    if (dateRange.type !== 'custom' && dateRange.type !== 'relative') {
                        if (this.selectedIteration) {
                            if (this.selectedIteration.fullPath === '@currentIteration') {
                                whereConditions.push(`[System.IterationPath] UNDER @currentIteration`);
                            } else {
                                whereConditions.push(`[System.IterationPath] = '${this.selectedIteration.fullPath}'`);
                            }
                        }
                    }

                    // Add date range filter
                    if (dateRange.type === 'custom' || dateRange.type === 'relative') {
                        const startDateStr = dateRange.start.toISOString().split('T')[0];
                        const endDateStr = dateRange.end.toISOString().split('T')[0];

                        // Use changed date for broader coverage
                        whereConditions.push(`[System.ChangedDate] >= '${startDateStr}'`);
                        whereConditions.push(`[System.ChangedDate] <= '${endDateStr}T23:59:59.999Z'`);
                    }

                    // Add work item type filter
                    whereConditions.push(`[System.WorkItemType] IN ('User Story', 'Bug', 'Task', 'Feature', 'Epic', 'Product Backlog Item', 'Test Case')`);

                    const query = `SELECT [System.Id] FROM WorkItems WHERE ${whereConditions.join(' AND ')} ORDER BY [System.ChangedDate] DESC`;

                    console.log('WIQL Query with date range:', query);
                    console.log('Date range:', dateRange);

                    const wiql = { query };
                    const queryResult = await this.makeADORequest('wit/wiql?$top=200&api-version=7.0', 'POST', wiql);

                    if (!queryResult.workItems || queryResult.workItems.length === 0) {
                        return [];
                    }

                    // Get work item details in batches
                    const allWorkItems = [];
                    const batchSize = 200;

                    for (let i = 0; i < queryResult.workItems.length; i += batchSize) {
                        const batch = queryResult.workItems.slice(i, i + batchSize);
                        const ids = batch.map(wi => wi.id).join(',');

                        try {
                            const workItemsResponse = await this.makeADORequest(
                                `wit/workitems?ids=${ids}&$expand=relations&api-version=7.0`
                            );
                            allWorkItems.push(...(workItemsResponse.value || []));
                        } catch (error) {
                            console.error('Error fetching work item batch:', error);
                        }
                    }

                    return allWorkItems;
                } catch (error) {
                    console.error('Error in loadWorkItemsWithDateRange:', error);
                    throw error;
                }
            }

            async testConnection() {
                if (!this.config.organization || !this.config.project || !this.config.pat) {
                    this.showToast('Please configure your ADO settings first', 'warning');
                    document.querySelector('[data-bs-target="#settingsModal"]').click();
                    return;
                }

                this.updateConnectionStatus('testing');

                try {
                    // Test with organization-level projects endpoint first
                    const projectsResponse = await this.makeADORequest('projects?api-version=7.0');

                    if (projectsResponse && projectsResponse.value) {
                        // Verify the specified project exists
                        const projectExists = projectsResponse.value.some(p =>
                            p.name.toLowerCase() === this.config.project.toLowerCase()
                        );

                        if (!projectExists) {
                            throw new Error(`Project '${this.config.project}' not found in organization '${this.config.organization}'`);
                        }

                        // Test project-level access with a simple endpoint
                        try {
                            await this.makeADORequest('wit/classificationnodes?api-version=7.0');
                            this.updateConnectionStatus('connected', 'Successfully connected to ADO');
                            await this.loadInitialData();
                        } catch (projectError) {
                            throw new Error(`Cannot access project '${this.config.project}': ${projectError.message}`);
                        }
                    } else {
                        throw new Error('Invalid response from ADO');
                    }
                } catch (error) {
                    console.error('Connection test failed:', error);
                    let errorMessage = error.message;

                    // Provide more helpful error messages
                    if (error.message.includes('404')) {
                        if (error.message.includes('projects')) {
                            errorMessage = `Organization '${this.config.organization}' not found or PAT doesn't have access`;
                        } else {
                            errorMessage = `Project '${this.config.project}' not found or no access`;
                        }
                    } else if (error.message.includes('401')) {
                        errorMessage = 'Invalid Personal Access Token or insufficient permissions';
                    } else if (error.message.includes('403')) {
                        errorMessage = 'Access denied. Check PAT permissions for the organization/project';
                    }

                    this.updateConnectionStatus('disconnected', `Connection failed: ${errorMessage}`);
                }
            }

            async loadInitialData() {
                try {
                    this.showLoading(true, 'Loading area paths and iterations...');

                    // Load area paths
                    await this.loadAreaPaths();

                    // Load iterations
                    await this.loadIterations();

                    // Load test plans
                    await this.loadTestPlans();

                    this.showLoading(false);
                } catch (error) {
                    console.error('Error loading initial data:', error);
                    this.showLoading(false);
                    this.showToast('Error loading initial data', 'error');
                }
            }

            async loadAreaPaths() {
                try {
                    const response = await this.makeADORequest('wit/classificationnodes/areas?$depth=3&api-version=7.0');
                    this.areaPaths = this.extractAreaPaths(response);
                    this.populateAreaPathDropdown();
                } catch (error) {
                    console.error('Error loading area paths:', error);
                    this.showToast('Error loading area paths', 'error');
                }
            }

            extractAreaPaths(response) {
                const paths = [];

                const extractRecursive = (node, parentPath = '') => {
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => {
                            const currentPath = parentPath ? `${parentPath}\\${child.name}` : child.name;

                            if (child.children && child.children.length > 0) {
                                // Show the parent team name (child) in dropdown, but store all sub-areas for filtering
                                child.children.forEach(grandChild => {
                                    const fullPath = `${currentPath}\\${grandChild.name}`;
                                    paths.push({
                                        id: grandChild.id,
                                        name: grandChild.name,
                                        fullPath: `${response.name}\\Area\\${fullPath}`,
                                        displayName: child.name, // Show parent team name
                                        parentPath: `${response.name}\\Area\\${currentPath}`, // Store parent path for filtering
                                        leafName: grandChild.name
                                    });
                                });
                            } else {
                                paths.push({
                                    id: child.id,
                                    name: child.name,
                                    fullPath: `${response.name}\\Area\\${currentPath}`,
                                    displayName: child.name,
                                    parentPath: `${response.name}\\Area\\${currentPath}`,
                                    leafName: child.name
                                });
                            }
                        });
                    }
                };

                extractRecursive(response);
                
                // Group by displayName to avoid duplicates and combine all paths under same team
                const groupedPaths = new Map();
                paths.forEach(path => {
                    if (!groupedPaths.has(path.displayName)) {
                        groupedPaths.set(path.displayName, {
                            id: path.id,
                            name: path.name,
                            displayName: path.displayName,
                            parentPath: path.parentPath,
                            subAreas: []
                        });
                    }
                    groupedPaths.get(path.displayName).subAreas.push({
                        name: path.leafName,
                        fullPath: path.fullPath
                    });
                });

                return Array.from(groupedPaths.values());
            }

            populateAreaPathDropdown() {
                const dropdown = document.getElementById('areaPathDropdown');
                dropdown.innerHTML = '';

                this.areaPaths.forEach(areaPath => {
                    const div = document.createElement('div');
                    div.className = 'dropdown-option';
                    div.textContent = areaPath.displayName;
                    div.addEventListener('click', () => {
                        this.selectAreaPath(areaPath);
                    });
                    dropdown.appendChild(div);
                });
            }

            selectAreaPath(areaPath) {
                this.selectedAreaPath = areaPath;
                document.getElementById('areaPathInput').value = areaPath.displayName;
                document.getElementById('areaPathDropdown').classList.remove('show');

                // Filter test plans by area path
                this.filterTestPlansByAreaPath();
            }

            async loadIterations() {
                try {
                    const response = await this.makeADORequest('wit/classificationnodes/iterations?$depth=3&api-version=7.0');
                    this.iterations = this.extractIterations(response);
                    this.populateIterationDropdown();
                } catch (error) {
                    console.error('Error loading iterations:', error);
                    this.showToast('Error loading iterations', 'error');
                }
            }

            extractIterations(response) {
                const iterations = [];

                const extractRecursive = (node, parentPath = '') => {
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(child => {
                            if (child.children && child.children.length > 0) {
                                child.children.forEach(grandChild => {
                                    if (grandChild.children && grandChild.children.length > 0) {
                                        grandChild.children.forEach(iteration => {
                                            if (iteration.attributes && iteration.attributes.startDate) {
                                                iterations.push({
                                                    id: iteration.id,
                                                    name: iteration.name,
                                                    fullPath: iteration.path,
                                                    startDate: new Date(iteration.attributes.startDate),
                                                    finishDate: new Date(iteration.attributes.finishDate),
                                                    displayName: iteration.name
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                };

                extractRecursive(response);

                // Sort by start date (latest first)
                iterations.sort((a, b) => b.startDate - a.startDate);

                return iterations;
            }

            populateIterationDropdown() {
                const dropdown = document.getElementById('iterationDropdown');
                dropdown.innerHTML = '';

                // Add current iteration option
                const currentDiv = document.createElement('div');
                currentDiv.className = 'dropdown-option';
                currentDiv.textContent = 'Current Iteration';
                currentDiv.addEventListener('click', () => {
                    this.selectIteration({ name: '@currentIteration', displayName: 'Current Iteration', fullPath: '@currentIteration' });
                });
                dropdown.appendChild(currentDiv);

                this.iterations.forEach(iteration => {
                    const div = document.createElement('div');
                    div.className = 'dropdown-option';
                    div.textContent = iteration.displayName;
                    div.addEventListener('click', () => {
                        this.selectIteration(iteration);
                    });
                    dropdown.appendChild(div);
                });
            }

            selectIteration(iteration) {
                this.selectedIteration = iteration;
                document.getElementById('iterationInput').value = iteration.displayName;
                document.getElementById('iterationDropdown').classList.remove('show');
            }

            async loadTestPlans() {
                try {
                    const response = await this.makeADORequest('testplan/plans?api-version=7.0');
                    this.testPlans = response.value || [];
                    this.populateTestPlansDropdown();
                } catch (error) {
                    console.error('Error loading test plans:', error);
                    // Don't show error for test plans as they're optional
                }
            }

            populateTestPlansDropdown() {
                const select = document.getElementById('testPlanSelect');
                select.innerHTML = '<option value="">No test plan selected</option>';

                this.testPlans.forEach(plan => {
                    const option = document.createElement('option');
                    option.value = plan.id;
                    option.textContent = plan.name;
                    select.appendChild(option);
                });
            }

            filterTestPlansByAreaPath() {
                if (!this.selectedAreaPath) return;

                const select = document.getElementById('testPlanSelect');
                select.innerHTML = '<option value="">No test plan selected</option>';

                const filteredPlans = this.testPlans.filter(plan => {
                    if (!plan.areaPath) return false;
                    
                    // Check if test plan area path matches any of the sub-areas under selected team
                    if (this.selectedAreaPath.subAreas) {
                        return this.selectedAreaPath.subAreas.some(subArea => 
                            plan.areaPath.includes(subArea.name) || 
                            plan.areaPath.includes(this.selectedAreaPath.displayName)
                        );
                    }
                    
                    return plan.areaPath.includes(this.selectedAreaPath.displayName) || 
                           plan.areaPath.includes(this.selectedAreaPath.name);
                });

                filteredPlans.forEach(plan => {
                    const option = document.createElement('option');
                    option.value = plan.id;
                    option.textContent = plan.name;
                    select.appendChild(option);
                });

                // Show message if test plans are now filtered
                if (this.testPlans.length > 0 && filteredPlans.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = `No test plans found for ${this.selectedAreaPath.displayName}`;
                    option.disabled = true;
                    select.appendChild(option);
                }
            }

            toggleDropdown(dropdownId) {
                document.getElementById(dropdownId).classList.toggle('show');
            }

            async makeADORequest(endpoint, method = 'GET', body = null) {
                const baseUrl = `https://dev.azure.com/${this.config.organization}`;

                // Determine if this is an organization-level or project-level endpoint
                let url;
                if (endpoint.includes('projects') && !endpoint.includes(this.config.project)) {
                    // Organization-level endpoints (like projects list)
                    url = endpoint.startsWith('http') ? endpoint : `${baseUrl}/_apis/${endpoint}`;
                } else {
                    // Project-level endpoints
                    url = endpoint.startsWith('http') ? endpoint : `${baseUrl}/${this.config.project}/_apis/${endpoint}`;
                }

                const headers = {
                    'Authorization': `Basic ${btoa(`:${this.config.pat}`)}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                };

                try {
                    console.log('Making request to:', url); // Debug log

                    const response = await fetch(url, {
                        method,
                        headers,
                        body: body ? JSON.stringify(body) : null
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`ADO API Error: ${response.status} - ${errorText}`);
                        throw new Error(`ADO API Error: ${response.status} - ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error('ADO Request Error:', error);
                    throw error;
                }
            }

            async loadData() {
                if (!this.selectedAreaPath) {
                    this.showToast('Please select an area path', 'warning');
                    return;
                }

                if (!this.selectedIteration) {
                    this.showToast('Please select an iteration', 'warning');
                    return;
                }

                this.showLoading(true, 'Loading work items...');

                try {
                    // Get date range based on selection
                    const dateRange = this.getSelectedDateRange();

                    // Build WIQL query with proper filtering
                    const workItems = await this.loadWorkItemsWithDateRange(dateRange);

                    if (workItems.length === 0) {
                        this.showToast('No work items found for the selected criteria', 'info');
                        this.showNoDataMessage();
                        return;
                    }

                    // Process and categorize work items
                    this.currentData = await this.processWorkItems(workItems);

                    // Calculate all metrics
                    this.calculateAllMetrics();

                    // Update current page
                    const activePage = document.querySelector('.nav-link.active')?.dataset.page || 'dashboard';
                    this.navigateToPage(activePage);

                    this.showToast(`Loaded ${workItems.length} work items successfully`, 'success');

                } catch (error) {
                    console.error('Error loading data:', error);
                    this.showToast(`Error loading data: ${error.message}`, 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            calculateSprintVelocity() {
                const stories = this.currentData.userStories || [];
                const iterations = new Map();

                // Group stories by iteration and calculate real velocity
                stories.forEach(story => {
                    const iterationPath = story.fields['System.IterationPath'];
                    const state = story.fields['System.State'];
                    const storyPoints = story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;
                    const createdDate = new Date(story.fields['System.CreatedDate']);
                    const changedDate = new Date(story.fields['System.ChangedDate']);
                    const completedDate = story.fields['Microsoft.VSTS.Common.ClosedDate'] ?
                        new Date(story.fields['Microsoft.VSTS.Common.ClosedDate']) : null;

                    if (!iterations.has(iterationPath)) {
                        iterations.set(iterationPath, {
                            name: iterationPath,
                            plannedPoints: 0,
                            completedPoints: 0,
                            plannedStories: 0,
                            completedStories: 0,
                            carryOverPoints: 0,
                            addedMidIterationPoints: 0,
                            scopeChangeCount: 0,
                            averageCycleTime: 0,
                            stories: []
                        });
                    }

                    const iteration = iterations.get(iterationPath);
                    iteration.stories.push(story);
                    iteration.plannedPoints += storyPoints;
                    iteration.plannedStories++;

                    // Check if story was completed in this iteration
                    if (['Done', 'Closed', 'Resolved'].includes(state)) {
                        iteration.completedPoints += storyPoints;
                        iteration.completedStories++;
                    }

                    // Calculate if story was added mid-iteration (simplified heuristic)
                    if (this.selectedIteration && this.selectedIteration.startDate) {
                        const iterationStart = new Date(this.selectedIteration.startDate);
                        if (createdDate > iterationStart) {
                            iteration.addedMidIterationPoints += storyPoints;
                            iteration.scopeChangeCount++;
                        }
                    }
                });

                // Calculate velocity trends and predictability
                const velocityHistory = Array.from(iterations.values())
                    .filter(iter => iter.completedPoints > 0)
                    .map(iter => iter.completedPoints)
                    .slice(-6); // Last 6 iterations

                const averageVelocity = velocityHistory.length > 0 ?
                    velocityHistory.reduce((sum, v) => sum + v, 0) / velocityHistory.length : 0;

                // Calculate velocity variance for predictability
                const velocityVariance = velocityHistory.length > 1 ?
                    velocityHistory.reduce((sum, v) => sum + Math.pow(v - averageVelocity, 2), 0) / velocityHistory.length : 0;

                const velocityStdDev = Math.sqrt(velocityVariance);
                const predictabilityScore = averageVelocity > 0 ?
                    Math.max(0, 100 - (velocityStdDev / averageVelocity) * 100) : 0;

                return {
                    iterations,
                    currentVelocity: Array.from(iterations.values())[0]?.completedPoints || 0,
                    averageVelocity: Math.round(averageVelocity),
                    velocityHistory,
                    predictabilityScore: Math.round(predictabilityScore),
                    velocityTrend: this.calculateVelocityTrend(velocityHistory),
                    totalScopeChanges: Array.from(iterations.values()).reduce((sum, iter) => sum + iter.scopeChangeCount, 0)
                };
            }

            calculateVelocityTrend(velocityHistory) {
                if (!velocityHistory || velocityHistory.length < 3) {
                    return 'insufficient-data';
                }

                // Use linear regression to determine trend
                const n = velocityHistory.length;
                const x = Array.from({ length: n }, (_, i) => i + 1);
                const y = velocityHistory;

                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
                const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);

                const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                // Calculate R-squared for trend strength
                const yMean = sumY / n;
                const totalSumSquares = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);
                const residualSumSquares = y.reduce((sum, yi, i) => {
                    const predicted = slope * x[i] + intercept;
                    return sum + Math.pow(yi - predicted, 2);
                }, 0);

                const rSquared = totalSumSquares > 0 ? 1 - (residualSumSquares / totalSumSquares) : 0;

                // Determine trend based on slope and strength
                if (rSquared < 0.3) {
                    return 'volatile'; // Low correlation, trend not reliable
                } else if (slope > 2) {
                    return 'strong-increasing';
                } else if (slope > 0.5) {
                    return 'increasing';
                } else if (slope < -2) {
                    return 'strong-decreasing';
                } else if (slope < -0.5) {
                    return 'decreasing';
                } else {
                    return 'stable';
                }
            }

            // ADD these new helper methods that are referenced above:

            calculateMedian(values) {
                if (!values || values.length === 0) return 0;

                const sorted = [...values].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);

                return sorted.length % 2 === 0 ?
                    (sorted[mid - 1] + sorted[mid]) / 2 :
                    sorted[mid];
            }

            createEmptyIndividualMetrics() {
                return {
                    workItems: {
                        created: 0,
                        assigned: 0,
                        completed: 0,
                        inProgress: 0
                    },
                    storyPoints: {
                        assigned: 0,
                        completed: 0,
                        average: 0
                    },
                    workTypes: {
                        stories: 0,
                        features: 0,
                        tasks: 0,
                        bugs: 0,
                        testCases: 0
                    },
                    quality: {
                        bugsCreated: 0,
                        bugsResolved: 0,
                        defectsCreated: 0,
                        testCasesCreated: 0,
                        testCasesExecuted: 0
                    },
                    timing: {
                        averageCycleTime: 0,
                        averageLeadTime: 0
                    },
                    collaboration: {
                        workItemsShared: 0,
                        commentsGiven: 0,
                        commentsReceived: 0
                    },
                    performanceScore: 0,
                    qualityScore: 0,
                    velocityTrend: 'stable',
                    workloadBalance: 0
                };
            }

            updateIndividualMetrics(metrics, item, role) {
                const workItemType = item.fields['System.WorkItemType'];
                const state = item.fields['System.State'];
                const storyPoints = item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;

                if (role === 'assignee') {
                    metrics.workItems.assigned++;
                    metrics.storyPoints.assigned += storyPoints;

                    if (['Done', 'Closed', 'Resolved'].includes(state)) {
                        metrics.workItems.completed++;
                        metrics.storyPoints.completed += storyPoints;
                    } else if (['Active', 'In Progress'].includes(state)) {
                        metrics.workItems.inProgress++;
                    }
                } else if (role === 'creator') {
                    metrics.workItems.created++;
                }

                // Update work type counts
                switch (workItemType) {
                    case 'User Story':
                    case 'Product Backlog Item':
                        metrics.workTypes.stories++;
                        break;
                    case 'Feature':
                        metrics.workTypes.features++;
                        break;
                    case 'Task':
                        metrics.workTypes.tasks++;
                        break;
                    case 'Bug':
                        if (role === 'creator') {
                            if (this.isProductionIssue(item)) {
                                metrics.quality.defectsCreated++;
                            } else {
                                metrics.quality.bugsCreated++;
                            }
                        } else if (role === 'assignee') {
                            metrics.quality.bugsResolved++;
                        }
                        metrics.workTypes.bugs++;
                        break;
                    case 'Test Case':
                        if (role === 'creator') {
                            metrics.quality.testCasesCreated++;
                        }
                        if (role === 'assignee' && ['Closed', 'Resolved'].includes(state)) {
                            metrics.quality.testCasesExecuted++;
                        }
                        metrics.workTypes.testCases++;
                        break;
                }
            }

            calculatePerformanceScore(metrics) {
                let score = 0;
                let maxScore = 0;

                // Delivery performance (40% weight)
                const deliveryWeight = 40;
                if (metrics.workItems.assigned > 0) {
                    const completionRate = (metrics.workItems.completed / metrics.workItems.assigned) * 100;
                    score += (completionRate / 100) * deliveryWeight;
                }
                maxScore += deliveryWeight;

                // Quality performance (30% weight)
                const qualityWeight = 30;
                const qualityFactor = Math.max(0, 1 - (metrics.quality.bugsCreated * 0.1) - (metrics.quality.defectsCreated * 0.3));
                score += qualityFactor * qualityWeight;
                maxScore += qualityWeight;

                // Velocity performance (20% weight)
                const velocityWeight = 20;
                if (metrics.storyPoints.assigned > 0) {
                    const velocityScore = Math.min(100, (metrics.storyPoints.completed / metrics.storyPoints.assigned) * 100);
                    score += (velocityScore / 100) * velocityWeight;
                }
                maxScore += velocityWeight;

                // Collaboration performance (10% weight)
                const collaborationWeight = 10;
                const collaborationScore = Math.min(100,
                    (metrics.quality.testCasesCreated * 10) +
                    (metrics.quality.bugsResolved * 5)
                );
                score += (collaborationScore / 100) * collaborationWeight;
                maxScore += collaborationWeight;

                return maxScore > 0 ? Math.round((score / maxScore) * 100) : 0;
            }

            calculateQualityScore(metrics) {
                let score = 100; // Start with perfect score

                // Penalize for bugs created
                score -= metrics.quality.bugsCreated * 5;

                // Heavy penalty for production defects
                score -= metrics.quality.defectsCreated * 20;

                // Reward for bugs resolved
                score += metrics.quality.bugsResolved * 3;

                // Reward for test cases created
                score += metrics.quality.testCasesCreated * 2;

                // Reward for test execution
                score += metrics.quality.testCasesExecuted * 1;

                return Math.max(0, Math.min(100, Math.round(score)));
            }

            calculateIndividualVelocityTrend(metrics) {
                // Simplified trend calculation for individual
                if (metrics.storyPoints.assigned === 0) return 'no-data';

                const completionRate = (metrics.storyPoints.completed / metrics.storyPoints.assigned) * 100;

                if (completionRate >= 90) return 'excellent';
                if (completionRate >= 70) return 'good';
                if (completionRate >= 50) return 'average';
                return 'needs-improvement';
            }

            calculateWorkloadBalance(metrics) {
                // Calculate individual workload balance
                const totalWork = metrics.workItems.assigned;
                const inProgress = metrics.workItems.inProgress;

                if (totalWork === 0) return 100;

                const wipRatio = inProgress / totalWork;

                // Ideal WIP ratio is around 20-30%
                if (wipRatio >= 0.2 && wipRatio <= 0.3) return 100;
                if (wipRatio < 0.2) return 80; // Under-utilized
                if (wipRatio > 0.5) return 40; // Overloaded
                return 60;
            }

            calculateSkillCoverage(teamMap) {
                const skills = {
                    development: 0,
                    testing: 0,
                    bugFixing: 0,
                    requirements: 0
                };

                teamMap.forEach(member => {
                    if (member.stories > 0) skills.development++;
                    if (member.testCasesCreated > 0 || member.testCasesExecuted > 0) skills.testing++;
                    if (member.bugs > 0) skills.bugFixing++;
                    if (member.stories > 0) skills.requirements++;
                });

                return skills;
            }

            calculateTeamWorkloadBalance(teamMap) {
                const workloads = [];
                teamMap.forEach(member => {
                    workloads.push(member.workInProgress || 0);
                });

                if (workloads.length === 0) return 100;

                const avg = workloads.reduce((a, b) => a + b, 0) / workloads.length;
                if (avg === 0) return 100;

                const variance = workloads.reduce((sum, load) => sum + Math.pow(load - avg, 2), 0) / workloads.length;
                const stdDev = Math.sqrt(variance);

                // Lower standard deviation means better balance
                return Math.max(0, 100 - (stdDev / avg) * 100);
            }

            calculateCollaborationScore(individualMetrics) {
                // Calculate team collaboration based on individual contributions
                let totalCollaboration = 0;
                let memberCount = 0;

                individualMetrics.forEach(metrics => {
                    const collabScore = (metrics.quality.testCasesCreated * 2) +
                        (metrics.quality.bugsResolved * 3) +
                        (metrics.collaboration.commentsGiven * 1);
                    totalCollaboration += Math.min(100, collabScore);
                    memberCount++;
                });

                return memberCount > 0 ? Math.round(totalCollaboration / memberCount) : 0;
            }

            calculateQualityTrend(issues) {
                // Group issues by week for trending
                const weeklyData = new Map();

                issues.forEach(issue => {
                    const createdDate = new Date(issue.fields['System.CreatedDate']);
                    const weekStart = new Date(createdDate);
                    weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // Start of week
                    const weekKey = weekStart.toISOString().split('T')[0];

                    if (!weeklyData.has(weekKey)) {
                        weeklyData.set(weekKey, {
                            bugs: 0,
                            defects: 0,
                            critical: 0,
                            resolved: 0
                        });
                    }

                    const weekData = weeklyData.get(weekKey);

                    if (this.isProductionIssue(issue)) {
                        weekData.defects++;
                    } else {
                        weekData.bugs++;
                    }

                    const severity = issue.fields['Microsoft.VSTS.Common.Severity'] || '';
                    if (severity.includes('1') || severity.toLowerCase().includes('critical')) {
                        weekData.critical++;
                    }

                    if (['Resolved', 'Closed'].includes(issue.fields['System.State'])) {
                        weekData.resolved++;
                    }
                });

                // Convert to array and sort by date
                const trendData = Array.from(weeklyData.entries())
                    .map(([week, data]) => ({ week, ...data }))
                    .sort((a, b) => new Date(a.week) - new Date(b.week))
                    .slice(-12); // Last 12 weeks

                // Calculate trend direction
                const recentWeeks = trendData.slice(-4);
                const olderWeeks = trendData.slice(-8, -4);

                const recentAverage = recentWeeks.length > 0 ?
                    recentWeeks.reduce((sum, week) => sum + week.bugs + week.defects, 0) / recentWeeks.length : 0;
                const olderAverage = olderWeeks.length > 0 ?
                    olderWeeks.reduce((sum, week) => sum + week.bugs + week.defects, 0) / olderWeeks.length : 0;

                let trendDirection = 'stable';
                if (recentAverage > olderAverage * 1.2) {
                    trendDirection = 'worsening';
                } else if (recentAverage < olderAverage * 0.8) {
                    trendDirection = 'improving';
                }

                return {
                    weeklyData: trendData,
                    trendDirection,
                    recentAverage: Math.round(recentAverage),
                    changeFromPrevious: olderAverage > 0 ? ((recentAverage - olderAverage) / olderAverage) * 100 : 0
                };
            }

            async loadWorkItems() {
                try {
                    // Build WIQL query
                    let whereConditions = [`[System.TeamProject] = '${this.config.project}'`];

                    // Add area path filter
                    if (this.selectedAreaPath) {
                        if (this.selectedAreaPath.subAreas && this.selectedAreaPath.subAreas.length > 1) {
                            // Multiple sub-areas under this team, use UNDER parent path
                            whereConditions.push(`[System.AreaPath] UNDER '${this.selectedAreaPath.parentPath}'`);
                        } else if (this.selectedAreaPath.subAreas && this.selectedAreaPath.subAreas.length === 1) {
                            // Single sub-area, use specific path
                            whereConditions.push(`[System.AreaPath] UNDER '${this.selectedAreaPath.subAreas[0].fullPath}'`);
                        } else {
                            // Fallback to parent path
                            whereConditions.push(`[System.AreaPath] UNDER '${this.selectedAreaPath.parentPath}'`);
                        }
                    }

                    // Add iteration filter
                    if (this.selectedIteration) {
                        if (this.selectedIteration.fullPath === '@currentIteration') {
                            whereConditions.push(`[System.IterationPath] UNDER @currentIteration`);
                        } else {
                            whereConditions.push(`[System.IterationPath] = '${this.selectedIteration.fullPath}'`);
                        }
                    }

                    // Add work item type filter
                    whereConditions.push(`[System.WorkItemType] IN ('User Story', 'Bug', 'Task', 'Feature', 'Epic', 'Product Backlog Item', 'Test Case')`);

                    const query = `SELECT [System.Id] FROM WorkItems WHERE ${whereConditions.join(' AND ')} ORDER BY [System.ChangedDate] DESC`;

                    console.log('WIQL Query:', query);

                    const wiql = { query };
                    const queryResult = await this.makeADORequest('wit/wiql?$top=200&api-version=7.0', 'POST', wiql);

                    if (!queryResult.workItems || queryResult.workItems.length === 0) {
                        return [];
                    }

                    // Get work item details in batches
                    const allWorkItems = [];
                    const batchSize = 200;

                    for (let i = 0; i < queryResult.workItems.length; i += batchSize) {
                        const batch = queryResult.workItems.slice(i, i + batchSize);
                        const ids = batch.map(wi => wi.id).join(',');

                        try {
                            const workItemsResponse = await this.makeADORequest(
                                `wit/workitems?ids=${ids}&$expand=relations&api-version=7.0`
                            );
                            allWorkItems.push(...(workItemsResponse.value || []));
                        } catch (error) {
                            console.error('Error fetching work item batch:', error);
                        }
                    }

                    return allWorkItems;
                } catch (error) {
                    console.error('Error in loadWorkItems:', error);
                    throw error;
                }
            }

            async processWorkItems(workItems) {
                const data = {
                    workItems: workItems,
                    userStories: [],
                    features: [],
                    epics: [],
                    tasks: [],
                    bugs: [],
                    defects: [],
                    testCases: [],
                    testTasks: []
                };

                // Categorize work items
                for (const item of workItems) {
                    const type = item.fields['System.WorkItemType'];
                    const title = (item.fields['System.Title'] || '').toLowerCase();

                    switch (type) {
                        case 'User Story':
                        case 'Product Backlog Item':
                            data.userStories.push(item);
                            break;
                        case 'Feature':
                            data.features.push(item);
                            break;
                        case 'Epic':
                            data.epics.push(item);
                            break;
                        case 'Task':
                            if (this.isTestingTask(title)) {
                                data.testTasks.push(item);
                            }
                            data.tasks.push(item);
                            break;
                        case 'Bug':
                            if (this.isProductionIssue(item)) {
                                data.defects.push(item);
                            } else {
                                data.bugs.push(item);
                            }
                            break;
                        case 'Test Case':
                            data.testCases.push(item);
                            break;
                    }
                }

                // Load additional test data if test plan is selected
                if (this.selectedTestPlan) {
                    try {
                        const testData = await this.loadTestPlanData(this.selectedTestPlan);
                        data.testCases = [...data.testCases, ...testData.testCases];
                    } catch (error) {
                        console.warn('Error loading test plan data:', error);
                    }
                }

                return data;
            }

            async loadTestPlanData(testPlanId) {
                try {
                    const testPlanResults = {
                        testCases: [],
                        testSuites: [],
                        testRuns: [],
                        testResults: []
                    };

                    // Get test plan details
                    const testPlan = await this.makeADORequest(`testplan/Plans/${testPlanId}?api-version=7.0`);

                    // Get all test suites in the test plan
                    const suitesResponse = await this.makeADORequest(`testplan/Plans/${testPlanId}/suites?api-version=7.0`);
                    testPlanResults.testSuites = suitesResponse.value || [];

                    // Get test cases from all suites
                    for (const suite of testPlanResults.testSuites) {
                        try {
                            // Get test cases in this suite
                            const testCasesResponse = await this.makeADORequest(
                                `testplan/Plans/${testPlanId}/Suites/${suite.id}/TestCase?api-version=7.0`
                            );

                            if (testCasesResponse.value) {
                                // Get detailed test case information
                                for (const testCaseRef of testCasesResponse.value) {
                                    try {
                                        const testCaseDetail = await this.makeADORequest(
                                            `wit/workitems/${testCaseRef.workItem.id}?$expand=relations&api-version=7.0`
                                        );

                                        // Add suite information to test case
                                        testCaseDetail.suiteId = suite.id;
                                        testCaseDetail.suiteName = suite.name;
                                        testCaseDetail.testPlanId = testPlanId;

                                        testPlanResults.testCases.push(testCaseDetail);
                                    } catch (tcError) {
                                        console.warn(`Error loading test case ${testCaseRef.workItem.id}:`, tcError);
                                    }
                                }
                            }
                        } catch (suiteError) {
                            console.warn(`Error loading test cases for suite ${suite.id}:`, suiteError);
                        }
                    }

                    // Get test runs for this test plan
                    try {
                        const testRunsResponse = await this.makeADORequest(
                            `test/runs?planId=${testPlanId}&api-version=7.0`
                        );
                        testPlanResults.testRuns = testRunsResponse.value || [];

                        // Get test results for each run
                        for (const testRun of testPlanResults.testRuns.slice(0, 10)) { // Limit to recent 10 runs
                            try {
                                const resultsResponse = await this.makeADORequest(
                                    `test/Runs/${testRun.id}/results?api-version=7.0`
                                );

                                if (resultsResponse.value) {
                                    testPlanResults.testResults.push(...resultsResponse.value.map(result => ({
                                        ...result,
                                        testRunId: testRun.id,
                                        testRunName: testRun.name,
                                        testPlanId: testPlanId
                                    })));
                                }
                            } catch (resultError) {
                                console.warn(`Error loading results for test run ${testRun.id}:`, resultError);
                            }
                        }
                    } catch (runError) {
                        console.warn(`Error loading test runs for plan ${testPlanId}:`, runError);
                    }

                    return testPlanResults;
                } catch (error) {
                    console.error('Error loading test plan data:', error);
                    throw error;
                }
            }

            isTestingTask(title) {
                const testingKeywords = [
                    'sit testing', 'sit-testing', 'sit_testing',
                    'uat testing', 'uat-testing', 'uat_testing',
                    'test execution', 'test case', 'testing',
                    'qa testing', 'quality assurance', 'regression test',
                    'smoke test', 'integration test'
                ];
                return testingKeywords.some(keyword => title.includes(keyword));
            }

            isProductionIssue(bug) {
                const tags = (bug.fields['System.Tags'] || '').toLowerCase();
                const areaPath = (bug.fields['System.AreaPath'] || '').toLowerCase();
                const title = (bug.fields['System.Title'] || '').toLowerCase();

                return tags.includes('production') || tags.includes('prod') ||
                    areaPath.includes('production') || areaPath.includes('prod') ||
                    title.includes('production') || title.includes('prod') ||
                    tags.includes('hotfix') || title.includes('hotfix');
            }

            calculateAllMetrics() {
                this.calculateDeliveryMetrics();
                this.calculateQualityMetrics();
                this.calculateTestingMetrics();
                this.calculateTeamMetrics();
                this.calculateIndividualMetrics();
            }

            calculateDeliveryMetrics() {
                const stories = this.currentData.userStories;
                const features = this.currentData.features;
                const epics = this.currentData.epics;
                const tasks = this.currentData.tasks;

                const completedStories = stories.filter(s =>
                    ['Done', 'Closed', 'Resolved'].includes(s.fields['System.State'])
                );

                const totalPoints = stories.reduce((sum, s) =>
                    sum + (s.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0
                );

                const completedPoints = completedStories.reduce((sum, s) =>
                    sum + (s.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0
                );

                const blockedItems = this.currentData.workItems.filter(item => {
                    const tags = (item.fields['System.Tags'] || '').toLowerCase();
                    const state = item.fields['System.State'];
                    return tags.includes('blocked') || tags.includes('impediment') || state === 'Blocked';
                }).length;

                this.metrics.delivery = {
                    totalStories: stories.length,
                    completedStories: completedStories.length,
                    totalFeatures: features.length,
                    completedFeatures: features.filter(f => ['Done', 'Closed', 'Resolved'].includes(f.fields['System.State'])).length,
                    totalEpics: epics.length,
                    completedEpics: epics.filter(e => ['Done', 'Closed', 'Resolved'].includes(e.fields['System.State'])).length,
                    totalTasks: tasks.length,
                    completedTasks: tasks.filter(t => ['Done', 'Closed', 'Resolved'].includes(t.fields['System.State'])).length,
                    totalPoints,
                    completedPoints,
                    completionRate: stories.length > 0 ? (completedStories.length / stories.length) * 100 : 0,
                    velocity: completedPoints,
                    blockedItems,
                    workInProgress: stories.filter(s => ['Active', 'In Progress'].includes(s.fields['System.State'])).length
                };
            }

            calculateQualityMetrics() {
                if (!this.currentData) return;

                const bugs = this.currentData.bugs || [];
                const defects = this.currentData.defects || [];
                const allIssues = [...bugs, ...defects];

                // Real bug density calculation per story point and per KLOC
                const totalStoryPoints = (this.currentData.userStories || []).reduce((sum, story) =>
                    sum + (story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0);

                const completedStoryPoints = (this.currentData.userStories || [])
                    .filter(story => ['Done', 'Closed', 'Resolved'].includes(story.fields['System.State']))
                    .reduce((sum, story) => sum + (story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0), 0);

                // Calculate bug injection rate (bugs found per completed work)
                const bugInjectionRate = completedStoryPoints > 0 ? bugs.length / completedStoryPoints : 0;

                // Calculate defect leakage (production defects per completed work)
                const defectLeakageRate = completedStoryPoints > 0 ? defects.length / completedStoryPoints : 0;

                // Real escape rate calculation
                const totalIssuesFound = bugs.length + defects.length;
                const defectEscapeRate = totalIssuesFound > 0 ? (defects.length / totalIssuesFound) * 100 : 0;

                // Categorize by severity and priority
                const severityCount = { critical: 0, high: 0, medium: 0, low: 0 };
                const priorityCount = { 1: 0, 2: 0, 3: 0, 4: 0 };
                const environmentCount = { dev: 0, qa: 0, uat: 0, prod: 0 };

                // Calculate mean time to detection and resolution
                const resolutionTimes = [];
                const reopenedIssues = [];

                allIssues.forEach(issue => {
                    const severity = issue.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    const priority = issue.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const env = this.detectEnvironment(issue);
                    const createdDate = new Date(issue.fields['System.CreatedDate']);
                    const state = issue.fields['System.State'];

                    if (severity.includes('1') || severity.toLowerCase().includes('critical')) severityCount.critical++;
                    else if (severity.includes('2') || severity.toLowerCase().includes('high')) severityCount.high++;
                    else if (severity.includes('3') || severity.toLowerCase().includes('medium')) severityCount.medium++;
                    else severityCount.low++;

                    priorityCount[priority] = (priorityCount[priority] || 0) + 1;
                    environmentCount[env] = (environmentCount[env] || 0) + 1;

                    // Resolution time calculation
                    if (['Resolved', 'Closed', 'Done'].includes(state)) {
                        const resolvedDate = issue.fields['Microsoft.VSTS.Common.ResolvedDate'] ?
                            new Date(issue.fields['Microsoft.VSTS.Common.ResolvedDate']) :
                            new Date(issue.fields['System.ChangedDate']);

                        const resolutionDays = (resolvedDate - createdDate) / (1000 * 60 * 60 * 24);
                        if (resolutionDays >= 0 && resolutionDays < 365) {
                            resolutionTimes.push(resolutionDays);
                        }
                    }

                    // Check for reopened issues
                    const history = issue.fields['System.History'] || '';
                    if (history.toLowerCase().includes('reopen') ||
                        (issue.fields['Microsoft.VSTS.Common.ResolvedReason'] === 'Fixed' &&
                            !['Resolved', 'Closed'].includes(state))) {
                        reopenedIssues.push(issue);
                    }
                });

                this.metrics.quality = {
                    totalBugs: bugs.length,
                    totalDefects: defects.length,
                    criticalBugs: severityCount.critical,
                    highBugs: severityCount.high,
                    bugsByEnvironment: environmentCount,
                    bugsBySeverity: severityCount,
                    bugsByPriority: priorityCount,
                    defectEscapeRate: defectEscapeRate,
                    bugDensity: {
                        perStoryPoint: totalStoryPoints > 0 ? (bugs.length / totalStoryPoints) : 0,
                        perCompletedStoryPoint: completedStoryPoints > 0 ? (bugs.length / completedStoryPoints) : 0
                    },
                    defectLeakage: {
                        rate: defectLeakageRate,
                        count: defects.length
                    },
                    resolutionMetrics: {
                        meanTimeToResolve: resolutionTimes.length > 0 ?
                            resolutionTimes.reduce((sum, time) => sum + time, 0) / resolutionTimes.length : 0,
                        medianTimeToResolve: this.calculateMedian(resolutionTimes),
                        reopenRate: allIssues.length > 0 ? (reopenedIssues.length / allIssues.length) * 100 : 0,
                        reopenedCount: reopenedIssues.length
                    },
                    bugInjectionRate,
                    qualityTrend: this.calculateQualityTrend(allIssues)
                };
            }

            detectEnvironment(bug) {
                const tags = (bug.fields['System.Tags'] || '').toLowerCase();
                const areaPath = (bug.fields['System.AreaPath'] || '').toLowerCase();
                const title = (bug.fields['System.Title'] || '').toLowerCase();

                if (tags.includes('production') || areaPath.includes('production') || title.includes('production')) return 'prod';
                if (tags.includes('uat') || areaPath.includes('uat') || title.includes('uat')) return 'uat';
                if (tags.includes('qa') || areaPath.includes('qa') || title.includes('qa')) return 'qa';
                return 'dev';
            }

            calculateTestingMetrics() {
                if (!this.currentData) return;

                const testCases = this.currentData.testCases || [];
                const testTasks = this.currentData.testTasks || [];
                const stories = this.currentData.userStories || [];

                const automationMetrics = {
                    total: testCases.length,
                    automated: 0,
                    manual: 0,
                    semiAutomated: 0,
                    automationByCategory: {
                        unit: { total: 0, automated: 0 },
                        integration: { total: 0, automated: 0 },
                        e2e: { total: 0, automated: 0 },
                        api: { total: 0, automated: 0 },
                        ui: { total: 0, automated: 0 },
                        performance: { total: 0, automated: 0 },
                        security: { total: 0, automated: 0 }
                    },
                    executionMetrics: {
                        automated: { executed: 0, passed: 0, failed: 0, blocked: 0 },
                        manual: { executed: 0, passed: 0, failed: 0, blocked: 0 }
                    },
                    testCategories: {
                        manual: 0,
                        automated: 0,
                        regression: 0,
                        smoke: 0,
                        e2e: 0,
                        api: 0,
                        integration: 0,
                        unit: 0
                    }
                };

                let executedTests = 0;
                let passedTests = 0;
                let failedTests = 0;

                testCases.forEach(testCase => {
                    const tags = (testCase.fields['System.Tags'] || '').toLowerCase();
                    const title = (testCase.fields['System.Title'] || '').toLowerCase();
                    const state = testCase.fields['System.State'];

                    // Determine automation status
                    let automationType = 'manual';
                    if (tags.includes('automated') || tags.includes('auto')) {
                        automationType = 'automated';
                        automationMetrics.automated++;
                        automationMetrics.testCategories.automated++;
                    } else if (tags.includes('semi-automated') || tags.includes('hybrid')) {
                        automationType = 'semiAutomated';
                        automationMetrics.semiAutomated++;
                    } else {
                        automationMetrics.manual++;
                        automationMetrics.testCategories.manual++;
                    }

                    // Categorize by test type
                    const categories = ['unit', 'integration', 'e2e', 'api', 'ui', 'performance', 'security'];
                    categories.forEach(category => {
                        if (tags.includes(category) || title.includes(category)) {
                            automationMetrics.automationByCategory[category].total++;
                            if (automationType === 'automated') {
                                automationMetrics.automationByCategory[category].automated++;
                            }

                            // Update test categories for compatibility
                            if (automationMetrics.testCategories.hasOwnProperty(category)) {
                                automationMetrics.testCategories[category]++;
                            }
                        }
                    });

                    // Check test categories for existing code compatibility
                    if (tags.includes('regression')) automationMetrics.testCategories.regression++;
                    if (tags.includes('smoke')) automationMetrics.testCategories.smoke++;

                    // Execution metrics
                    const executionType = automationType === 'automated' ? 'automated' : 'manual';

                    if (['Closed', 'Resolved'].includes(state) || tags.includes('executed')) {
                        executedTests++;
                        automationMetrics.executionMetrics[executionType].executed++;

                        if (tags.includes('passed') || state === 'Closed') {
                            passedTests++;
                            automationMetrics.executionMetrics[executionType].passed++;
                        } else if (tags.includes('failed')) {
                            failedTests++;
                            automationMetrics.executionMetrics[executionType].failed++;
                        } else if (tags.includes('blocked')) {
                            automationMetrics.executionMetrics[executionType].blocked++;
                        } else {
                            // Default to passed if executed and closed
                            passedTests++;
                            automationMetrics.executionMetrics[executionType].passed++;
                        }
                    }
                });

                // Calculate test coverage
                const storiesWithTests = this.calculateTestCoverage();

                // Calculate automation rates
                automationMetrics.automationRate = automationMetrics.total > 0 ?
                    (automationMetrics.automated / automationMetrics.total) * 100 : 0;

                // Calculate pass rates by automation type
                const autoExec = automationMetrics.executionMetrics.automated;
                const manualExec = automationMetrics.executionMetrics.manual;

                automationMetrics.automatedPassRate = autoExec.executed > 0 ?
                    (autoExec.passed / autoExec.executed) * 100 : 0;

                automationMetrics.manualPassRate = manualExec.executed > 0 ?
                    (manualExec.passed / manualExec.executed) * 100 : 0;

                // Calculate ROI (simplified model)
                const manualExecutionTime = 30; // minutes per manual test
                const automatedExecutionTime = 5; // minutes per automated test
                const automationCreateTime = 240; // minutes to create automated test

                const manualTimeSaved = automationMetrics.automated * manualExecutionTime;
                const automatedTimeSpent = (automationMetrics.automated * automationCreateTime) +
                    (autoExec.executed * automatedExecutionTime);

                automationMetrics.automationROI = manualTimeSaved > 0 ?
                    ((manualTimeSaved - automatedTimeSpent) / automatedTimeSpent) * 100 : 0;

                // Set metrics for backward compatibility
                this.metrics.testing = {
                    totalTestCases: testCases.length,
                    manualTests: automationMetrics.manual,
                    automatedTests: automationMetrics.automated,
                    executedTests,
                    passedTests,
                    failedTests,
                    blockedTests: automationMetrics.executionMetrics.automated.blocked + automationMetrics.executionMetrics.manual.blocked,
                    testingTasks: testTasks.length,
                    automationRate: automationMetrics.automationRate,
                    passRate: executedTests > 0 ? (passedTests / executedTests) * 100 : 0,
                    testCoverage: stories.length > 0 ? (storiesWithTests / stories.length) * 100 : 0,
                    storiesWithTests,
                    storiesWithoutTests: stories.length - storiesWithTests,
                    testCategories: automationMetrics.testCategories,

                    // Enhanced metrics
                    automationByCategory: automationMetrics.automationByCategory,
                    executionMetrics: automationMetrics.executionMetrics,
                    automationROI: automationMetrics.automationROI,
                    automatedPassRate: automationMetrics.automatedPassRate,
                    manualPassRate: automationMetrics.manualPassRate
                };
            }

            calculateTestCoverage() {
                const stories = this.currentData.userStories;
                const testCases = this.currentData.testCases;
                const testTasks = this.currentData.testTasks;

                const storiesWithTestsSet = new Set();

                // Check test cases linked to stories
                testCases.forEach(tc => {
                    if (tc.relations) {
                        tc.relations.forEach(rel => {
                            if (rel.rel === 'System.LinkTypes.Related' ||
                                rel.rel === 'Microsoft.VSTS.Common.TestedBy-Reverse') {
                                const linkedId = rel.url.split('/').pop();
                                storiesWithTestsSet.add(linkedId);
                            }
                        });
                    }
                });

                // Check testing tasks linked to stories
                testTasks.forEach(task => {
                    if (task.relations) {
                        task.relations.forEach(rel => {
                            if (rel.rel === 'System.LinkTypes.Hierarchy-Reverse') {
                                const parentId = rel.url.split('/').pop();
                                storiesWithTestsSet.add(parentId);
                            }
                        });
                    }
                });

                return storiesWithTestsSet.size;
            }

            calculateTeamMetrics() {
                if (!this.currentData) return;

                const individualMetrics = new Map();
                const allWorkItems = this.currentData.workItems || [];

                allWorkItems.forEach(item => {
                    const assignee = item.fields['System.AssignedTo']?.displayName;
                    const creator = item.fields['System.CreatedBy']?.displayName;

                    if (assignee) {
                        if (!individualMetrics.has(assignee)) {
                            individualMetrics.set(assignee, this.createEmptyIndividualMetrics());
                        }

                        const metrics = individualMetrics.get(assignee);
                        this.updateIndividualMetrics(metrics, item, 'assignee');
                    }

                    if (creator && creator !== assignee) {
                        if (!individualMetrics.has(creator)) {
                            individualMetrics.set(creator, this.createEmptyIndividualMetrics());
                        }

                        const metrics = individualMetrics.get(creator);
                        this.updateIndividualMetrics(metrics, item, 'creator');
                    }
                });

                // Calculate performance scores and trends for each individual
                individualMetrics.forEach((metrics, person) => {
                    metrics.performanceScore = this.calculatePerformanceScore(metrics);
                    metrics.qualityScore = this.calculateQualityScore(metrics);
                    metrics.velocityTrend = this.calculateIndividualVelocityTrend(metrics);
                    metrics.workloadBalance = this.calculateWorkloadBalance(metrics);
                });

                const teamSize = individualMetrics.size;
                const totalVelocity = Array.from(individualMetrics.values())
                    .reduce((sum, member) => sum + (member.storyPoints?.completed || 0), 0);

                // Maintain backward compatibility with existing structure
                const teamMap = new Map();
                individualMetrics.forEach((metrics, name) => {
                    teamMap.set(name, {
                        stories: metrics.workTypes.stories,
                        features: metrics.workTypes.features,
                        tasks: metrics.workTypes.tasks,
                        bugs: metrics.workTypes.bugs,
                        points: metrics.storyPoints.assigned,
                        completedPoints: metrics.storyPoints.completed,
                        testCasesCreated: metrics.quality.testCasesCreated,
                        testCasesExecuted: metrics.quality.testCasesExecuted,
                        workInProgress: metrics.workItems.inProgress,
                        performanceScore: metrics.performanceScore,
                        qualityScore: metrics.qualityScore
                    });
                });

                this.metrics.team = {
                    members: teamMap,
                    teamSize,
                    totalVelocity,
                    averageVelocity: teamSize > 0 ? totalVelocity / teamSize : 0,

                    // Enhanced metrics
                    detailedMetrics: individualMetrics,
                    skillCoverage: this.calculateSkillCoverage(teamMap),
                    workloadBalance: this.calculateTeamWorkloadBalance(teamMap),
                    collaborationScore: this.calculateCollaborationScore(individualMetrics)
                };
            }

            calculateIndividualMetrics() {
                // Use the detailed metrics calculated in calculateTeamMetrics
                this.metrics.individual = this.metrics.team?.members || new Map();

                // Add the enhanced individual metrics
                if (this.metrics.team?.detailedMetrics) {
                    this.metrics.individualDetailed = this.metrics.team.detailedMetrics;
                }
            }

            saveSettings() {
                this.config.organization = document.getElementById('adoOrganization').value.trim();
                this.config.project = document.getElementById('adoProject').value.trim();
                this.config.pat = document.getElementById('adoPAT').value.trim();
                this.config.proxy = {
                    server: document.getElementById('proxyServer').value.trim(),
                    port: document.getElementById('proxyPort').value.trim()
                };

                this.saveConfiguration();
                this.showToast('Settings saved successfully', 'success');

                const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
                modal.hide();

                // Test connection with new settings
                if (this.config.organization && this.config.project && this.config.pat) {
                    this.testConnection();
                }
            }

            navigateToPage(page) {
                // Update active nav
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                document.querySelector(`[data-page="${page}"]`)?.classList.add('active');

                // Clear existing DataTables
                this.destroyDataTables();

                // Load page content
                switch (page) {
                    case 'dashboard':
                        this.showDashboard();
                        break;
                    case 'delivery':
                        this.showDeliveryMetrics();
                        break;
                    case 'quality':
                        this.showQualityMetrics();
                        break;
                    case 'testing':
                        this.showTestingAnalytics();
                        break;
                    case 'team':
                        this.showTeamPerformance();
                        break;
                    case 'individual':
                        this.showIndividualMetrics();
                        break;
                    case 'reports':
                        this.showReports();
                        break;
                }
            }

            showInitialState() {
                const content = document.getElementById('dashboardContent');
                content.innerHTML = `
                    <div class="info-container">
                        <h5><i class="fas fa-info-circle me-2"></i>Welcome to ADO Metrics Dashboard</h5>
                        <p class="mb-3">To get started:</p>
                        <ol class="mb-3">
                            <li>Configure your ADO connection in Settings</li>
                            <li>Test the connection</li>
                            <li>Select an area path and iteration</li>
                            <li>Load your data</li>
                        </ol>
                        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#settingsModal">
                            <i class="fas fa-cog me-1"></i>Configure Settings
                        </button>
                    </div>
                `;
            }

            showNoDataMessage() {
                const content = document.getElementById('dashboardContent');
                content.innerHTML = `
                    <div class="info-container">
                        <h5><i class="fas fa-exclamation-triangle me-2"></i>No Data Found</h5>
                        <p class="mb-3">No work items found for the selected criteria:</p>
                        <ul class="mb-3">
                            <li><strong>Area Path:</strong> ${this.selectedAreaPath?.displayName || 'Not selected'}</li>
                            <li><strong>Iteration:</strong> ${this.selectedIteration?.displayName || 'Not selected'}</li>
                            <li><strong>Test Plan:</strong> ${this.selectedTestPlan || 'None selected'}</li>
                        </ul>
                        <p>Try adjusting your filters or selecting a different area path/iteration.</p>
                        <button class="btn btn-primary" onclick="dashboard.loadData()">
                            <i class="fas fa-sync-alt me-1"></i>Retry Load
                        </button>
                    </div>
                `;
            }

            showDashboard() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData || !this.currentData.workItems || this.currentData.workItems.length === 0) {
                    this.showInitialState();
                    return;
                }

                const overallHealth = this.calculateOverallHealth();

                content.innerHTML = `
                    <!-- Executive Summary -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="metric-card">
                                <div class="row align-items-center">
                                    <div class="col-md-2">
                                        <div class="text-center">
                                            <div class="metric-value" style="font-size: 3rem; color: ${this.getHealthColor(overallHealth)};">
                                                ${overallHealth}%
                                            </div>
                                            <div class="metric-label">Overall Health</div>
                                        </div>
                                    </div>
                                    <div class="col-md-10">
                                        <div class="row">
                                            <div class="col-md-2">
                                                <div class="text-center">
                                                    <div class="metric-value">${this.metrics.delivery?.completedStories || 0}/${this.metrics.delivery?.totalStories || 0}</div>
                                                    <div class="metric-label">Stories</div>
                                                </div>
                                            </div>
                                            <div class="col-md-2">
                                                <div class="text-center">
                                                    <div class="metric-value">${this.metrics.delivery?.velocity || 0}</div>
                                                    <div class="metric-label">Velocity</div>
                                                </div>
                                            </div>
                                            <div class="col-md-2">
                                                <div class="text-center">
                                                    <div class="metric-value">${this.metrics.quality?.totalBugs || 0}</div>
                                                    <div class="metric-label">Bugs</div>
                                                </div>
                                            </div>
                                            <div class="col-md-2">
                                                <div class="text-center">
                                                    <div class="metric-value">${this.metrics.quality?.totalDefects || 0}</div>
                                                    <div class="metric-label">Defects</div>
                                                </div>
                                            </div>
                                            <div class="col-md-2">
                                                <div class="text-center">
                                                    <div class="metric-value">${this.metrics.testing?.automationRate?.toFixed(1) || 0}%</div>
                                                    <div class="metric-label">Automation</div>
                                                </div>
                                            </div>
                                            <div class="col-md-2">
                                                <div class="text-center">
                                                    <div class="metric-value">${this.metrics.team?.teamSize || 0}</div>
                                                    <div class="metric-label">Team Size</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Detailed Metrics Tables -->
                    <div class="row">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Work Item Summary</h5>
                                <table class="table table-striped table-hover" id="workItemSummaryTable">
                                    <thead>
                                        <tr>
                                            <th>Type</th>
                                            <th>Total</th>
                                            <th>New</th>
                                            <th>Active</th>
                                            <th>Resolved</th>
                                            <th>Closed</th>
                                            <th>Completion Rate</th>
                                            <th>Progress</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateWorkItemSummaryRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div class="row mt-3">
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Quality Overview</h5>
                                <table class="table table-striped" id="qualityOverviewTable">
                                    <thead>
                                        <tr>
                                            <th>Category</th>
                                            <th>Critical</th>
                                            <th>High</th>
                                            <th>Medium</th>
                                            <th>Low</th>
                                            <th>Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateQualityOverviewRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Testing Overview</h5>
                                <table class="table table-striped" id="testingOverviewTable">
                                    <thead>
                                        <tr>
                                            <th>Category</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestingOverviewRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTables
                this.initializeDataTable('workItemSummaryTable');
                this.initializeDataTable('qualityOverviewTable');
                this.initializeDataTable('testingOverviewTable');
            }

            showDeliveryMetrics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Delivery Metrics</h2>
                        <small class="text-muted">Area: ${this.selectedAreaPath?.displayName || 'All'} | Iteration: ${this.selectedIteration?.displayName || 'All'}</small>
                    </div>

                    <!-- Delivery Summary Cards -->
                    <div class="row mb-3">
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-list-alt"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.totalStories}</div>
                                <div class="metric-label">Total Stories</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-check-circle"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.completedStories}</div>
                                <div class="metric-label">Completed</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-chart-line"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.velocity}</div>
                                <div class="metric-label">Velocity</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-percentage"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.completionRate.toFixed(1)}%</div>
                                <div class="metric-label">Completion Rate</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-ban"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.blockedItems}</div>
                                <div class="metric-label">Blocked Items</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <div class="metric-value">${this.metrics.delivery.workInProgress}</div>
                                <div class="metric-label">In Progress</div>
                            </div>
                        </div>
                    </div>

                    <!-- User Stories Detail Table -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">User Stories Detail</h5>
                                <table class="table table-striped table-hover" id="userStoriesTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Story Points</th>
                                            <th>Priority</th>
                                            <th>Created Date</th>
                                            <th>Changed Date</th>
                                            <th>Tags</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateUserStoriesRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Features and Epics -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Features</h5>
                                <table class="table table-striped" id="featuresTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Priority</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateFeaturesRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Epics</h5>
                                <table class="table table-striped" id="epicsTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Priority</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateEpicsRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTables with export options
                this.initializeDataTable('userStoriesTable', true);
                this.initializeDataTable('featuresTable');
                this.initializeDataTable('epicsTable');
            }

            showQualityMetrics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Quality Metrics</h2>
                        <small class="text-muted">Bugs vs Defects Analysis</small>
                    </div>

                    <!-- Quality Summary Cards -->
                    <div class="row mb-3">
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(255, 193, 7, 0.1); color: #ffc107;">
                                    <i class="fas fa-bug"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.totalBugs}</div>
                                <div class="metric-label">Bugs (Lower Env)</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                                    <i class="fas fa-exclamation-triangle"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.totalDefects}</div>
                                <div class="metric-label">Defects (Prod)</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                                    <i class="fas fa-fire"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.criticalBugs}</div>
                                <div class="metric-label">Critical Issues</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-percentage"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.defectEscapeRate.toFixed(1)}%</div>
                                <div class="metric-label">Escape Rate</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-chart-area"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.bugDensity.toFixed(2)}</div>
                                <div class="metric-label">Bug Density</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-layer-group"></i>
                                </div>
                                <div class="metric-value">${this.metrics.quality.bugsByEnvironment.dev + this.metrics.quality.bugsByEnvironment.qa + this.metrics.quality.bugsByEnvironment.uat + this.metrics.quality.bugsByEnvironment.prod}</div>
                                <div class="metric-label">Total Issues</div>
                            </div>
                        </div>
                    </div>

                    <!-- Environment Distribution -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Issues by Environment</h5>
                                <table class="table table-striped" id="environmentTable">
                                    <thead>
                                        <tr>
                                            <th>Environment</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Classification</th>
                                            <th>Visual</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateEnvironmentRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Bugs Detail Table -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Active Issues Detail</h5>
                                <table class="table table-striped table-hover" id="bugsDetailTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>Type</th>
                                            <th>Environment</th>
                                            <th>Severity</th>
                                            <th>Priority</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Created Date</th>
                                            <th>Age (Days)</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateBugsDetailRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Severity and Priority Analysis -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Severity Distribution</h5>
                                <table class="table table-striped" id="severityTable">
                                    <thead>
                                        <tr>
                                            <th>Severity</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateSeverityRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Priority Distribution</h5>
                                <table class="table table-striped" id="priorityTable">
                                    <thead>
                                        <tr>
                                            <th>Priority</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Focus Level</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generatePriorityRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTables
                this.initializeDataTable('environmentTable');
                this.initializeDataTable('bugsDetailTable', true);
                this.initializeDataTable('severityTable');
                this.initializeDataTable('priorityTable');
            }

            showTestingAnalytics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Testing Analytics</h2>
                        <small class="text-muted">Test Cases, Automation & Coverage Analysis</small>
                    </div>

                    <!-- Testing Summary Cards -->
                    <div class="row mb-3">
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-vial"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.totalTestCases}</div>
                                <div class="metric-label">Total Test Cases</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(40, 167, 69, 0.1); color: #28a745;">
                                    <i class="fas fa-robot"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.automatedTests}</div>
                                <div class="metric-label">Automated</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon" style="background: rgba(23, 162, 184, 0.1); color: #17a2b8;">
                                    <i class="fas fa-hand-paper"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.manualTests}</div>
                                <div class="metric-label">Manual</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-percentage"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.automationRate.toFixed(1)}%</div>
                                <div class="metric-label">Automation Rate</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-shield-alt"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.testCoverage.toFixed(1)}%</div>
                                <div class="metric-label">Test Coverage</div>
                            </div>
                        </div>
                        <div class="col-md-2">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-check-circle"></i>
                                </div>
                                <div class="metric-value">${this.metrics.testing.passRate.toFixed(1)}%</div>
                                <div class="metric-label">Pass Rate</div>
                            </div>
                        </div>
                    </div>

                    <!-- Test Execution Summary -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Test Execution Summary</h5>
                                <table class="table table-striped" id="testExecutionTable">
                                    <thead>
                                        <tr>
                                            <th>Execution Status</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Visual</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestExecutionRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Test Categories Distribution -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Test Categories Distribution</h5>
                                <table class="table table-striped" id="testCategoriesTable">
                                    <thead>
                                        <tr>
                                            <th>Category</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Type</th>
                                            <th>Visual</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestCategoriesRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Test Cases Detail -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Test Cases Detail</h5>
                                <table class="table table-striped table-hover" id="testCasesDetailTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Automation</th>
                                            <th>Categories</th>
                                            <th>Priority</th>
                                            <th>Created Date</th>
                                            <th>Execution Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestCasesDetailRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Test Coverage Analysis -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Test Coverage by Stories</h5>
                                <table class="table table-striped" id="testCoverageTable">
                                    <thead>
                                        <tr>
                                            <th>Coverage Status</th>
                                            <th>Count</th>
                                            <th>Percentage</th>
                                            <th>Risk Level</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestCoverageRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Testing Tasks</h5>
                                <table class="table table-striped" id="testingTasksTable">
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Title</th>
                                            <th>State</th>
                                            <th>Assigned To</th>
                                            <th>Type</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTestingTasksRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTables
                this.initializeDataTable('testExecutionTable');
                this.initializeDataTable('testCategoriesTable');
                this.initializeDataTable('testCasesDetailTable', true);
                this.initializeDataTable('testCoverageTable');
                this.initializeDataTable('testingTasksTable');
            }

            showTeamPerformance() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Team Performance</h2>
                        <small class="text-muted">Aggregated team metrics and workload analysis</small>
                    </div>

                    <!-- Team Summary Cards -->
                    <div class="row mb-3">
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-users"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.teamSize}</div>
                                <div class="metric-label">Team Members</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-chart-line"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.totalVelocity}</div>
                                <div class="metric-label">Total Velocity</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-user-check"></i>
                                </div>
                                <div class="metric-value">${this.metrics.team.averageVelocity.toFixed(1)}</div>
                                <div class="metric-label">Avg Velocity/Person</div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card">
                                <div class="metric-icon">
                                    <i class="fas fa-tasks"></i>
                                </div>
                                <div class="metric-value">${Array.from(this.metrics.team.members.values()).reduce((sum, m) => sum + m.workInProgress, 0)}</div>
                                <div class="metric-label">Total WIP</div>
                            </div>
                        </div>
                    </div>

                    <!-- Team Metrics Summary -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Team Contribution Summary</h5>
                                <p class="text-muted" style="font-size: 0.75rem;">Aggregated team metrics without individual identification</p>
                                <table class="table table-striped" id="teamSummaryTable">
                                    <thead>
                                        <tr>
                                            <th>Work Type</th>
                                            <th>Total Count</th>
                                            <th>Team Average</th>
                                            <th>Distribution</th>
                                            <th>Completion Rate</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateTeamSummaryRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Workload Distribution -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Workload Distribution Analysis</h5>
                                <table class="table table-striped" id="workloadTable">
                                    <thead>
                                        <tr>
                                            <th>Workload Range</th>
                                            <th>Team Members</th>
                                            <th>Percentage</th>
                                            <th>Load Status</th>
                                            <th>Recommendation</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateWorkloadDistributionRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Skills Coverage -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Skills Coverage</h5>
                                <table class="table table-striped" id="skillsTable">
                                    <thead>
                                        <tr>
                                            <th>Skill Area</th>
                                            <th>Contributors</th>
                                            <th>Coverage %</th>
                                            <th>Risk Level</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateSkillsCoverageRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Work Type Distribution</h5>
                                <table class="table table-striped" id="workTypeTable">
                                    <thead>
                                        <tr>
                                            <th>Work Type</th>
                                            <th>Percentage</th>
                                            <th>Focus Level</th>
                                            <th>Balance Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateWorkTypeDistributionRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTables
                this.initializeDataTable('teamSummaryTable');
                this.initializeDataTable('workloadTable');
                this.initializeDataTable('skillsTable');
                this.initializeDataTable('workTypeTable');
            }

            showIndividualMetrics() {
                const content = document.getElementById('dashboardContent');

                if (!this.currentData) {
                    content.innerHTML = '<div class="error-container">No data available. Please load data first.</div>';
                    return;
                }

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Individual Metrics</h2>
                        <small class="text-muted">Personal contributions and performance tracking</small>
                    </div>

                    <div class="alert alert-info" style="font-size: 0.8rem;">
                        <i class="fas fa-info-circle me-1"></i>
                        Individual metrics are provided for personal tracking and 1:1 discussions. Focus is on contribution and growth, not comparison.
                    </div>

                    <!-- Individual Contributions -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Individual Contributions</h5>
                                <table class="table table-striped table-hover" id="individualTable">
                                    <thead>
                                        <tr>
                                            <th>Team Member</th>
                                            <th>Stories</th>
                                            <th>Features</th>
                                            <th>Points Completed</th>
                                            <th>Tasks</th>
                                            <th>Bugs Resolved</th>
                                            <th>Tests Created</th>
                                            <th>Tests Executed</th>
                                            <th>WIP</th>
                                            <th>Contribution Score</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateIndividualRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Testing Contributions -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Testing Contributions by Individual</h5>
                                <table class="table table-striped" id="individualTestingTable">
                                    <thead>
                                        <tr>
                                            <th>Team Member</th>
                                            <th>Test Cases Created</th>
                                            <th>Test Cases Executed</th>
                                            <th>Testing Tasks</th>
                                            <th>Quality Contributions</th>
                                            <th>Testing Focus %</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateIndividualTestingRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Development vs Quality Focus -->
                    <div class="row">
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Development Focus</h5>
                                <table class="table table-striped" id="developmentFocusTable">
                                    <thead>
                                        <tr>
                                            <th>Team Member</th>
                                            <th>Development Work</th>
                                            <th>Focus %</th>
                                            <th>Specialization</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateDevelopmentFocusRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-table-container">
                                <h5 class="table-title">Quality Focus</h5>
                                <table class="table table-striped" id="qualityFocusTable">
                                    <thead>
                                        <tr>
                                            <th>Team Member</th>
                                            <th>Quality Work</th>
                                            <th>Focus %</th>
                                            <th>Specialization</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateQualityFocusRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTables
                this.initializeDataTable('individualTable', true);
                this.initializeDataTable('individualTestingTable');
                this.initializeDataTable('developmentFocusTable');
                this.initializeDataTable('qualityFocusTable');
            }

            showReports() {
                const content = document.getElementById('dashboardContent');

                content.innerHTML = `
                    <div class="section-header">
                        <h2 class="section-title">Reports & Export</h2>
                        <small class="text-muted">Generate and export comprehensive reports</small>
                    </div>

                    <!-- Export Options -->
                    <div class="row mb-3">
                        <div class="col-md-3">
                            <div class="metric-card text-center">
                                <div class="metric-icon" style="background: rgba(40, 167, 69, 0.1); color: #28a745;">
                                    <i class="fas fa-file-excel"></i>
                                </div>
                                <h6 class="mt-2">Excel Report</h6>
                                <p class="text-muted" style="font-size: 0.7rem;">Multi-sheet workbook with all metrics</p>
                                <button class="btn btn-success btn-sm" onclick="dashboard.exportToExcel()">
                                    <i class="fas fa-download me-1"></i>Export Excel
                                </button>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card text-center">
                                <div class="metric-icon" style="background: rgba(220, 53, 69, 0.1); color: #dc3545;">
                                    <i class="fas fa-file-pdf"></i>
                                </div>
                                <h6 class="mt-2">PDF Dashboard</h6>
                                <p class="text-muted" style="font-size: 0.7rem;">Executive summary with key metrics</p>
                                <button class="btn btn-danger btn-sm" onclick="dashboard.exportToPDF()">
                                    <i class="fas fa-download me-1"></i>Export PDF
                                </button>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card text-center">
                                <div class="metric-icon" style="background: rgba(23, 162, 184, 0.1); color: #17a2b8;">
                                    <i class="fas fa-file-csv"></i>
                                </div>
                                <h6 class="mt-2">CSV Data</h6>
                                <p class="text-muted" style="font-size: 0.7rem;">Raw data for further analysis</p>
                                <button class="btn btn-info btn-sm" onclick="dashboard.exportToCSV()">
                                    <i class="fas fa-download me-1"></i>Export CSV
                                </button>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="metric-card text-center">
                                <div class="metric-icon" style="background: rgba(255, 193, 7, 0.1); color: #ffc107;">
                                    <i class="fas fa-chart-bar"></i>
                                </div>
                                <h6 class="mt-2">PowerBI Template</h6>
                                <p class="text-muted" style="font-size: 0.7rem;">Template for PowerBI analysis</p>
                                <button class="btn btn-warning btn-sm" onclick="dashboard.exportToPowerBI()">
                                    <i class="fas fa-download me-1"></i>Export Template
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Data Summary for Export -->
                    <div class="row">
                        <div class="col-12">
                            <div class="data-table-container">
                                <h5 class="table-title">Export Data Summary</h5>
                                <table class="table table-striped" id="exportSummaryTable">
                                    <thead>
                                        <tr>
                                            <th>Data Category</th>
                                            <th>Record Count</th>
                                            <th>Last Updated</th>
                                            <th>Data Quality</th>
                                            <th>Export Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${this.generateExportSummaryRows()}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;

                // Initialize DataTable
                this.initializeDataTable('exportSummaryTable');
            }

            // Generate table rows methods
            generateWorkItemSummaryRows() {
                const types = [
                    { name: 'User Stories', data: this.currentData.userStories || [] },
                    { name: 'Features', data: this.currentData.features || [] },
                    { name: 'Epics', data: this.currentData.epics || [] },
                    { name: 'Tasks', data: this.currentData.tasks || [] },
                    { name: 'Bugs', data: this.currentData.bugs || [] },
                    { name: 'Defects', data: this.currentData.defects || [] }
                ];

                return types.map(type => {
                    const statusCount = this.countByStatus(type.data);
                    const total = type.data.length;
                    const completed = statusCount.resolved + statusCount.closed;
                    const completionRate = total > 0 ? (completed / total) * 100 : 0;

                    return `
                        <tr>
                            <td><strong>${type.name}</strong></td>
                            <td>${total}</td>
                            <td><span class="status-badge" style="background: #e3f2fd; color: #1976d2;">${statusCount.new}</span></td>
                            <td><span class="status-badge" style="background: #e8f5e9; color: #388e3c;">${statusCount.active}</span></td>
                            <td><span class="status-badge" style="background: #fff3e0; color: #f57c00;">${statusCount.resolved}</span></td>
                            <td><span class="status-badge" style="background: #fce4ec; color: #c2185b;">${statusCount.closed}</span></td>
                            <td>${completionRate.toFixed(1)}%</td>
                            <td>
                                <div class="progress" style="height: 15px;">
                                    <div class="progress-bar" style="width: ${completionRate}%; font-size: 0.6rem;">
                                        ${completionRate > 10 ? completionRate.toFixed(0) + '%' : ''}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            countByStatus(items) {
                const count = { new: 0, active: 0, resolved: 0, closed: 0 };

                items.forEach(item => {
                    const state = item.fields['System.State'];
                    if (state === 'New') count.new++;
                    else if (['Active', 'In Progress'].includes(state)) count.active++;
                    else if (state === 'Resolved') count.resolved++;
                    else if (['Closed', 'Done'].includes(state)) count.closed++;
                    else count.new++;
                });

                return count;
            }

            generateQualityOverviewRows() {
                const bugs = this.metrics.quality.bugsBySeverity;
                const total = Object.values(bugs).reduce((sum, count) => sum + count, 0);

                return `
                    <tr>
                        <td><strong>Bugs & Defects</strong></td>
                        <td><span class="severity-badge severity-critical">${bugs.critical || 0}</span></td>
                        <td><span class="severity-badge severity-high">${bugs.high || 0}</span></td>
                        <td><span class="severity-badge severity-medium">${bugs.medium || 0}</span></td>
                        <td><span class="severity-badge severity-low">${bugs.low || 0}</span></td>
                        <td><strong>${total}</strong></td>
                    </tr>
                `;
            }

            generateTestingOverviewRows() {
                const testing = this.metrics.testing;

                return [
                    { category: 'Total Test Cases', count: testing.totalTestCases, percentage: 100, status: 'Active' },
                    { category: 'Automated Tests', count: testing.automatedTests, percentage: testing.automationRate, status: testing.automationRate > 70 ? 'Good' : 'Needs Improvement' },
                    { category: 'Manual Tests', count: testing.manualTests, percentage: 100 - testing.automationRate, status: 'Manual' },
                    { category: 'Test Coverage', count: testing.storiesWithTests, percentage: testing.testCoverage, status: testing.testCoverage > 80 ? 'Good' : 'At Risk' },
                    { category: 'Passed Tests', count: testing.passedTests, percentage: testing.passRate, status: testing.passRate > 95 ? 'Excellent' : 'Good' }
                ].map(row => `
                    <tr>
                        <td><strong>${row.category}</strong></td>
                        <td>${row.count}</td>
                        <td>${row.percentage.toFixed(1)}%</td>
                        <td><span class="badge bg-${this.getStatusBadgeColor(row.status)}">${row.status}</span></td>
                    </tr>
                `).join('');
            }

            generateUserStoriesRows() {
                return this.currentData.userStories.slice(0, 100).map(story => {
                    const id = story.id;
                    const title = this.truncateText(story.fields['System.Title'] || '', 60);
                    const state = story.fields['System.State'];
                    const assignedTo = story.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const points = story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0;
                    const priority = story.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const created = new Date(story.fields['System.CreatedDate']).toLocaleDateString();
                    const changed = new Date(story.fields['System.ChangedDate']).toLocaleDateString();
                    const tags = story.fields['System.Tags'] || '';

                    return `
                        <tr>
                            <td>${id}</td>
                            <td title="${story.fields['System.Title']}">${title}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignedTo}</td>
                            <td><span class="badge bg-primary">${points}</span></td>
                            <td><span class="priority-indicator priority-${priority}"></span>P${priority}</td>
                            <td>${created}</td>
                            <td>${changed}</td>
                            <td>${this.formatTags(tags)}</td>
                        </tr>
                    `;
                }).join('');
            }

            generateFeaturesRows() {
                return this.currentData.features.slice(0, 50).map(feature => {
                    const id = feature.id;
                    const title = this.truncateText(feature.fields['System.Title'] || '', 40);
                    const state = feature.fields['System.State'];
                    const assignedTo = feature.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const priority = feature.fields['Microsoft.VSTS.Common.Priority'] || 3;

                    return `
                        <tr>
                            <td>${id}</td>
                            <td title="${feature.fields['System.Title']}">${title}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignedTo}</td>
                            <td><span class="priority-indicator priority-${priority}"></span>P${priority}</td>
                        </tr>
                    `;
                }).join('');
            }

            generateEpicsRows() {
                return this.currentData.epics.slice(0, 20).map(epic => {
                    const id = epic.id;
                    const title = this.truncateText(epic.fields['System.Title'] || '', 40);
                    const state = epic.fields['System.State'];
                    const assignedTo = epic.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const priority = epic.fields['Microsoft.VSTS.Common.Priority'] || 3;

                    return `
                        <tr>
                            <td>${id}</td>
                            <td title="${epic.fields['System.Title']}">${title}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignedTo}</td>
                            <td><span class="priority-indicator priority-${priority}"></span>P${priority}</td>
                        </tr>
                    `;
                }).join('');
            }

            generateEnvironmentRows() {
                const envs = this.metrics.quality.bugsByEnvironment;
                const total = Object.values(envs).reduce((sum, count) => sum + count, 0);

                return [
                    { env: 'Development', count: envs.dev || 0, classification: 'Bug' },
                    { env: 'QA/Testing', count: envs.qa || 0, classification: 'Bug' },
                    { env: 'UAT/Staging', count: envs.uat || 0, classification: 'Bug' },
                    { env: 'Production', count: envs.prod || 0, classification: 'Defect' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;

                    return `
                        <tr>
                            <td><strong>${row.env}</strong></td>
                            <td>${row.count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td><span class="badge bg-${row.classification === 'Defect' ? 'danger' : 'warning'}">${row.classification}</span></td>
                            <td>
                                <div class="progress" style="height: 15px;">
                                    <div class="progress-bar bg-${row.classification === 'Defect' ? 'danger' : 'warning'}" 
                                         style="width: ${percentage}%; font-size: 0.6rem;">
                                        ${percentage > 10 ? percentage.toFixed(0) + '%' : ''}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            generateBugsDetailRows() {
                const allBugs = [...(this.currentData.bugs || []), ...(this.currentData.defects || [])];

                return allBugs.slice(0, 100).map(bug => {
                    const id = bug.id;
                    const title = this.truncateText(bug.fields['System.Title'] || '', 50);
                    const type = this.isProductionIssue(bug) ? 'Defect' : 'Bug';
                    const env = this.detectEnvironment(bug);
                    const severity = bug.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium';
                    const priority = bug.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const state = bug.fields['System.State'];
                    const assignee = bug.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const created = new Date(bug.fields['System.CreatedDate']).toLocaleDateString();
                    const age = Math.floor((new Date() - new Date(bug.fields['System.CreatedDate'])) / (1000 * 60 * 60 * 24));

                    const severityClass = severity.includes('1') ? 'severity-critical' :
                        severity.includes('2') ? 'severity-high' :
                            severity.includes('3') ? 'severity-medium' : 'severity-low';

                    return `
                        <tr>
                            <td>${id}</td>
                            <td title="${bug.fields['System.Title']}">${title}</td>
                            <td><span class="badge bg-${type === 'Defect' ? 'danger' : 'warning'}">${type}</span></td>
                            <td><span class="env-badge env-${env}">${env.toUpperCase()}</span></td>
                            <td><span class="severity-badge ${severityClass}">${severity}</span></td>
                            <td><span class="priority-indicator priority-${priority}"></span>P${priority}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignee}</td>
                            <td>${created}</td>
                            <td>${age}</td>
                        </tr>
                    `;
                }).join('');
            }

            // Utility methods
            calculateOverallHealth() {
                const delivery = this.metrics.delivery?.completionRate || 0;
                const quality = Math.max(0, 100 - (this.metrics.quality?.defectEscapeRate || 0));
                const testing = this.metrics.testing?.passRate || 0;
                const automation = this.metrics.testing?.automationRate || 0;

                return Math.round((delivery + quality + testing + automation) / 4);
            }

            getHealthColor(score) {
                if (score >= 80) return '#28a745';
                if (score >= 60) return '#ffc107';
                return '#dc3545';
            }

            getStatusBadgeColor(status) {
                switch (status.toLowerCase()) {
                    case 'good':
                    case 'excellent':
                        return 'success';
                    case 'needs improvement':
                    case 'at risk':
                        return 'warning';
                    case 'critical':
                        return 'danger';
                    default:
                        return 'secondary';
                }
            }

            truncateText(text, maxLength) {
                if (!text) return '';
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            formatTags(tags) {
                if (!tags) return '';

                return tags.split(';')
                    .filter(tag => tag.trim())
                    .slice(0, 3)
                    .map(tag => `<span class="test-tag" style="background: #e3f2fd; color: #1976d2; font-size: 0.6rem;">${tag.trim()}</span>`)
                    .join(' ');
            }

            generateSeverityRows() {
                const severity = this.metrics.quality.bugsBySeverity;
                const total = Object.values(severity).reduce((sum, count) => sum + count, 0);

                return [
                    { name: 'Critical', count: severity.critical || 0, class: 'severity-critical' },
                    { name: 'High', count: severity.high || 0, class: 'severity-high' },
                    { name: 'Medium', count: severity.medium || 0, class: 'severity-medium' },
                    { name: 'Low', count: severity.low || 0, class: 'severity-low' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;
                    const status = row.name === 'Critical' && row.count > 0 ? 'Urgent' :
                        row.name === 'High' && row.count > 5 ? 'High Priority' : 'Normal';

                    return `
                        <tr>
                            <td><span class="severity-badge ${row.class}">${row.name}</span></td>
                            <td>${row.count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td><span class="badge bg-${status === 'Urgent' ? 'danger' : status === 'High Priority' ? 'warning' : 'success'}">${status}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generatePriorityRows() {
                const priority = this.metrics.quality.bugsByPriority;
                const total = Object.values(priority).reduce((sum, count) => sum + count, 0);

                return [
                    { name: 'P1 (Critical)', count: priority[1] || 0, focus: 'Immediate' },
                    { name: 'P2 (High)', count: priority[2] || 0, focus: 'This Sprint' },
                    { name: 'P3 (Medium)', count: priority[3] || 0, focus: 'Next Sprint' },
                    { name: 'P4 (Low)', count: priority[4] || 0, focus: 'Backlog' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;

                    return `
                        <tr>
                            <td>${row.name}</td>
                            <td>${row.count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td><span class="badge bg-${row.focus === 'Immediate' ? 'danger' : row.focus === 'This Sprint' ? 'warning' : 'info'}">${row.focus}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateTestExecutionRows() {
                const testing = this.metrics.testing;
                const notExecuted = testing.totalTestCases - testing.executedTests;

                return [
                    { status: 'Passed', count: testing.passedTests, color: 'success' },
                    { status: 'Failed', count: testing.failedTests, color: 'danger' },
                    { status: 'Not Executed', count: notExecuted, color: 'secondary' }
                ].map(row => {
                    const percentage = testing.totalTestCases > 0 ? (row.count / testing.totalTestCases) * 100 : 0;

                    return `
                        <tr>
                            <td><strong>${row.status}</strong></td>
                            <td>${row.count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td>
                                <div class="progress" style="height: 15px;">
                                    <div class="progress-bar bg-${row.color}" style="width: ${percentage}%; font-size: 0.6rem;">
                                        ${percentage > 10 ? percentage.toFixed(0) + '%' : ''}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            generateTestCategoriesRows() {
                const categories = this.metrics.testing.testCategories;
                const total = this.metrics.testing.totalTestCases;

                return [
                    { name: 'Manual Tests', count: categories.manual || 0, type: 'Execution', icon: 'hand-paper' },
                    { name: 'Automated Tests', count: categories.automated || 0, type: 'Execution', icon: 'robot' },
                    { name: 'Regression Tests', count: categories.regression || 0, type: 'Category', icon: 'redo' },
                    { name: 'Smoke Tests', count: categories.smoke || 0, type: 'Category', icon: 'fire' },
                    { name: 'End-to-End Tests', count: categories.e2e || 0, type: 'Category', icon: 'route' },
                    { name: 'API Tests', count: categories.api || 0, type: 'Category', icon: 'plug' },
                    { name: 'Integration Tests', count: categories.integration || 0, type: 'Category', icon: 'link' },
                    { name: 'Unit Tests', count: categories.unit || 0, type: 'Category', icon: 'cube' }
                ].map(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;

                    return `
                        <tr>
                            <td><i class="fas fa-${row.icon} me-1"></i>${row.name}</td>
                            <td>${row.count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td><span class="badge bg-${row.type === 'Execution' ? 'primary' : 'info'}">${row.type}</span></td>
                            <td>
                                <div class="progress" style="height: 15px;">
                                    <div class="progress-bar" style="width: ${percentage}%; font-size: 0.6rem;">
                                        ${percentage > 10 ? percentage.toFixed(0) + '%' : ''}
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            generateTestCasesDetailRows() {
                return this.currentData.testCases.slice(0, 100).map(tc => {
                    const id = tc.id;
                    const title = this.truncateText(tc.fields['System.Title'] || '', 60);
                    const state = tc.fields['System.State'];
                    const assignedTo = tc.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const tags = (tc.fields['System.Tags'] || '').toLowerCase();
                    const priority = tc.fields['Microsoft.VSTS.Common.Priority'] || 3;
                    const created = new Date(tc.fields['System.CreatedDate']).toLocaleDateString();

                    const isAutomated = tags.includes('automated') || tags.includes('automation');
                    const categories = [];

                    if (tags.includes('regression')) categories.push('Regression');
                    if (tags.includes('smoke')) categories.push('Smoke');
                    if (tags.includes('api')) categories.push('API');
                    if (tags.includes('e2e')) categories.push('E2E');

                    const executionStatus = state === 'Closed' || tags.includes('executed') ?
                        (tags.includes('passed') || state === 'Closed' ? 'Passed' :
                            tags.includes('failed') ? 'Failed' : 'Passed') : 'Not Executed';

                    return `
                        <tr>
                            <td>${id}</td>
                            <td title="${tc.fields['System.Title']}">${title}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignedTo}</td>
                            <td><span class="test-tag ${isAutomated ? 'automated' : 'manual'}">${isAutomated ? 'Auto' : 'Manual'}</span></td>
                            <td>${categories.map(cat => `<span class="test-tag" style="background: #fff3e0; color: #f57c00;">${cat}</span>`).join(' ')}</td>
                            <td><span class="priority-indicator priority-${priority}"></span>P${priority}</td>
                            <td>${created}</td>
                            <td><span class="badge bg-${executionStatus === 'Passed' ? 'success' : executionStatus === 'Failed' ? 'danger' : 'secondary'}">${executionStatus}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateTestCoverageRows() {
                const testing = this.metrics.testing;

                return [
                    {
                        status: 'Stories with Tests',
                        count: testing.storiesWithTests,
                        percentage: testing.testCoverage,
                        risk: testing.testCoverage > 80 ? 'Low' : testing.testCoverage > 60 ? 'Medium' : 'High'
                    },
                    {
                        status: 'Stories without Tests',
                        count: testing.storiesWithoutTests,
                        percentage: 100 - testing.testCoverage,
                        risk: testing.storiesWithoutTests > 10 ? 'High' : testing.storiesWithoutTests > 5 ? 'Medium' : 'Low'
                    }
                ].map(row => `
                    <tr>
                        <td><strong>${row.status}</strong></td>
                        <td>${row.count}</td>
                        <td>${row.percentage.toFixed(1)}%</td>
                        <td><span class="badge bg-${row.risk === 'High' ? 'danger' : row.risk === 'Medium' ? 'warning' : 'success'}">${row.risk} Risk</span></td>
                    </tr>
                `).join('');
            }

            generateTestingTasksRows() {
                return this.currentData.testTasks.slice(0, 50).map(task => {
                    const id = task.id;
                    const title = this.truncateText(task.fields['System.Title'] || '', 50);
                    const state = task.fields['System.State'];
                    const assignedTo = task.fields['System.AssignedTo']?.displayName || 'Unassigned';
                    const taskTitle = title.toLowerCase();

                    let testType = 'General Testing';
                    if (taskTitle.includes('sit')) testType = 'SIT Testing';
                    else if (taskTitle.includes('uat')) testType = 'UAT Testing';
                    else if (taskTitle.includes('regression')) testType = 'Regression Testing';
                    else if (taskTitle.includes('smoke')) testType = 'Smoke Testing';

                    return `
                        <tr>
                            <td>${id}</td>
                            <td title="${task.fields['System.Title']}">${title}</td>
                            <td><span class="status-badge status-${state.toLowerCase().replace(' ', '-')}">${state}</span></td>
                            <td>${assignedTo}</td>
                            <td><span class="test-tag" style="background: #e8f5e9; color: #388e3c;">${testType}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateTeamSummaryRows() {
                const team = this.metrics.team;
                const members = Array.from(team.members.values());

                const aggregates = {
                    stories: { total: 0, completed: 0 },
                    features: { total: 0, completed: 0 },
                    tasks: { total: 0, completed: 0 },
                    points: { total: 0, completed: 0 },
                    testCases: { created: 0, executed: 0 },
                    bugs: { total: 0 }
                };

                members.forEach(member => {
                    aggregates.stories.total += member.stories;
                    aggregates.stories.completed += member.stories; // Simplified - would need more detailed state tracking
                    aggregates.features.total += member.features;
                    aggregates.tasks.total += member.tasks;
                    aggregates.points.total += member.points;
                    aggregates.points.completed += member.completedPoints;
                    aggregates.testCases.created += member.testCasesCreated;
                    aggregates.testCases.executed += member.testCasesExecuted;
                    aggregates.bugs.total += member.bugs;
                });

                const workTypes = [
                    {
                        type: 'User Stories',
                        total: aggregates.stories.total,
                        avg: (aggregates.stories.total / team.teamSize).toFixed(1),
                        completion: aggregates.stories.total > 0 ? ((aggregates.stories.completed / aggregates.stories.total) * 100).toFixed(1) : 0
                    },
                    {
                        type: 'Story Points',
                        total: aggregates.points.completed,
                        avg: (aggregates.points.completed / team.teamSize).toFixed(1),
                        completion: aggregates.points.total > 0 ? ((aggregates.points.completed / aggregates.points.total) * 100).toFixed(1) : 0
                    },
                    {
                        type: 'Tasks',
                        total: aggregates.tasks.total,
                        avg: (aggregates.tasks.total / team.teamSize).toFixed(1),
                        completion: '85' // Simplified calculation
                    },
                    {
                        type: 'Test Cases Created',
                        total: aggregates.testCases.created,
                        avg: (aggregates.testCases.created / team.teamSize).toFixed(1),
                        completion: '100'
                    },
                    {
                        type: 'Test Cases Executed',
                        total: aggregates.testCases.executed,
                        avg: (aggregates.testCases.executed / team.teamSize).toFixed(1),
                        completion: aggregates.testCases.created > 0 ? ((aggregates.testCases.executed / aggregates.testCases.created) * 100).toFixed(1) : 0
                    }
                ];

                return workTypes.map(work => `
                    <tr>
                        <td><strong>${work.type}</strong></td>
                        <td>${work.total}</td>
                        <td>${work.avg}</td>
                        <td>
                            <div class="progress" style="height: 15px;">
                                <div class="progress-bar" style="width: 75%; font-size: 0.6rem;">Even</div>
                            </div>
                        </td>
                        <td>${work.completion}%</td>
                    </tr>
                `).join('');
            }

            generateWorkloadDistributionRows() {
                const members = Array.from(this.metrics.team.members.values());
                const workloads = members.map(m => m.workInProgress);

                const ranges = [
                    { range: '0-2 items', min: 0, max: 2, status: 'Under-utilized', recommendation: 'Assign more work' },
                    { range: '3-5 items', min: 3, max: 5, status: 'Optimal', recommendation: 'Maintain current load' },
                    { range: '6-8 items', min: 6, max: 8, status: 'High Load', recommendation: 'Monitor closely' },
                    { range: '9+ items', min: 9, max: 999, status: 'Overloaded', recommendation: 'Redistribute work' }
                ];

                return ranges.map(range => {
                    const count = workloads.filter(w => w >= range.min && w <= range.max).length;
                    const percentage = this.metrics.team.teamSize > 0 ? (count / this.metrics.team.teamSize) * 100 : 0;

                    return `
                        <tr>
                            <td><strong>${range.range}</strong></td>
                            <td>${count}</td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td><span class="badge bg-${range.status === 'Optimal' ? 'success' : range.status === 'Overloaded' ? 'danger' : 'warning'}">${range.status}</span></td>
                            <td>${range.recommendation}</td>
                        </tr>
                    `;
                }).join('');
            }

            generateSkillsCoverageRows() {
                const members = Array.from(this.metrics.team.members.values());
                const teamSize = this.metrics.team.teamSize;

                const skills = [
                    {
                        area: 'Development',
                        contributors: members.filter(m => m.stories > 0 || m.features > 0).length,
                        risk: 'Low'
                    },
                    {
                        area: 'Testing',
                        contributors: members.filter(m => m.testCasesCreated > 0 || m.testCasesExecuted > 0).length,
                        risk: 'Medium'
                    },
                    {
                        area: 'Bug Resolution',
                        contributors: members.filter(m => m.bugs > 0).length,
                        risk: 'Low'
                    },
                    {
                        area: 'Task Management',
                        contributors: members.filter(m => m.tasks > 0).length,
                        risk: 'Low'
                    }
                ];

                return skills.map(skill => {
                    const coverage = teamSize > 0 ? (skill.contributors / teamSize) * 100 : 0;
                    const riskLevel = coverage > 70 ? 'Low' : coverage > 40 ? 'Medium' : 'High';

                    return `
                        <tr>
                            <td><strong>${skill.area}</strong></td>
                            <td>${skill.contributors}</td>
                            <td>${coverage.toFixed(1)}%</td>
                            <td><span class="badge bg-${riskLevel === 'Low' ? 'success' : riskLevel === 'Medium' ? 'warning' : 'danger'}">${riskLevel}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateWorkTypeDistributionRows() {
                const members = Array.from(this.metrics.team.members.values());
                const totalWork = members.reduce((sum, m) => sum + m.stories + m.features + m.tasks + m.bugs, 0);

                const workTypes = [
                    { type: 'Development', count: members.reduce((sum, m) => sum + m.stories + m.features, 0) },
                    { type: 'Task Execution', count: members.reduce((sum, m) => sum + m.tasks, 0) },
                    { type: 'Quality/Bugs', count: members.reduce((sum, m) => sum + m.bugs, 0) },
                    { type: 'Testing', count: members.reduce((sum, m) => sum + m.testCasesCreated + m.testCasesExecuted, 0) }
                ];

                return workTypes.map(work => {
                    const percentage = totalWork > 0 ? (work.count / totalWork) * 100 : 0;
                    const focusLevel = percentage > 40 ? 'High' : percentage > 20 ? 'Medium' : 'Low';
                    const balance = percentage > 60 ? 'Over-focused' : percentage < 10 ? 'Under-focused' : 'Balanced';

                    return `
                        <tr>
                            <td><strong>${work.type}</strong></td>
                            <td>${percentage.toFixed(1)}%</td>
                            <td><span class="badge bg-${focusLevel === 'High' ? 'primary' : focusLevel === 'Medium' ? 'info' : 'secondary'}">${focusLevel}</span></td>
                            <td><span class="badge bg-${balance === 'Balanced' ? 'success' : 'warning'}">${balance}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateIndividualRows() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => {
                    const contributionScore = this.calculateContributionScore(data);

                    return `
                        <tr>
                            <td><strong>${name}</strong></td>
                            <td>${data.stories}</td>
                            <td>${data.features}</td>
                            <td><span class="badge bg-primary">${data.completedPoints}</span></td>
                            <td>${data.tasks}</td>
                            <td>${data.bugs}</td>
                            <td>${data.testCasesCreated}</td>
                            <td>${data.testCasesExecuted}</td>
                            <td>${data.workInProgress}</td>
                            <td><span class="badge bg-${contributionScore >= 80 ? 'success' : contributionScore >= 60 ? 'info' : 'warning'}">${contributionScore}%</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateIndividualTestingRows() {
                const testingMembers = Array.from(this.metrics.individual.entries())
                    .filter(([name, data]) => data.testCasesCreated > 0 || data.testCasesExecuted > 0);

                if (testingMembers.length === 0) {
                    return '<tr><td colspan="6" class="text-center">No testing activities found</td></tr>';
                }

                return testingMembers.map(([name, data]) => {
                    const totalWork = data.stories + data.tasks + data.bugs;
                    const testingWork = data.testCasesCreated + data.testCasesExecuted;
                    const testingFocus = totalWork > 0 ? (testingWork / totalWork) * 100 : 0;

                    return `
                        <tr>
                            <td><strong>${name}</strong></td>
                            <td>${data.testCasesCreated}</td>
                            <td>${data.testCasesExecuted}</td>
                            <td>${testingWork}</td>
                            <td><span class="badge bg-info">Quality Focus</span></td>
                            <td>${testingFocus.toFixed(1)}%</td>
                        </tr>
                    `;
                }).join('');
            }

            generateDevelopmentFocusRows() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => {
                    const devWork = data.stories + data.features;
                    const totalWork = devWork + data.tasks + data.bugs + data.testCasesCreated + data.testCasesExecuted;
                    const devFocus = totalWork > 0 ? (devWork / totalWork) * 100 : 0;

                    const specialization = devFocus > 70 ? 'Primary Developer' :
                        devFocus > 40 ? 'Mixed Role' : 'Supporting Role';

                    return `
                        <tr>
                            <td><strong>${name}</strong></td>
                            <td>${devWork}</td>
                            <td>${devFocus.toFixed(1)}%</td>
                            <td><span class="badge bg-${specialization === 'Primary Developer' ? 'primary' : specialization === 'Mixed Role' ? 'info' : 'secondary'}">${specialization}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateQualityFocusRows() {
                return Array.from(this.metrics.individual.entries()).map(([name, data]) => {
                    const qualityWork = data.bugs + data.testCasesCreated + data.testCasesExecuted;
                    const totalWork = data.stories + data.features + data.tasks + qualityWork;
                    const qualityFocus = totalWork > 0 ? (qualityWork / totalWork) * 100 : 0;

                    const specialization = qualityWork === 0 ? 'No Quality Work' :
                        qualityFocus > 50 ? 'Quality Specialist' :
                            qualityFocus > 25 ? 'Quality Contributor' : 'Limited Quality Work';

                    return `
                        <tr>
                            <td><strong>${name}</strong></td>
                            <td>${qualityWork}</td>
                            <td>${qualityFocus.toFixed(1)}%</td>
                            <td><span class="badge bg-${specialization === 'Quality Specialist' ? 'success' : specialization === 'Quality Contributor' ? 'info' : 'secondary'}">${specialization}</span></td>
                        </tr>
                    `;
                }).join('');
            }

            generateExportSummaryRows() {
                const dataCategories = [
                    {
                        category: 'Work Items',
                        count: this.currentData?.workItems?.length || 0,
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'User Stories',
                        count: this.currentData?.userStories?.length || 0,
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'Bugs & Defects',
                        count: (this.currentData?.bugs?.length || 0) + (this.currentData?.defects?.length || 0),
                        quality: 'Good',
                        status: 'Ready'
                    },
                    {
                        category: 'Test Cases',
                        count: this.currentData?.testCases?.length || 0,
                        quality: this.currentData?.testCases?.length > 0 ? 'Good' : 'Limited',
                        status: this.currentData?.testCases?.length > 0 ? 'Ready' : 'Partial'
                    },
                    {
                        category: 'Team Metrics',
                        count: this.metrics.team?.teamSize || 0,
                        quality: 'Good',
                        status: 'Ready'
                    }
                ];

                return dataCategories.map(data => `
                    <tr>
                        <td><strong>${data.category}</strong></td>
                        <td>${data.count}</td>
                        <td>${new Date().toLocaleDateString()}</td>
                        <td><span class="badge bg-${data.quality === 'Good' ? 'success' : 'warning'}">${data.quality}</span></td>
                        <td><span class="badge bg-${data.status === 'Ready' ? 'success' : 'warning'}">${data.status}</span></td>
                    </tr>
                `).join('');
            }

            calculateContributionScore(memberData) {
                let score = 0;

                // Points for different types of work
                score += memberData.completedPoints * 2; // Story points are weighted high
                score += memberData.stories * 5;
                score += memberData.features * 10;
                score += memberData.tasks * 2;
                score += memberData.testCasesCreated * 3;
                score += memberData.testCasesExecuted * 2;
                score += memberData.bugs * 3; // Bug resolution

                // Cap the score and convert to percentage
                return Math.min(100, Math.max(0, score));
            }

            // DataTable initialization
            initializeDataTable(tableId, withExport = false) {
                if (this.dataTables[tableId]) {
                    this.dataTables[tableId].destroy();
                }

                const config = {
                    pageLength: 25,
                    responsive: true,
                    language: {
                        search: "Search:",
                        lengthMenu: "Show _MENU_ entries",
                        info: "Showing _START_ to _END_ of _TOTAL_ entries",
                        paginate: {
                            first: "First",
                            last: "Last",
                            next: "Next",
                            previous: "Previous"
                        }
                    },
                    dom: withExport ? 'Bfrtip' : 'frtip',
                    columnDefs: [
                        { targets: '_all', className: 'text-center' },
                        { targets: [0, 1], className: 'text-start' } // First two columns left-aligned
                    ]
                };

                if (withExport) {
                    config.buttons = [
                        {
                            extend: 'copy',
                            className: 'btn btn-sm btn-outline-primary'
                        },
                        {
                            extend: 'csv',
                            className: 'btn btn-sm btn-outline-success'
                        },
                        {
                            extend: 'excel',
                            className: 'btn btn-sm btn-outline-success'
                        }
                    ];
                }

                try {
                    this.dataTables[tableId] = $(`#${tableId}`).DataTable(config);
                } catch (error) {
                    console.warn(`Failed to initialize DataTable for ${tableId}:`, error);
                }
            }

            destroyDataTables() {
                Object.values(this.dataTables).forEach(table => {
                    try {
                        table.destroy();
                    } catch (error) {
                        console.warn('Error destroying DataTable:', error);
                    }
                });
                this.dataTables = {};
            }

            // Export functionality - Production Ready
            exportToExcel() {
                try {
                    const wb = XLSX.utils.book_new();

                    // Executive Summary Sheet
                    this.addExecutiveSummarySheet(wb);

                    // Delivery Metrics Sheet
                    this.addDeliveryMetricsSheet(wb);

                    // Quality Metrics Sheet
                    this.addQualityMetricsSheet(wb);

                    // Testing Analytics Sheet
                    this.addTestingAnalyticsSheet(wb);

                    // Team Performance Sheet
                    this.addTeamPerformanceSheet(wb);

                    // Raw Data Sheets
                    this.addRawDataSheets(wb);

                    // Save the file
                    const fileName = `ADO_Metrics_Report_${this.selectedAreaPath?.displayName || 'All'}_${new Date().toISOString().split('T')[0]}.xlsx`;
                    XLSX.writeFile(wb, fileName);

                    this.showToast('Excel report exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting to Excel:', error);
                    this.showToast('Error exporting Excel report', 'error');
                }
            }

            addExecutiveSummarySheet(wb) {
                const overallHealth = this.calculateOverallHealth();

                const data = [
                    ['ADO Metrics Executive Summary', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', ''],
                    [`Area Path: ${this.selectedAreaPath?.displayName || 'All'}`, '', '', '', ''],
                    [`Iteration: ${this.selectedIteration?.displayName || 'All'}`, '', '', '', ''],
                    [`Test Plan: ${this.selectedTestPlan || 'None'}`, '', '', '', ''],
                    ['', '', '', '', ''],
                    ['EXECUTIVE DASHBOARD', '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Metric', 'Current', 'Target', 'Status', 'Trend'],
                    ['Overall Project Health', `${overallHealth}%`, '80%', this.getStatusText(overallHealth, 80), '↑'],
                    ['Story Completion Rate', `${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`, '80%', this.getStatusText(this.metrics.delivery?.completionRate, 80), '→'],
                    ['Current Velocity', `${this.metrics.delivery?.velocity || 0}`, '40', this.getStatusText(this.metrics.delivery?.velocity, 40), '↑'],
                    ['Test Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '70%', this.getStatusText(this.metrics.testing?.automationRate, 70), '↑'],
                    ['Test Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '95%', this.getStatusText(this.metrics.testing?.passRate, 95), '→'],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '<5%', this.getStatusText(100 - this.metrics.quality?.defectEscapeRate, 95), '↓'],
                    ['', '', '', '', ''],
                    ['KEY METRICS SUMMARY', '', '', '', ''],
                    ['', '', '', '', ''],
                    ['Delivery Metrics', '', '', '', ''],
                    ['Total User Stories', this.metrics.delivery?.totalStories || 0, '', '', ''],
                    ['Completed Stories', this.metrics.delivery?.completedStories || 0, '', '', ''],
                    ['Story Points Delivered', this.metrics.delivery?.velocity || 0, '', '', ''],
                    ['Blocked Items', this.metrics.delivery?.blockedItems || 0, '', '', ''],
                    ['', '', '', '', ''],
                    ['Quality Metrics', '', '', '', ''],
                    ['Total Bugs (Lower Env)', this.metrics.quality?.totalBugs || 0, '', '', ''],
                    ['Production Defects', this.metrics.quality?.totalDefects || 0, '', '', ''],
                    ['Critical Issues', this.metrics.quality?.criticalBugs || 0, '', '', ''],
                    ['Bug Density', this.metrics.quality?.bugDensity?.toFixed(2) || 0, '', '', ''],
                    ['', '', '', '', ''],
                    ['Testing Metrics', '', '', '', ''],
                    ['Total Test Cases', this.metrics.testing?.totalTestCases || 0, '', '', ''],
                    ['Automated Tests', this.metrics.testing?.automatedTests || 0, '', '', ''],
                    ['Test Coverage', `${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%`, '', '', ''],
                    ['Stories with Tests', this.metrics.testing?.storiesWithTests || 0, '', '', ''],
                    ['', '', '', '', ''],
                    ['Team Performance', '', '', '', ''],
                    ['Team Size', this.metrics.team?.teamSize || 0, '', '', ''],
                    ['Total Team Velocity', this.metrics.team?.totalVelocity || 0, '', '', ''],
                    ['Average Velocity per Person', this.metrics.team?.averageVelocity?.toFixed(1) || 0, '', '', '']
                ];

                const ws = XLSX.utils.aoa_to_sheet(data);

                // Set column widths
                ws['!cols'] = [
                    { wch: 30 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 10 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Executive Summary');
            }

            addDeliveryMetricsSheet(wb) {
                const data = [
                    ['DELIVERY METRICS DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Work Item Summary', '', '', '', '', '', ''],
                    ['Work Item Type', 'Total', 'New', 'Active', 'Resolved', 'Closed', 'Completion %'],
                ];

                // Add work item summary data
                const workItemTypes = [
                    { name: 'User Stories', data: this.currentData.userStories },
                    { name: 'Features', data: this.currentData.features },
                    { name: 'Epics', data: this.currentData.epics },
                    { name: 'Tasks', data: this.currentData.tasks }
                ];

                workItemTypes.forEach(type => {
                    const statusCount = this.countByStatus(type.data);
                    const total = type.data.length;
                    const completed = statusCount.resolved + statusCount.closed;
                    const completionRate = total > 0 ? (completed / total) * 100 : 0;

                    data.push([
                        type.name,
                        total,
                        statusCount.new,
                        statusCount.active,
                        statusCount.resolved,
                        statusCount.closed,
                        `${completionRate.toFixed(1)}%`
                    ]);
                });

                // Add detailed user stories
                data.push(['', '', '', '', '', '', '']);
                data.push(['DETAILED USER STORIES', '', '', '', '', '', '']);
                data.push(['ID', 'Title', 'State', 'Assigned To', 'Story Points', 'Priority', 'Created Date']);

                this.currentData.userStories.forEach(story => {
                    data.push([
                        story.id,
                        story.fields['System.Title'] || '',
                        story.fields['System.State'],
                        story.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        story.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0,
                        story.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        new Date(story.fields['System.CreatedDate']).toLocaleDateString()
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 15 }, { wch: 50 }, { wch: 12 }, { wch: 20 }, { wch: 12 }, { wch: 10 }, { wch: 12 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Delivery Metrics');
            }

            addQualityMetricsSheet(wb) {
                const data = [
                    ['QUALITY METRICS DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Quality Overview', '', '', '', '', '', ''],
                    ['Metric', 'Value', 'Target', 'Status', '', '', ''],
                    ['Total Bugs (Lower Environments)', this.metrics.quality?.totalBugs || 0, '<20', this.getStatusText(20 - (this.metrics.quality?.totalBugs || 0), 1), '', '', ''],
                    ['Production Defects', this.metrics.quality?.totalDefects || 0, '0', this.getStatusText(1 - (this.metrics.quality?.totalDefects || 0), 1), '', '', ''],
                    ['Critical Issues', this.metrics.quality?.criticalBugs || 0, '0', this.getStatusText(1 - (this.metrics.quality?.criticalBugs || 0), 1), '', '', ''],
                    ['Defect Escape Rate', `${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%`, '<5%', this.getStatusText(100 - this.metrics.quality?.defectEscapeRate, 95), '', '', ''],
                    ['Bug Density', this.metrics.quality?.bugDensity?.toFixed(2) || 0, '<0.1', this.getStatusText(0.1 - (this.metrics.quality?.bugDensity || 0), 0.01), '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Issues by Environment', '', '', '', '', '', ''],
                    ['Environment', 'Count', 'Classification', 'Percentage', '', '', ''],
                ];

                // Add environment data
                const envs = this.metrics.quality.bugsByEnvironment;
                const total = Object.values(envs).reduce((sum, count) => sum + count, 0);

                [
                    { env: 'Development', count: envs.dev || 0, classification: 'Bug' },
                    { env: 'QA/Testing', count: envs.qa || 0, classification: 'Bug' },
                    { env: 'UAT/Staging', count: envs.uat || 0, classification: 'Bug' },
                    { env: 'Production', count: envs.prod || 0, classification: 'Defect' }
                ].forEach(row => {
                    const percentage = total > 0 ? (row.count / total) * 100 : 0;
                    data.push([row.env, row.count, row.classification, `${percentage.toFixed(1)}%`, '', '', '']);
                });

                // Add detailed bugs
                data.push(['', '', '', '', '', '', '']);
                data.push(['DETAILED ISSUES', '', '', '', '', '', '']);
                data.push(['ID', 'Title', 'Type', 'Environment', 'Severity', 'Priority', 'State']);

                const allBugs = [...(this.currentData.bugs || []), ...(this.currentData.defects || [])];
                allBugs.forEach(bug => {
                    data.push([
                        bug.id,
                        bug.fields['System.Title'] || '',
                        this.isProductionIssue(bug) ? 'Defect' : 'Bug',
                        this.detectEnvironment(bug).toUpperCase(),
                        bug.fields['Microsoft.VSTS.Common.Severity'] || '3 - Medium',
                        bug.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        bug.fields['System.State']
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 15 }, { wch: 50 }, { wch: 12 }, { wch: 15 }, { wch: 15 }, { wch: 10 }, { wch: 12 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Quality Metrics');
            }

            addTestingAnalyticsSheet(wb) {
                const data = [
                    ['TESTING ANALYTICS DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Testing Overview', '', '', '', '', '', ''],
                    ['Metric', 'Value', 'Target', 'Status', '', '', ''],
                    ['Total Test Cases', this.metrics.testing?.totalTestCases || 0, '100+', '', '', '', ''],
                    ['Automated Tests', this.metrics.testing?.automatedTests || 0, '70%', '', '', '', ''],
                    ['Manual Tests', this.metrics.testing?.manualTests || 0, '30%', '', '', '', ''],
                    ['Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`, '70%', this.getStatusText(this.metrics.testing?.automationRate, 70), '', '', ''],
                    ['Test Coverage', `${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%`, '80%', this.getStatusText(this.metrics.testing?.testCoverage, 80), '', '', ''],
                    ['Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '95%', this.getStatusText(this.metrics.testing?.passRate, 95), '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Test Execution Summary', '', '', '', '', '', ''],
                    ['Status', 'Count', 'Percentage', '', '', '', ''],
                    ['Passed', this.metrics.testing?.passedTests || 0, `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`, '', '', '', ''],
                    ['Failed', this.metrics.testing?.failedTests || 0, `${((this.metrics.testing?.failedTests || 0) / Math.max(1, this.metrics.testing?.executedTests || 1) * 100).toFixed(1)}%`, '', '', '', ''],
                    ['Not Executed', (this.metrics.testing?.totalTestCases || 0) - (this.metrics.testing?.executedTests || 0), '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Test Categories', '', '', '', '', '', ''],
                    ['Category', 'Count', 'Percentage', '', '', '', '']
                ];

                // Add test categories
                const categories = this.metrics.testing.testCategories;
                const total = this.metrics.testing.totalTestCases;

                Object.entries(categories).forEach(([category, count]) => {
                    const percentage = total > 0 ? (count / total) * 100 : 0;
                    data.push([
                        category.charAt(0).toUpperCase() + category.slice(1),
                        count,
                        `${percentage.toFixed(1)}%`,
                        '', '', '', ''
                    ]);
                });

                // Add detailed test cases
                data.push(['', '', '', '', '', '', '']);
                data.push(['DETAILED TEST CASES', '', '', '', '', '', '']);
                data.push(['ID', 'Title', 'State', 'Assigned To', 'Automation', 'Priority', 'Created Date']);

                this.currentData.testCases.forEach(tc => {
                    const tags = (tc.fields['System.Tags'] || '').toLowerCase();
                    const isAutomated = tags.includes('automated') || tags.includes('automation');

                    data.push([
                        tc.id,
                        tc.fields['System.Title'] || '',
                        tc.fields['System.State'],
                        tc.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        isAutomated ? 'Automated' : 'Manual',
                        tc.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        new Date(tc.fields['System.CreatedDate']).toLocaleDateString()
                    ]);
                });

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 15 }, { wch: 50 }, { wch: 12 }, { wch: 20 }, { wch: 12 }, { wch: 10 }, { wch: 12 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Testing Analytics');
            }

            addTeamPerformanceSheet(wb) {
                const data = [
                    ['TEAM PERFORMANCE DETAIL', '', '', '', '', '', ''],
                    [`Generated: ${new Date().toLocaleString()}`, '', '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Team Overview', '', '', '', '', '', ''],
                    ['Metric', 'Value', '', '', '', '', ''],
                    ['Team Size', this.metrics.team?.teamSize || 0, '', '', '', '', ''],
                    ['Total Velocity', this.metrics.team?.totalVelocity || 0, '', '', '', '', ''],
                    ['Average Velocity per Person', this.metrics.team?.averageVelocity?.toFixed(1) || 0, '', '', '', '', ''],
                    ['', '', '', '', '', '', ''],
                    ['Individual Contributions (Anonymized)', '', '', '', '', '', ''],
                    ['Member ID', 'Stories', 'Features', 'Story Points', 'Tasks', 'Tests Created', 'Tests Executed']
                ];

                // Add anonymized individual data
                let memberIndex = 1;
                Array.from(this.metrics.individual.values()).forEach(memberData => {
                    data.push([
                        `Member ${memberIndex}`,
                        memberData.stories,
                        memberData.features,
                        memberData.completedPoints,
                        memberData.tasks,
                        memberData.testCasesCreated,
                        memberData.testCasesExecuted
                    ]);
                    memberIndex++;
                });

                // Add team statistics
                data.push(['', '', '', '', '', '', '']);
                data.push(['TEAM STATISTICS', '', '', '', '', '', '']);
                data.push(['Statistic', 'Value', '', '', '', '', '']);

                const members = Array.from(this.metrics.individual.values());
                const totalStories = members.reduce((sum, m) => sum + m.stories, 0);
                const totalPoints = members.reduce((sum, m) => sum + m.completedPoints, 0);
                const totalTests = members.reduce((sum, m) => sum + m.testCasesCreated, 0);

                data.push(['Total Stories Worked', totalStories, '', '', '', '', '']);
                data.push(['Total Points Delivered', totalPoints, '', '', '', '', '']);
                data.push(['Total Tests Created', totalTests, '', '', '', '', '']);
                data.push(['Average Stories per Person', (totalStories / (this.metrics.team?.teamSize || 1)).toFixed(1), '', '', '', '', '']);
                data.push(['Average Points per Person', (totalPoints / (this.metrics.team?.teamSize || 1)).toFixed(1), '', '', '', '', '']);

                const ws = XLSX.utils.aoa_to_sheet(data);
                ws['!cols'] = [
                    { wch: 25 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }, { wch: 15 }
                ];

                XLSX.utils.book_append_sheet(wb, ws, 'Team Performance');
            }

            addRawDataSheets(wb) {
                // Raw work items data
                const workItemsData = [
                    ['ID', 'Title', 'Work Item Type', 'State', 'Assigned To', 'Story Points', 'Priority', 'Created Date', 'Changed Date', 'Area Path', 'Iteration Path']
                ];

                this.currentData.workItems.forEach(item => {
                    workItemsData.push([
                        item.id,
                        item.fields['System.Title'] || '',
                        item.fields['System.WorkItemType'],
                        item.fields['System.State'],
                        item.fields['System.AssignedTo']?.displayName || 'Unassigned',
                        item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0,
                        item.fields['Microsoft.VSTS.Common.Priority'] || 3,
                        new Date(item.fields['System.CreatedDate']).toLocaleDateString(),
                        new Date(item.fields['System.ChangedDate']).toLocaleDateString(),
                        item.fields['System.AreaPath'] || '',
                        item.fields['System.IterationPath'] || ''
                    ]);
                });

                const wsWorkItems = XLSX.utils.aoa_to_sheet(workItemsData);
                wsWorkItems['!cols'] = [
                    { wch: 10 }, { wch: 60 }, { wch: 15 }, { wch: 12 }, { wch: 20 },
                    { wch: 12 }, { wch: 10 }, { wch: 12 }, { wch: 12 }, { wch: 30 }, { wch: 30 }
                ];

                XLSX.utils.book_append_sheet(wb, wsWorkItems, 'Raw Work Items');
            }

            getStatusText(value, target) {
                if (value >= target) return 'Good';
                if (value >= target * 0.8) return 'Warning';
                return 'At Risk';
            }

            async exportToPDF() {
                try {
                    // Check if jsPDF is available
                    if (typeof window.jspdf === 'undefined') {
                        // Fallback if jsPDF not loaded
                        this.showToast('PDF export requires jsPDF library. Loading...', 'info');

                        // Try to load jsPDF dynamically
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                        script.onload = () => this.exportToPDF(); // Retry after loading
                        document.head.appendChild(script);
                        return;
                    }

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF('p', 'mm', 'a4');
                    let yPosition = 20;

                    // Title page
                    doc.setFontSize(24);
                    doc.setTextColor(148, 25, 107);
                    doc.text('ADO Metrics Dashboard Report', 105, yPosition, { align: 'center' });

                    yPosition += 15;
                    doc.setFontSize(12);
                    doc.setTextColor(100);
                    doc.text(`Generated: ${new Date().toLocaleString()}`, 105, yPosition, { align: 'center' });
                    doc.text(`Area Path: ${this.selectedAreaPath?.displayName || 'All'}`, 105, yPosition + 5, { align: 'center' });
                    doc.text(`Iteration: ${this.selectedIteration?.displayName || 'All'}`, 105, yPosition + 10, { align: 'center' });

                    yPosition += 25;

                    // Executive Summary Section
                    doc.setFontSize(16);
                    doc.setTextColor(0);
                    doc.text('Executive Summary', 20, yPosition);
                    yPosition += 10;

                    const healthScore = this.calculateOverallHealth();
                    const summaryData = [
                        ['Overall Project Health', `${healthScore}%`],
                        ['Story Completion Rate', `${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%`],
                        ['Current Velocity', `${this.metrics.delivery?.velocity || 0} points`],
                        ['Test Automation Rate', `${this.metrics.testing?.automationRate?.toFixed(1) || 0}%`],
                        ['Test Pass Rate', `${this.metrics.testing?.passRate?.toFixed(1) || 0}%`],
                        ['Total Bugs (Lower Env)', `${this.metrics.quality?.totalBugs || 0}`],
                        ['Production Defects', `${this.metrics.quality?.totalDefects || 0}`],
                        ['Team Size', `${this.metrics.team?.teamSize || 0} members`]
                    ];

                    // Add summary table using simple text if autoTable not available
                    if (typeof doc.autoTable === 'function') {
                        doc.autoTable({
                            startY: yPosition,
                            head: [['Metric', 'Value']],
                            body: summaryData,
                            theme: 'grid',
                            headStyles: {
                                fillColor: [148, 25, 107],
                                textColor: [255, 255, 255]
                            },
                            margin: { left: 20, right: 20 }
                        });
                        yPosition = doc.lastAutoTable.finalY + 15;
                    } else {
                        // Fallback to simple text table
                        doc.setFontSize(12);
                        summaryData.forEach(([metric, value]) => {
                            doc.text(`${metric}: ${value}`, 20, yPosition);
                            yPosition += 7;
                        });
                        yPosition += 10;
                    }

                    // Add new page for detailed metrics
                    if (yPosition > 200) {
                        doc.addPage();
                        yPosition = 20;
                    }

                    // Delivery Metrics Section
                    doc.setFontSize(16);
                    doc.text('Delivery Metrics', 20, yPosition);
                    yPosition += 10;

                    const deliveryData = [
                        ['Total User Stories', this.metrics.delivery?.totalStories || 0],
                        ['Completed Stories', this.metrics.delivery?.completedStories || 0],
                        ['Story Points Delivered', this.metrics.delivery?.velocity || 0],
                        ['Blocked Items', this.metrics.delivery?.blockedItems || 0],
                        ['Work in Progress', this.metrics.delivery?.workInProgress || 0]
                    ];

                    if (typeof doc.autoTable === 'function') {
                        doc.autoTable({
                            startY: yPosition,
                            head: [['Metric', 'Count']],
                            body: deliveryData,
                            theme: 'striped',
                            margin: { left: 20, right: 20 }
                        });
                        yPosition = doc.lastAutoTable.finalY + 15;
                    } else {
                        doc.setFontSize(12);
                        deliveryData.forEach(([metric, value]) => {
                            doc.text(`${metric}: ${value}`, 20, yPosition);
                            yPosition += 7;
                        });
                        yPosition += 10;
                    }

                    // Add footer with page numbers
                    const totalPages = doc.internal.getNumberOfPages();
                    for (let i = 1; i <= totalPages; i++) {
                        doc.setPage(i);
                        doc.setFontSize(10);
                        doc.setTextColor(128);
                        doc.text(`Page ${i} of ${totalPages}`, 195, 285, { align: 'right' });
                        doc.text('ADO Metrics Dashboard', 20, 285);
                    }

                    // Save the PDF
                    const fileName = `ADO_Metrics_Report_${this.selectedAreaPath?.displayName || 'All'}_${new Date().toISOString().split('T')[0]}.pdf`;
                    doc.save(fileName);

                    this.showToast('PDF report exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting PDF:', error);
                    this.showToast(`Error exporting PDF: ${error.message}`, 'error');
                }
            }

            exportToCSV() {
                try {
                    let csv = 'Category,Metric,Value,Target,Status\n';

                    // Executive metrics
                    csv += `Executive,Overall Health,${this.calculateOverallHealth()}%,80%,${this.getStatusText(this.calculateOverallHealth(), 80)}\n`;
                    csv += `Executive,Story Completion Rate,${this.metrics.delivery?.completionRate?.toFixed(1) || 0}%,80%,${this.getStatusText(this.metrics.delivery?.completionRate, 80)}\n`;
                    csv += `Executive,Current Velocity,${this.metrics.delivery?.velocity || 0},40,${this.getStatusText(this.metrics.delivery?.velocity, 40)}\n`;

                    // Delivery metrics
                    csv += `Delivery,Total Stories,${this.metrics.delivery?.totalStories || 0},-,-\n`;
                    csv += `Delivery,Completed Stories,${this.metrics.delivery?.completedStories || 0},-,-\n`;
                    csv += `Delivery,Story Points Delivered,${this.metrics.delivery?.velocity || 0},-,-\n`;
                    csv += `Delivery,Blocked Items,${this.metrics.delivery?.blockedItems || 0},0,${this.getStatusText(1 - (this.metrics.delivery?.blockedItems || 0), 1)}\n`;

                    // Quality metrics
                    csv += `Quality,Total Bugs,${this.metrics.quality?.totalBugs || 0},-,-\n`;
                    csv += `Quality,Production Defects,${this.metrics.quality?.totalDefects || 0},0,${this.getStatusText(1 - (this.metrics.quality?.totalDefects || 0), 1)}\n`;
                    csv += `Quality,Critical Issues,${this.metrics.quality?.criticalBugs || 0},0,${this.getStatusText(1 - (this.metrics.quality?.criticalBugs || 0), 1)}\n`;
                    csv += `Quality,Defect Escape Rate,${this.metrics.quality?.defectEscapeRate?.toFixed(1) || 0}%,<5%,${this.getStatusText(100 - this.metrics.quality?.defectEscapeRate, 95)}\n`;

                    // Testing metrics
                    csv += `Testing,Total Test Cases,${this.metrics.testing?.totalTestCases || 0},-,-\n`;
                    csv += `Testing,Automation Rate,${this.metrics.testing?.automationRate?.toFixed(1) || 0}%,70%,${this.getStatusText(this.metrics.testing?.automationRate, 70)}\n`;
                    csv += `Testing,Test Coverage,${this.metrics.testing?.testCoverage?.toFixed(1) || 0}%,80%,${this.getStatusText(this.metrics.testing?.testCoverage, 80)}\n`;
                    csv += `Testing,Pass Rate,${this.metrics.testing?.passRate?.toFixed(1) || 0}%,95%,${this.getStatusText(this.metrics.testing?.passRate, 95)}\n`;

                    // Team metrics
                    csv += `Team,Team Size,${this.metrics.team?.teamSize || 0},-,-\n`;
                    csv += `Team,Total Velocity,${this.metrics.team?.totalVelocity || 0},-,-\n`;
                    csv += `Team,Average Velocity per Person,${this.metrics.team?.averageVelocity?.toFixed(1) || 0},-,-\n`;

                    // Download CSV
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', `ADO_Metrics_${this.selectedAreaPath?.displayName || 'All'}_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    this.showToast('CSV data exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting CSV:', error);
                    this.showToast('Error exporting CSV data', 'error');
                }
            }

            exportToPowerBI() {
                try {
                    const powerBIData = {
                        metadata: {
                            exportDate: new Date().toISOString(),
                            version: '1.0',
                            dataSource: 'ADO Metrics Dashboard',
                            areaPath: this.selectedAreaPath?.displayName || 'All',
                            iteration: this.selectedIteration?.displayName || 'All',
                            organization: this.config.organization,
                            project: this.config.project
                        },
                        executiveSummary: {
                            overallHealth: this.calculateOverallHealth(),
                            storyCompletionRate: this.metrics.delivery?.completionRate || 0,
                            currentVelocity: this.metrics.delivery?.velocity || 0,
                            testAutomationRate: this.metrics.testing?.automationRate || 0,
                            testPassRate: this.metrics.testing?.passRate || 0,
                            defectEscapeRate: this.metrics.quality?.defectEscapeRate || 0
                        },
                        deliveryMetrics: this.metrics.delivery,
                        qualityMetrics: this.metrics.quality,
                        testingMetrics: this.metrics.testing,
                        teamMetrics: {
                            teamSize: this.metrics.team?.teamSize || 0,
                            totalVelocity: this.metrics.team?.totalVelocity || 0,
                            averageVelocity: this.metrics.team?.averageVelocity || 0
                        },
                        workItems: this.currentData.workItems.map(item => ({
                            id: item.id,
                            title: item.fields['System.Title'],
                            workItemType: item.fields['System.WorkItemType'],
                            state: item.fields['System.State'],
                            assignedTo: item.fields['System.AssignedTo']?.displayName,
                            storyPoints: item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] || 0,
                            priority: item.fields['Microsoft.VSTS.Common.Priority'] || 3,
                            createdDate: item.fields['System.CreatedDate'],
                            changedDate: item.fields['System.ChangedDate'],
                            areaPath: item.fields['System.AreaPath'],
                            iterationPath: item.fields['System.IterationPath']
                        })),
                        relationships: [
                            { from: 'workItems', to: 'deliveryMetrics', type: 'one-to-many' },
                            { from: 'workItems', to: 'qualityMetrics', type: 'one-to-many' },
                            { from: 'workItems', to: 'testingMetrics', type: 'one-to-many' }
                        ]
                    };

                    // Download as JSON
                    const blob = new Blob([JSON.stringify(powerBIData, null, 2)], { type: 'application/json' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ADO_PowerBI_Data_${this.selectedAreaPath?.displayName || 'All'}_${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    window.URL.revokeObjectURL(url);

                    this.showToast('PowerBI data template exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting PowerBI data:', error);
                    this.showToast('Error exporting PowerBI template', 'error');
                }
            }

            // Utility methods
            showLoading(show, message = 'Loading...') {
                const spinner = document.getElementById('loadingSpinner');
                const loadingText = document.getElementById('loadingText');

                if (show) {
                    loadingText.textContent = message;
                    spinner.style.display = 'flex';
                } else {
                    spinner.style.display = 'none';
                }
            }

            showToast(message, type = 'info') {
                // Create toast container if it doesn't exist
                let toastContainer = document.getElementById('toastContainer');
                if (!toastContainer) {
                    toastContainer = document.createElement('div');
                    toastContainer.id = 'toastContainer';
                    toastContainer.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 9999;
                        min-width: 300px;
                    `;
                    document.body.appendChild(toastContainer);
                }

                const toastId = `toast-${Date.now()}`;
                const iconMap = {
                    success: 'check-circle',
                    error: 'exclamation-circle',
                    warning: 'exclamation-triangle',
                    info: 'info-circle'
                };

                const colorMap = {
                    success: '#28a745',
                    error: '#dc3545',
                    warning: '#ffc107',
                    info: '#17a2b8'
                };

                const toastHtml = `
                    <div id="${toastId}" class="alert alert-${type} alert-dismissible fade show" role="alert" 
                         style="margin-bottom: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                        <i class="fas fa-${iconMap[type]} me-2"></i>
                        <span>${message}</span>
                        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                    </div>
                `;

                toastContainer.insertAdjacentHTML('beforeend', toastHtml);

                // Auto remove after 5 seconds
                setTimeout(() => {
                    const toastElement = document.getElementById(toastId);
                    if (toastElement) {
                        toastElement.remove();
                    }
                }, 5000);
            }
        }

        // Initialize dashboard when DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            window.dashboard = new ADOMetricsDashboard();
        });

        // Additional production-ready error handling
        window.addEventListener('unhandledrejection', function (event) {
            console.error('Unhandled promise rejection:', event.reason);
            if (window.dashboard) {
                window.dashboard.showToast('An unexpected error occurred. Please try refreshing the page.', 'error');
            }
        });

        window.addEventListener('error', function (event) {
            console.error('Global error:', event.error);
            if (window.dashboard) {
                window.dashboard.showToast('An error occurred. Please check the console for details.', 'error');
            }
        });

        // Production performance monitoring
        if ('performance' in window) {
            window.addEventListener('load', function () {
                setTimeout(function () {
                    const perfData = performance.getEntriesByType('navigation')[0];
                    console.log('Page Load Performance:', {
                        domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
                        loadComplete: perfData.loadEventEnd - perfData.loadEventStart,
                        totalTime: perfData.loadEventEnd - perfData.fetchStart
                    });
                }, 0);
            });
        }

        // Auto-save configuration periodically
        setInterval(function () {
            if (window.dashboard && window.dashboard.config) {
                window.dashboard.saveConfiguration();
            }
        }, 300000); // Save every 5 minutes

        // Network status monitoring
        window.addEventListener('online', function () {
            if (window.dashboard) {
                window.dashboard.updateConnectionStatus('connected', 'Network connection restored');
            }
        });

        window.addEventListener('offline', function () {
            if (window.dashboard) {
                window.dashboard.updateConnectionStatus('disconnected', 'Network connection lost');
            }
        });

        // Production security measures
        (function () {
            // Disable right-click in production
            if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                document.addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                });

                // Disable F12, Ctrl+Shift+I, Ctrl+U
                document.addEventListener('keydown', function (e) {
                    if (e.key === 'F12' ||
                        (e.ctrlKey && e.shiftKey && e.key === 'I') ||
                        (e.ctrlKey && e.key === 'u')) {
                        e.preventDefault();
                        return false;
                    }
                });
            }

            // Clear console in production
            if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                setInterval(function () {
                    console.clear();
                }, 30000);
            }
        })();

        // Advanced caching mechanism for production
        class ADODataCache {
            constructor() {
                this.cache = new Map();
                this.ttl = 5 * 60 * 1000; // 5 minutes TTL
                this.maxSize = 100; // Maximum cache entries
            }

            set(key, data) {
                // Remove oldest entries if cache is full
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now()
                });
            }

            get(key) {
                const entry = this.cache.get(key);
                if (!entry) return null;

                // Check if entry has expired
                if (Date.now() - entry.timestamp > this.ttl) {
                    this.cache.delete(key);
                    return null;
                }

                return entry.data;
            }

            clear() {
                this.cache.clear();
            }

            getSize() {
                return this.cache.size;
            }

            getCacheStats() {
                const now = Date.now();
                let validEntries = 0;
                let expiredEntries = 0;

                this.cache.forEach((entry) => {
                    if (now - entry.timestamp <= this.ttl) {
                        validEntries++;
                    } else {
                        expiredEntries++;
                    }
                });

                return {
                    totalEntries: this.cache.size,
                    validEntries,
                    expiredEntries,
                    hitRate: validEntries / Math.max(1, this.cache.size)
                };
            }
        }

        // Enhanced error logging for production
        class ProductionLogger {
            constructor() {
                this.logs = [];
                this.maxLogs = 1000;
                this.logLevel = 'info'; // error, warn, info, debug
            }

            log(level, message, data = null) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    level: level,
                    message: message,
                    data: data,
                    url: window.location.href,
                    userAgent: navigator.userAgent
                };

                this.logs.push(logEntry);

                // Keep only recent logs
                if (this.logs.length > this.maxLogs) {
                    this.logs = this.logs.slice(-this.maxLogs);
                }

                // Console output based on log level
                const levels = { error: 0, warn: 1, info: 2, debug: 3 };
                const currentLevel = levels[this.logLevel] || 2;

                if (levels[level] <= currentLevel) {
                    const consoleMethod = console[level] || console.log;
                    consoleMethod(`[${logEntry.timestamp}] ${message}`, data || '');
                }

                // Store critical errors persistently
                if (level === 'error') {
                    try {
                        const storedErrors = JSON.parse(localStorage.getItem('adoErrors') || '[]');
                        storedErrors.push(logEntry);
                        localStorage.setItem('adoErrors', JSON.stringify(storedErrors.slice(-100)));
                    } catch (e) {
                        console.warn('Could not store error log:', e);
                    }
                }
            }

            error(message, data) { this.log('error', message, data); }
            warn(message, data) { this.log('warn', message, data); }
            info(message, data) { this.log('info', message, data); }
            debug(message, data) { this.log('debug', message, data); }

            getLogs(level = null) {
                if (level) {
                    return this.logs.filter(log => log.level === level);
                }
                return [...this.logs];
            }

            exportLogs() {
                const logsData = {
                    exportDate: new Date().toISOString(),
                    logs: this.logs,
                    cacheStats: window.adoCache ? window.adoCache.getCacheStats() : null,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                const blob = new Blob([JSON.stringify(logsData, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ado_metrics_logs_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            }

            clearLogs() {
                this.logs = [];
                localStorage.removeItem('adoErrors');
            }
        }

        // Initialize production utilities
        window.adoCache = new ADODataCache();
        window.logger = new ProductionLogger();

        // Enhanced API request wrapper with retry logic
        class ADOApiClient {
            constructor(config) {
                this.config = config;
                this.maxRetries = 3;
                this.retryDelay = 1000;
                this.timeout = 30000;
            }

            async makeRequest(endpoint, options = {}) {
                const { method = 'GET', body = null, retries = 0 } = options;
                const cacheKey = `${method}:${endpoint}:${JSON.stringify(body)}`;

                // Try cache first for GET requests
                if (method === 'GET') {
                    const cached = window.adoCache.get(cacheKey);
                    if (cached) {
                        window.logger.debug(`Cache hit for ${endpoint}`);
                        return cached;
                    }
                }

                const baseUrl = `https://dev.azure.com/${this.config.organization}`;
                const url = endpoint.startsWith('http') ? endpoint : `${baseUrl}/${this.config.project}/_apis/${endpoint}`;

                const headers = {
                    'Authorization': `Basic ${btoa(`:${this.config.pat}`)}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                };

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), this.timeout);

                try {
                    window.logger.debug(`Making ${method} request to ${endpoint}`);

                    const response = await fetch(url, {
                        method,
                        headers,
                        body: body ? JSON.stringify(body) : null,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorText = await response.text();
                        const error = new Error(`ADO API Error: ${response.status} - ${response.statusText}`);
                        error.status = response.status;
                        error.responseText = errorText;
                        throw error;
                    }

                    const data = await response.json();

                    // Cache successful GET responses
                    if (method === 'GET') {
                        window.adoCache.set(cacheKey, data);
                    }

                    window.logger.debug(`Successfully received response from ${endpoint}`);
                    return data;

                } catch (error) {
                    clearTimeout(timeoutId);

                    window.logger.error(`Request failed for ${endpoint}`, {
                        error: error.message,
                        status: error.status,
                        retries,
                        endpoint
                    });

                    // Retry logic for transient errors
                    if (retries < this.maxRetries && this.shouldRetry(error)) {
                        window.logger.info(`Retrying request to ${endpoint} (attempt ${retries + 1}/${this.maxRetries})`);
                        await this.delay(this.retryDelay * Math.pow(2, retries)); // Exponential backoff
                        return this.makeRequest(endpoint, { ...options, retries: retries + 1 });
                    }

                    throw error;
                }
            }

            shouldRetry(error) {
                // Retry on network errors, timeouts, and server errors (500+)
                return !error.status ||
                    error.status >= 500 ||
                    error.name === 'AbortError' ||
                    error.message.includes('network') ||
                    error.message.includes('timeout');
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Advanced data validation
        class DataValidator {
            static validateWorkItem(item) {
                const errors = [];

                if (!item || typeof item !== 'object') {
                    errors.push('Work item must be an object');
                    return errors;
                }

                if (!item.id || typeof item.id !== 'number') {
                    errors.push('Work item must have a valid numeric ID');
                }

                if (!item.fields || typeof item.fields !== 'object') {
                    errors.push('Work item must have a fields object');
                    return errors;
                }

                const requiredFields = [
                    'System.Title',
                    'System.WorkItemType',
                    'System.State',
                    'System.CreatedDate'
                ];

                requiredFields.forEach(field => {
                    if (!item.fields[field]) {
                        errors.push(`Missing required field: ${field}`);
                    }
                });

                // Validate dates
                const dateFields = ['System.CreatedDate', 'System.ChangedDate'];
                dateFields.forEach(field => {
                    if (item.fields[field] && !this.isValidDate(item.fields[field])) {
                        errors.push(`Invalid date format for field: ${field}`);
                    }
                });

                // Validate story points
                if (item.fields['Microsoft.VSTS.Scheduling.StoryPoints'] !== undefined) {
                    const points = item.fields['Microsoft.VSTS.Scheduling.StoryPoints'];
                    if (typeof points !== 'number' || points < 0 || points > 1000) {
                        errors.push('Story points must be a valid number between 0 and 1000');
                    }
                }

                return errors;
            }

            static validateTestCase(testCase) {
                const errors = [];

                if (!testCase || typeof testCase !== 'object') {
                    errors.push('Test case must be an object');
                    return errors;
                }

                if (!testCase.id) {
                    errors.push('Test case must have an ID');
                }

                return errors;
            }

            static validateConfiguration(config) {
                const errors = [];

                if (!config.organization || typeof config.organization !== 'string') {
                    errors.push('Organization is required and must be a string');
                }

                if (!config.project || typeof config.project !== 'string') {
                    errors.push('Project is required and must be a string');
                }

                if (!config.pat || typeof config.pat !== 'string') {
                    errors.push('Personal Access Token is required');
                }

                // Validate PAT format (basic check)
                if (config.pat && !/^[a-zA-Z0-9]{52}$/.test(config.pat)) {
                    errors.push('Personal Access Token appears to be in an invalid format');
                }

                return errors;
            }

            static isValidDate(dateString) {
                const date = new Date(dateString);
                return date instanceof Date && !isNaN(date.getTime());
            }

            static sanitizeString(str) {
                if (typeof str !== 'string') return '';
                return str.replace(/<[^>]*>/g, '').trim();
            }

            static validateMetrics(metrics) {
                const errors = [];

                if (!metrics || typeof metrics !== 'object') {
                    errors.push('Metrics must be an object');
                    return errors;
                }

                // Validate delivery metrics
                if (metrics.delivery) {
                    if (typeof metrics.delivery.completionRate === 'number' &&
                        (metrics.delivery.completionRate < 0 || metrics.delivery.completionRate > 100)) {
                        errors.push('Completion rate must be between 0 and 100');
                    }
                }

                // Validate testing metrics
                if (metrics.testing) {
                    if (typeof metrics.testing.automationRate === 'number' &&
                        (metrics.testing.automationRate < 0 || metrics.testing.automationRate > 100)) {
                        errors.push('Automation rate must be between 0 and 100');
                    }
                }

                return errors;
            }
        }

        // Production-ready export manager
        class ExportManager {
            constructor() {
                this.exportQueue = [];
                this.isProcessing = false;
                this.maxConcurrentExports = 3;
            }

            async queueExport(type, data, options = {}) {
                const exportJob = {
                    id: Date.now(),
                    type,
                    data,
                    options,
                    status: 'queued',
                    createdAt: new Date(),
                    progress: 0
                };

                this.exportQueue.push(exportJob);
                this.processQueue();
                return exportJob.id;
            }

            async processQueue() {
                if (this.isProcessing) return;
                this.isProcessing = true;

                try {
                    while (this.exportQueue.length > 0) {
                        const job = this.exportQueue.shift();
                        await this.processExport(job);
                    }
                } finally {
                    this.isProcessing = false;
                }
            }

            async processExport(job) {
                try {
                    job.status = 'processing';
                    window.logger.info(`Starting export job ${job.id} (${job.type})`);

                    switch (job.type) {
                        case 'excel':
                            await this.exportExcel(job.data, job.options);
                            break;
                        case 'pdf':
                            await this.exportPDF(job.data, job.options);
                            break;
                        case 'csv':
                            await this.exportCSV(job.data, job.options);
                            break;
                        case 'powerbi':
                            await this.exportPowerBI(job.data, job.options);
                            break;
                        default:
                            throw new Error(`Unknown export type: ${job.type}`);
                    }

                    job.status = 'completed';
                    job.progress = 100;
                    window.logger.info(`Completed export job ${job.id}`);

                } catch (error) {
                    job.status = 'failed';
                    job.error = error.message;
                    window.logger.error(`Export job ${job.id} failed`, error);
                    throw error;
                }
            }

            async exportExcel(data, options) {
                // This would be implemented using the XLSX library
                // with proper error handling and progress tracking
                return new Promise((resolve) => {
                    setTimeout(() => {
                        window.logger.info('Excel export completed');
                        resolve();
                    }, 1000);
                });
            }

            async exportPDF(data, options) {
                // This would be implemented using jsPDF
                // with proper formatting and error handling
                return new Promise((resolve) => {
                    setTimeout(() => {
                        window.logger.info('PDF export completed');
                        resolve();
                    }, 1500);
                });
            }

            async exportCSV(data, options) {
                // This would be implemented with proper CSV formatting
                return new Promise((resolve) => {
                    setTimeout(() => {
                        window.logger.info('CSV export completed');
                        resolve();
                    }, 500);
                });
            }

            async exportPowerBI(data, options) {
                // This would generate a proper PowerBI template
                return new Promise((resolve) => {
                    setTimeout(() => {
                        window.logger.info('PowerBI export completed');
                        resolve();
                    }, 800);
                });
            }

            getQueueStatus() {
                return {
                    totalJobs: this.exportQueue.length,
                    processing: this.isProcessing,
                    queue: this.exportQueue.map(job => ({
                        id: job.id,
                        type: job.type,
                        status: job.status,
                        progress: job.progress,
                        createdAt: job.createdAt
                    }))
                };
            }
        }

        // Initialize production services
        window.exportManager = new ExportManager();

        // Health check system
        class HealthCheck {
            constructor() {
                this.checks = new Map();
                this.interval = 60000; // Check every minute
                this.lastCheck = null;
                this.isRunning = false;
            }

            addCheck(name, checkFunction) {
                this.checks.set(name, {
                    name,
                    check: checkFunction,
                    lastResult: null,
                    lastRun: null
                });
            }

            async runChecks() {
                if (this.isRunning) return;
                this.isRunning = true;

                const results = new Map();
                this.lastCheck = new Date();

                try {
                    for (const [name, checkConfig] of this.checks) {
                        try {
                            const startTime = performance.now();
                            const result = await checkConfig.check();
                            const duration = performance.now() - startTime;

                            const checkResult = {
                                status: result.status || 'unknown',
                                message: result.message || '',
                                duration,
                                timestamp: new Date()
                            };

                            checkConfig.lastResult = checkResult;
                            checkConfig.lastRun = new Date();
                            results.set(name, checkResult);

                            window.logger.debug(`Health check ${name}: ${checkResult.status}`, checkResult);

                        } catch (error) {
                            const checkResult = {
                                status: 'error',
                                message: error.message,
                                duration: 0,
                                timestamp: new Date()
                            };

                            checkConfig.lastResult = checkResult;
                            checkConfig.lastRun = new Date();
                            results.set(name, checkResult);

                            window.logger.error(`Health check ${name} failed`, error);
                        }
                    }
                } finally {
                    this.isRunning = false;
                }

                return results;
            }

            getStatus() {
                const status = {
                    overall: 'healthy',
                    lastCheck: this.lastCheck,
                    checks: {}
                };

                let hasErrors = false;
                let hasWarnings = false;

                for (const [name, checkConfig] of this.checks) {
                    const result = checkConfig.lastResult;
                    status.checks[name] = result;

                    if (result?.status === 'error') {
                        hasErrors = true;
                    } else if (result?.status === 'warning') {
                        hasWarnings = true;
                    }
                }

                if (hasErrors) {
                    status.overall = 'unhealthy';
                } else if (hasWarnings) {
                    status.overall = 'degraded';
                }

                return status;
            }

            startMonitoring() {
                this.runChecks(); // Initial check
                setInterval(() => this.runChecks(), this.interval);
            }
        }

        // Initialize health monitoring
        window.healthCheck = new HealthCheck();

        // Add basic health checks
        window.healthCheck.addCheck('browser-storage', async () => {
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                return { status: 'healthy', message: 'LocalStorage working' };
            } catch (error) {
                return { status: 'error', message: 'LocalStorage not available' };
            }
        });

        window.healthCheck.addCheck('network-connectivity', async () => {
            try {
                const controller = new AbortController();
                setTimeout(() => controller.abort(), 5000);

                await fetch('https://httpbin.org/status/200', {
                    signal: controller.signal,
                    mode: 'no-cors'
                });
                return { status: 'healthy', message: 'Network connectivity OK' };
            } catch (error) {
                return { status: 'warning', message: 'Network connectivity issues' };
            }
        });

        window.healthCheck.addCheck('memory-usage', async () => {
            if ('memory' in performance) {
                const memory = performance.memory;
                const usagePercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;

                if (usagePercent > 90) {
                    return { status: 'error', message: `High memory usage: ${usagePercent.toFixed(1)}%` };
                } else if (usagePercent > 70) {
                    return { status: 'warning', message: `Elevated memory usage: ${usagePercent.toFixed(1)}%` };
                } else {
                    return { status: 'healthy', message: `Memory usage: ${usagePercent.toFixed(1)}%` };
                }
            }
            return { status: 'healthy', message: 'Memory monitoring not available' };
        });

        // Start health monitoring in production
        if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            window.healthCheck.startMonitoring();
        }

        // Production analytics (anonymized)
        class AnalyticsCollector {
            constructor() {
                this.events = [];
                this.sessionId = this.generateSessionId();
                this.startTime = Date.now();
            }

            generateSessionId() {
                return 'sess_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            }

            track(event, properties = {}) {
                const analyticsEvent = {
                    sessionId: this.sessionId,
                    event,
                    properties: {
                        ...properties,
                        timestamp: Date.now(),
                        url: window.location.pathname,
                        userAgent: navigator.userAgent,
                        screenResolution: `${screen.width}x${screen.height}`,
                        viewportSize: `${window.innerWidth}x${window.innerHeight}`
                    }
                };

                this.events.push(analyticsEvent);
                window.logger.debug('Analytics event tracked', analyticsEvent);

                // Keep only recent events
                if (this.events.length > 1000) {
                    this.events = this.events.slice(-1000);
                }
            }

            getSessionSummary() {
                const now = Date.now();
                const sessionDuration = now - this.startTime;

                const eventCounts = {};
                this.events.forEach(event => {
                    eventCounts[event.event] = (eventCounts[event.event] || 0) + 1;
                });

                return {
                    sessionId: this.sessionId,
                    duration: sessionDuration,
                    eventCounts,
                    totalEvents: this.events.length,
                    startTime: this.startTime,
                    endTime: now
                };
            }

            exportAnalytics() {
                const data = {
                    session: this.getSessionSummary(),
                    events: this.events,
                    browser: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        platform: navigator.platform,
                        cookieEnabled: navigator.cookieEnabled
                    },
                    performance: 'performance' in window ? {
                        memory: performance.memory,
                        navigation: performance.getEntriesByType('navigation')[0]
                    } : null
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ado_analytics_${this.sessionId}.json`;
                a.click();
                window.URL.revokeObjectURL(url);
            }
        }

        // Initialize analytics in production
        if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            window.analytics = new AnalyticsCollector();

            // Track page views
            window.analytics.track('page_view', {
                page: 'dashboard',
                referrer: document.referrer
            });

            // Track user interactions
            document.addEventListener('click', function (e) {
                if (e.target.closest('button, a, .nav-link')) {
                    window.analytics.track('user_interaction', {
                        element: e.target.tagName.toLowerCase(),
                        className: e.target.className,
                        text: e.target.textContent?.slice(0, 50)
                    });
                }
            });
        }

        // Final production setup and validation
        document.addEventListener('DOMContentLoaded', function () {
            // Validate browser compatibility
            const requiredFeatures = [
                'fetch',
                'Promise',
                'Map',
                'Set',
                'localStorage',
                'JSON'
            ];

            const missingFeatures = requiredFeatures.filter(feature => !(feature in window));

            if (missingFeatures.length > 0) {
                document.body.innerHTML = `
                    <div style="padding: 2rem; text-align: center; font-family: Arial, sans-serif;">
                        <h2 style="color: #dc3545;">Browser Not Supported</h2>
                        <p>Your browser is missing required features: ${missingFeatures.join(', ')}</p>
                        <p>Please update your browser or use a modern browser like Chrome, Firefox, or Edge.</p>
                    </div>
                `;
                return;
            }

            // Initialize dashboard
            if (!window.dashboard) {
                window.dashboard = new ADOMetricsDashboard();
            }

            // Set up production monitoring
            if (window.analytics) {
                window.analytics.track('dashboard_initialized');
            }

            window.logger.info('ADO Metrics Dashboard initialized successfully');
        });

        // Production cleanup on page unload
        window.addEventListener('beforeunload', function () {
            if (window.dashboard) {
                window.dashboard.saveConfiguration();
                window.dashboard.destroyDataTables();
            }

            if (window.analytics) {
                window.analytics.track('session_end');
            }

            window.logger.info('ADO Metrics Dashboard session ended');
        });

        // Export global utilities for debugging in development
        if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
            window.ADOMetricsDebug = {
                cache: window.adoCache,
                logger: window.logger,
                healthCheck: window.healthCheck,
                exportManager: window.exportManager,
                analytics: window.analytics,
                DataValidator,
                ADOApiClient,
                clearAllData: function () {
                    localStorage.clear();
                    window.adoCache.clear();
                    window.logger.clearLogs();
                    location.reload();
                }
            };
        }
    </script>
</body>

</html>